
#Область ЧетвертыйФорматОбмена

// Формирует XML-файл 4-й версии обмена для передачи на сайт.
//
Функция СформироватьФайлXMLЧетвертыйФормат(СтруктураВыгрузки, НастройкаДоступа, ТипФайла, ИспользоватьЛогиныВВерсии4 = Ложь, ОбновлятьПараметрыДоступа = Ложь) Экспорт
	
	Если НЕ ЗначениеЗаполнено(СтруктураВыгрузки) ИЛИ НЕ ТипЗнч(СтруктураВыгрузки) = Тип("Структура") ИЛИ НЕ ЗначениеЗаполнено(ТипФайла) Тогда
		// Если неопределенное значение.
		Возврат Неопределено;
	КонецЕсли;
	
	Если ТипФайла = "calculations" Тогда
		
		// Получаем имя временного файла.
		ИмяВременногоФайла = ПолучитьИмяВременногоФайла("xml");
		
		// Выгружать ли персональные данные.
		ВыгружатьПерсональныеДанные = НЕ НастройкаДоступа.НеВыгружатьПерсональныеДанные;
		
		// Создаем XML файл.
		ЗаписьXML = Новый ЗаписьXML;
		ЗаписьXML.ОткрытьФайл(ИмяВременногоФайла, "windows-1251");
		
		// Записываем сведения об организации в элемент "org".
		ДокументDOM = Новый ДокументDOM("", "org");
		
		КорневойЭлемент = СформироватьИЗаполнитьXMLКорневойЭлемент(СтруктураВыгрузки, ДокументDOM);
		
		// Статистическая информация о файле.
		ЗаполнитьXMLИнформациюОПередаваемыхДанных(СтруктураВыгрузки, ДокументDOM, КорневойЭлемент);
		
		// Ограничение периода ввода показаний.
		ЗаполнитьXMLСведенияОбОграниченииВводаПоказаний(СтруктураВыгрузки, ДокументDOM, КорневойЭлемент);
		
		// Все поставщики.
		ЗаполнитьXMLСведениямиПоПоставщикам(СтруктураВыгрузки, ДокументDOM, КорневойЭлемент);
		
		// Дома.
		ЗаполнитьXMLСведениямиПоЗданиям(СтруктураВыгрузки, ДокументDOM, КорневойЭлемент);
		
		// Подготовка данных по л/с.
		Если СтруктураВыгрузки.ВыгрузкаДанныхПоЛС Тогда
			ЗаполнитьXMLСведениямиПоЛС(СтруктураВыгрузки, ДокументDOM, КорневойЭлемент);
			ЗаполнитьXMLСведенияПоЛСЗаДополнительныйПериод(СтруктураВыгрузки, ДокументDOM, КорневойЭлемент);
		КонецЕсли;
		
	ИначеЕсли ТипФайла = "access" Тогда
		
		// Получаем имя временного файла.
		ИмяВременногоФайла = ПолучитьИмяВременногоФайла("xml");
		
		// Создаем XML файл.
		ЗаписьXML = Новый ЗаписьXML;
		ЗаписьXML.ОткрытьФайл(ИмяВременногоФайла, "windows-1251");
		
		// Записываем сведения об организации в элемент "org".
		ДокументDOM = Новый ДокументDOM("", "org");
		КорневойЭлемент = ДокументDOM.ЭлементДокумента;
		
		УстановитьЗначениеАтрибута(КорневойЭлемент, "name",     СтруктураВыгрузки.name);
		УстановитьЗначениеАтрибута(КорневойЭлемент, "inn",      СтруктураВыгрузки.inn);
		УстановитьЗначениеАтрибута(КорневойЭлемент, "filedate", СтруктураВыгрузки.filedate);
		УстановитьЗначениеАтрибута(КорневойЭлемент, "filetype", СтруктураВыгрузки.filetype);
		УстановитьЗначениеАтрибута(КорневойЭлемент, "version",  СтруктураВыгрузки.version);
		
		Если ОбновлятьПараметрыДоступа Тогда
			УстановитьЗначениеАтрибута(КорневойЭлемент, "rewrite", "true");
		КонецЕсли;
		
		Для каждого ТекСтрока из СтруктураВыгрузки.accs Цикл
			
			ТекЛС = ДокументDOM.СоздатьЭлемент("acc");
			КорневойЭлемент.ДобавитьДочерний(ТекЛС);
			
			УстановитьЗначениеАтрибута(ТекЛС, "id",   ТекСтрока.id);
			УстановитьЗначениеАтрибута(ТекЛС, "name", ТекСтрока.name);
			
			Если ИспользоватьЛогиныВВерсии4 Тогда
				УстановитьЗначениеАтрибута(ТекЛС, "login", ТекСтрока.login);
			КонецЕсли;
			
			УстановитьЗначениеАтрибута(ТекЛС, "pin",   ТекСтрока.pin);
			УстановитьЗначениеАтрибута(ТекЛС, "email", ТекСтрока.email);
			
		КонецЦикла;
		
	КонецЕсли;
	
	ЗаписьDOM = Новый ЗаписьDOM();
	ЗаписьDOM.Записать(ДокументDOM, ЗаписьXML);
	
	ЗаписьXML.Закрыть();
	
	Возврат ИмяВременногоФайла;
	
КонецФункции

// Формирует корневой тег и заполняет информацией о файле XML-документ.
//
Функция СформироватьИЗаполнитьXMLКорневойЭлемент(СтруктураВыгрузки, ДокументDOM)
	
	КорневойЭлемент = ДокументDOM.ЭлементДокумента;
	
	УстановитьЗначениеАтрибута(КорневойЭлемент, "filedate", СтруктураВыгрузки.filedate);
	УстановитьЗначениеАтрибута(КорневойЭлемент, "filetype", СтруктураВыгрузки.filetype);
	УстановитьЗначениеАтрибута(КорневойЭлемент, "version",  СтруктураВыгрузки.version);
	УстановитьЗначениеАтрибута(КорневойЭлемент, "ready",    СтруктураВыгрузки.ready);
	УстановитьЗначениеАтрибута(КорневойЭлемент, "name",     СтруктураВыгрузки.name);
	УстановитьЗначениеАтрибута(КорневойЭлемент, "inn",      СтруктураВыгрузки.inn);
	УстановитьЗначениеАтрибута(КорневойЭлемент, "kpp",      СтруктураВыгрузки.kpp);
	УстановитьЗначениеАтрибута(КорневойЭлемент, "bank",     СтруктураВыгрузки.bank);
	УстановитьЗначениеАтрибута(КорневойЭлемент, "bik",      СтруктураВыгрузки.bik);
	УстановитьЗначениеАтрибута(КорневойЭлемент, "rs",       СтруктураВыгрузки.rs);
	УстановитьЗначениеАтрибута(КорневойЭлемент, "ks",       СтруктураВыгрузки.ks);
	УстановитьЗначениеАтрибута(КорневойЭлемент, "address",  СтруктураВыгрузки.address);
	УстановитьЗначениеАтрибута(КорневойЭлемент, "phone",    СтруктураВыгрузки.phone);
	УстановитьЗначениеАтрибута(КорневойЭлемент, "email",    СтруктураВыгрузки.email);
	УстановитьЗначениеАтрибута(КорневойЭлемент, "site",     СтруктураВыгрузки.site);
	УстановитьЗначениеАтрибута(КорневойЭлемент, "additional_info_main",     СтруктураВыгрузки.additional_info_main);
	УстановитьЗначениеАтрибута(КорневойЭлемент, "additional_info_overhaul", СтруктураВыгрузки.additional_info_overhaul);
	УстановитьЗначениеАтрибута(КорневойЭлемент, "annotation_main",          СтруктураВыгрузки.annotation_main);
	УстановитьЗначениеАтрибута(КорневойЭлемент, "annotation_overhaul",      СтруктураВыгрузки.annotation_overhaul);
	
	Возврат КорневойЭлемент;
	
КонецФункции

// Заполняет XML-документ дополнительными сведениями о передаваемых данных.
// Данные сведения нужны только для отладки и на сайте не используются.
//
Процедура ЗаполнитьXMLИнформациюОПередаваемыхДанных(СтруктураВыгрузки, ДокументDOM, КорневойЭлементDOM)
	
	Если СтруктураВыгрузки.Свойство("info") Тогда
		
		ГруппаСтатистическаяИнформация = ДокументDOM.СоздатьЭлемент("info");
		КорневойЭлементDOM.ДобавитьДочерний(ГруппаСтатистическаяИнформация);
		
		УстановитьЗначениеАтрибута(ГруппаСтатистическаяИнформация, "accs_count", СтруктураВыгрузки.info.accs_count);
		УстановитьЗначениеАтрибута(ГруппаСтатистическаяИнформация, "sum",        СтруктураВыгрузки.info.sum);
		УстановитьЗначениеАтрибута(ГруппаСтатистическаяИнформация, "sum_payed",  СтруктураВыгрузки.info.sum_payed);
		УстановитьЗначениеАтрибута(ГруппаСтатистическаяИнформация, "sum_to_pay", СтруктураВыгрузки.info.sum_to_pay);
		
	КонецЕсли;
	
КонецПроцедуры

// Заполняет XML-документ сведениями об ограничении периода ввода показаний.
//
Процедура ЗаполнитьXMLСведенияОбОграниченииВводаПоказаний(СтруктураВыгрузки, ДокументDOM, КорневойЭлементDOM) Экспорт
	
	Если СтруктураВыгрузки.Свойство("meters_date_limitation") Тогда
		
		ГруппаОграничениеВводаПоказаний = ДокументDOM.СоздатьЭлемент("meters_date_limitation");
		КорневойЭлементDOM.ДобавитьДочерний(ГруппаОграничениеВводаПоказаний);
		
		УстановитьЗначениеАтрибута(ГруппаОграничениеВводаПоказаний, "is_limited", СтруктураВыгрузки.meters_date_limitation.is_limited);
		УстановитьЗначениеАтрибута(ГруппаОграничениеВводаПоказаний, "date_begin", СтруктураВыгрузки.meters_date_limitation.date_begin);
		УстановитьЗначениеАтрибута(ГруппаОграничениеВводаПоказаний, "date_end",   СтруктураВыгрузки.meters_date_limitation.date_end);
		УстановитьЗначениеАтрибута(ГруппаОграничениеВводаПоказаний, "reason",     СтруктураВыгрузки.meters_date_limitation.reason);
		
	КонецЕсли;
	
КонецПроцедуры

// Заполняет XML-документ общими сведениями о поставщиках.
//
Процедура ЗаполнитьXMLСведениямиПоПоставщикам(СтруктураВыгрузки, ДокументDOM, КорневойЭлементDOM) Экспорт
	
	// Все поставщики.
	Если СтруктураВыгрузки.Свойство("contractors") И Не СтруктураВыгрузки.contractors.Количество() = 0 Тогда
		
		ГруппаПоставщики = ДокументDOM.СоздатьЭлемент("contractors");
		КорневойЭлементDOM.ДобавитьДочерний(ГруппаПоставщики);
		
		Для Каждого СтрокаПоставщика ИЗ СтруктураВыгрузки.contractors Цикл
			ТекПоставщик = ДокументDOM.СоздатьЭлемент("contractor");
			ГруппаПоставщики.ДобавитьДочерний(ТекПоставщик);
			
			УстановитьЗначениеАтрибута(ТекПоставщик, "id",       СтрокаПоставщика.id);
			УстановитьЗначениеАтрибута(ТекПоставщик, "name",     СтрокаПоставщика.name);
			УстановитьЗначениеАтрибута(ТекПоставщик, "inn",      СтрокаПоставщика.inn);
			УстановитьЗначениеАтрибута(ТекПоставщик, "kpp",      СтрокаПоставщика.kpp);
			УстановитьЗначениеАтрибута(ТекПоставщик, "bank",     СтрокаПоставщика.bank);
			УстановитьЗначениеАтрибута(ТекПоставщик, "bik",      СтрокаПоставщика.bik);
			УстановитьЗначениеАтрибута(ТекПоставщик, "rs",       СтрокаПоставщика.rs);
			УстановитьЗначениеАтрибута(ТекПоставщик, "ks",       СтрокаПоставщика.ks);
			УстановитьЗначениеАтрибута(ТекПоставщик, "executor", СтрокаПоставщика.executor);
			УстановитьЗначениеАтрибута(ТекПоставщик, "address",  СтрокаПоставщика.address);
			УстановитьЗначениеАтрибута(ТекПоставщик, "phone",    СтрЗаменить(СтрокаПоставщика.phone, "тел.: ", ""));
		КонецЦикла;
	КонецЕсли;
	
КонецПроцедуры

// Заполняет XML-документ сведениями о зданиях.
//
Процедура ЗаполнитьXMLСведениямиПоЗданиям(СтруктураВыгрузки, ДокументDOM, КорневойЭлементDOM) Экспорт
	
	// Дома.
	ГруппаЗдания = ДокументDOM.СоздатьЭлемент("houses");
	КорневойЭлементDOM.ДобавитьДочерний(ГруппаЗдания);
	
	Для Каждого СтрокаЗдания ИЗ СтруктураВыгрузки.houses Цикл
		
		ТекЗдание = СформироватьИЗаполнитьЭлементDOMЗдания(СтруктураВыгрузки, СтрокаЗдания, ДокументDOM, ГруппаЗдания);
		
		ЗаполнитьXMLСведениямиОбАдресеЗдания(СтрокаЗдания, ДокументDOM, ТекЗдание);
		ЗаполнитьXMLСведениямиОРасчетномСчетеЗдания(СтрокаЗдания, ДокументDOM, ТекЗдание);
		ЗаполнитьXMLСведениямиОФондеКапРемонта(СтрокаЗдания, ДокументDOM, ТекЗдание);
		ЗаполнитьXMLДополнительнымиСведениямиОЗдании(СтрокаЗдания, ДокументDOM, ТекЗдание);
		ЗаполнитьXMLСведениямиОбЭПД(СтрокаЗдания, ДокументDOM, ТекЗдание);
		ЗаполнитьXMLСведениямиПоСчетчикам(СтрокаЗдания, ДокументDOM, ТекЗдание);
		
	КонецЦикла;
	
КонецПроцедуры

// Формирует тег здания и заполняет его общими данными о здании XML-документ.
//
Функция СформироватьИЗаполнитьЭлементDOMЗдания(СтруктураВыгрузки, СтрокаЗдания, ДокументDOM, ЭлементDOMГруппыЗданий)
	
	ТекЗдание = ДокументDOM.СоздатьЭлемент("house");
	ЭлементDOMГруппыЗданий.ДобавитьДочерний(ТекЗдание);
	
	УстановитьЗначениеАтрибута(ТекЗдание, "id",                    СтрокаЗдания.id);
	УстановитьЗначениеАтрибута(ТекЗдание, "area",                  СтрокаЗдания.area);
	УстановитьЗначениеАтрибута(ТекЗдание, "flats_area",            СтрокаЗдания.flats_area);
	УстановитьЗначениеАтрибута(ТекЗдание, "common_area",           СтрокаЗдания.common_area);
	УстановитьЗначениеАтрибута(ТекЗдание, "type",                  СтрокаЗдания.type);
	УстановитьЗначениеАтрибута(ТекЗдание, "year_of_built",         СтрокаЗдания.year_of_built);
	УстановитьЗначениеАтрибута(ТекЗдание, "date_of_commissioning", СтрокаЗдания.date_of_commissioning);
	УстановитьЗначениеАтрибута(ТекЗдание, "date_of_maintenance",   СтрокаЗдания.date_of_maintenance);
	УстановитьЗначениеАтрибута(ТекЗдание, "floors",                СтрокаЗдания.floors);
	УстановитьЗначениеАтрибута(ТекЗдание, "porches",               СтрокаЗдания.porches);
	
	Возврат ТекЗдание;
	
КонецФункции

// Заполняет XML-документ сведениями об адресе здания.
//
Процедура ЗаполнитьXMLСведениямиОбАдресеЗдания(СтрокаЗдания, ДокументDOM, ЭлементDOMЗдания)
	
	АдресЗдания = ДокументDOM.СоздатьЭлемент("address");
	ЭлементDOMЗдания.ДобавитьДочерний(АдресЗдания);
	
	УстановитьЗначениеАтрибута(АдресЗдания, "index",             СтрокаЗдания.address.index);
	УстановитьЗначениеАтрибута(АдресЗдания, "region",            СтрокаЗдания.address.region);
	УстановитьЗначениеАтрибута(АдресЗдания, "district",          СтрокаЗдания.address.district);
	УстановитьЗначениеАтрибута(АдресЗдания, "city",              СтрокаЗдания.address.city);
	УстановитьЗначениеАтрибута(АдресЗдания, "settlement",        СтрокаЗдания.address.settlement);
	УстановитьЗначениеАтрибута(АдресЗдания, "street",            СтрокаЗдания.address.street);
	УстановитьЗначениеАтрибута(АдресЗдания, "house",             СтрокаЗдания.address.house);
	УстановитьЗначениеАтрибута(АдресЗдания, "address_view",      СтрокаЗдания.address.address_view);
	УстановитьЗначениеАтрибута(АдресЗдания, "address_view_full", СтрокаЗдания.address.address_view_full);
	
КонецПроцедуры

// Заполняет XML-документ сведениями о расчетном счете здания.
//
Процедура ЗаполнитьXMLСведениямиОРасчетномСчетеЗдания(СтрокаЗдания, ДокументDOM, ЭлементDOMЗдания)
	
	Если НЕ СтрокаЗдания.fund = Неопределено Тогда
		СчетОрганизацииДляЗдания = ДокументDOM.СоздатьЭлемент("fund");
		ЭлементDOMЗдания.ДобавитьДочерний(СчетОрганизацииДляЗдания);
		
		ДанныеСчетаОрганизации = СтрокаЗдания.fund;
		
		УстановитьЗначениеАтрибута(СчетОрганизацииДляЗдания, "bank", ДанныеСчетаОрганизации.bank);
		УстановитьЗначениеАтрибута(СчетОрганизацииДляЗдания, "bik",  ДанныеСчетаОрганизации.bik);
		УстановитьЗначениеАтрибута(СчетОрганизацииДляЗдания, "ks",   ДанныеСчетаОрганизации.ks);
		УстановитьЗначениеАтрибута(СчетОрганизацииДляЗдания, "rs",   ДанныеСчетаОрганизации.rs);
	КонецЕсли;
	
КонецПроцедуры

// Заполняет XML-документ сведениями о расчетном счете фонда капитального ремонта.
//
Процедура ЗаполнитьXMLСведениямиОФондеКапРемонта(СтрокаЗдания, ДокументDOM, ЭлементDOMЗдания)
	
	Если НЕ СтрокаЗдания.overhaul_fund = Неопределено Тогда
		ФондКапРемонта = ДокументDOM.СоздатьЭлемент("overhaul_fund");
		ЭлементDOMЗдания.ДобавитьДочерний(ФондКапРемонта);
		
		ДанныеФондаКапРемонта = СтрокаЗдания.overhaul_fund;
		
		УстановитьЗначениеАтрибута(ФондКапРемонта, "name",  ДанныеФондаКапРемонта.name);
		УстановитьЗначениеАтрибута(ФондКапРемонта, "inn",   ДанныеФондаКапРемонта.inn);
		УстановитьЗначениеАтрибута(ФондКапРемонта, "bank",  ДанныеФондаКапРемонта.bank);
		УстановитьЗначениеАтрибута(ФондКапРемонта, "bik",   ДанныеФондаКапРемонта.bik);
		УстановитьЗначениеАтрибута(ФондКапРемонта, "ks",    ДанныеФондаКапРемонта.ks);
		УстановитьЗначениеАтрибута(ФондКапРемонта, "rs",    ДанныеФондаКапРемонта.rs);
		УстановитьЗначениеАтрибута(ФондКапРемонта, "phone", ДанныеФондаКапРемонта.phone);
		УстановитьЗначениеАтрибута(ФондКапРемонта, "email", ДанныеФондаКапРемонта.email);
	КонецЕсли;
	
КонецПроцедуры

// Заполняет XML-документ дополнительными сведениями по зданию.
//
Процедура ЗаполнитьXMLДополнительнымиСведениямиОЗдании(СтрокаЗдания, ДокументDOM, ЭлементDOMЗдания)
	
	Если НЕ СтрокаЗдания.add_info = Неопределено Тогда
		ТегДополнительнаяИнформация = ДокументDOM.СоздатьЭлемент("add_info");
		ЭлементDOMЗдания.ДобавитьДочерний(ТегДополнительнаяИнформация);
		
		УстановитьЗначениеАтрибута(ТегДополнительнаяИнформация, "wear",             СтрокаЗдания.add_info.wear);
		УстановитьЗначениеАтрибута(ТегДополнительнаяИнформация, "series",           СтрокаЗдания.add_info.series);
		УстановитьЗначениеАтрибута(ТегДополнительнаяИнформация, "living_rooms",     СтрокаЗдания.add_info.living_rooms);
		УстановитьЗначениеАтрибута(ТегДополнительнаяИнформация, "nonliving_rooms",  СтрокаЗдания.add_info.nonliving_rooms);
		УстановитьЗначениеАтрибута(ТегДополнительнаяИнформация, "people",           СтрокаЗдания.add_info.people);
		УстановитьЗначениеАтрибута(ТегДополнительнаяИнформация, "accounts",         СтрокаЗдания.add_info.accounts);
		УстановитьЗначениеАтрибута(ТегДополнительнаяИнформация, "people_accounts",  СтрокаЗдания.add_info.people_accounts);
		УстановитьЗначениеАтрибута(ТегДополнительнаяИнформация, "company_accounts", СтрокаЗдания.add_info.company_accounts);
	КонецЕсли;
	
КонецПроцедуры

// Заполняет XML-документ сведениями об электронных паспортах домов.
//
Процедура ЗаполнитьXMLСведениямиОбЭПД(СтрокаЗдания, ДокументDOM, ЭлементDOMЗдания)
	
	Если НЕ СтрокаЗдания.contents.Количество() = 0 Тогда
		
		ТекЭлектронныеПаспортаHTMLОбщийТег = ДокументDOM.СоздатьЭлемент("contents");
		ЭлементDOMЗдания.ДобавитьДочерний(ТекЭлектронныеПаспортаHTMLОбщийТег);
		
		Для каждого ТекТегHTML из СтрокаЗдания.contents Цикл
			ТекЭлементЭлектронногоПаспортаHTML = ДокументDOM.СоздатьЭлемент("content");
			ТекЭлектронныеПаспортаHTMLОбщийТег.ДобавитьДочерний(ТекЭлементЭлектронногоПаспортаHTML);
			
			УстановитьЗначениеАтрибута(ТекЭлементЭлектронногоПаспортаHTML, "name", ТекТегHTML.name);
			УстановитьЗначениеАтрибута(ТекЭлементЭлектронногоПаспортаHTML, "type", ТекТегHTML.type);
			
			ТекЭлементЭлектронногоПаспортаHTML.ТекстовоеСодержимое = ТекТегHTML.text;
		КонецЦикла;
		
	КонецЕсли;
	
КонецПроцедуры

// Заполняет XML-документ сведениями по л/с.
//
Процедура ЗаполнитьXMLСведениямиПоЛС(СтруктураВыгрузки, ДокументDOM, КорневойЭлементDOM) Экспорт
	
	ГруппаЛицевыеСчета = ДокументDOM.СоздатьЭлемент("accs");
	КорневойЭлементDOM.ДобавитьДочерний(ГруппаЛицевыеСчета);
	
	Для Каждого СтрокаЛС ИЗ СтруктураВыгрузки.accs Цикл
		
		ТекЛицевойСчет = СформироватьИЗаполнитьЭлементDOMЛицевогоСчета(СтруктураВыгрузки, СтрокаЛС, ДокументDOM, ГруппаЛицевыеСчета);
		
		Если Не СтрокаЛС.meter = Неопределено Тогда
			ЗаполнитьXMLСведениямиПоСчетчикам(СтрокаЛС, ДокументDOM, ТекЛицевойСчет);
		КонецЕсли;
		
		Если СтруктураВыгрузки.ВыгружатьНачисления Тогда
			
			// ОСНОВНАЯ КВИТАНЦИЯ.
			Если Не СтрокаЛС.main = Неопределено Тогда
				ЗаполнитьXMLСведениямиОКвитанции(СтрокаЛС, ДокументDOM, ТекЛицевойСчет);
			КонецЕсли;
			
			// ОСНОВНАЯ КВИТАНЦИЯ ПО КАП. РЕМОНТУ.
			Если Не СтрокаЛС.overhaul = Неопределено Тогда
				ЗаполнитьXMLСведениямиОКвитанции(СтрокаЛС, ДокументDOM, ТекЛицевойСчет, Истина);
			КонецЕсли;
			
			// ПЕНИ ПО ОСНОВНЫМ УСЛУГАМ.
			Если Не СтрокаЛС.finesMain = Неопределено Тогда
				ЗаполнитьXMLСведениямиОПенях(СтрокаЛС, ДокументDOM, ТекЛицевойСчет);
			КонецЕсли;
			
			// ПЕНИ ПО УСЛУГАМ КАП. РЕМОНТА.
			Если Не СтрокаЛС.finesOverhaul = Неопределено Тогда
				ЗаполнитьXMLСведениямиОПенях(СтрокаЛС, ДокументDOM, ТекЛицевойСчет, Истина);
			КонецЕсли;
			
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Формирует тег л/с и заполняет общими данными по л/с XML-документ.
//
Функция СформироватьИЗаполнитьЭлементDOMЛицевогоСчета(СтруктураВыгрузки, СтрокаЛС, ДокументDOM, ЭлементDOMГруппыЛицевыхСчетов)
	
	ТекЛицевойСчет = ДокументDOM.СоздатьЭлемент("acc");
	ЭлементDOMГруппыЛицевыхСчетов.ДобавитьДочерний(ТекЛицевойСчет);
	
	УстановитьЗначениеАтрибута(ТекЛицевойСчет, "id", СтрокаЛС.id);
	Если СтрокаЛС.del = "1" Тогда
		УстановитьЗначениеАтрибута(ТекЛицевойСчет, "del", СтрокаЛС.del);
	Иначе
		УстановитьЗначениеАтрибута(ТекЛицевойСчет, "kod_ls", СтрокаЛС.kod_ls);
		УстановитьЗначениеАтрибута(ТекЛицевойСчет, "type",   СтрокаЛС.type);
		УстановитьЗначениеАтрибута(ТекЛицевойСчет, "email",  СтрокаЛС.email);
		Если СтруктураВыгрузки.ВыгружатьПерсональныеДанные Тогда
			УстановитьЗначениеАтрибута(ТекЛицевойСчет, "owner", СтрокаЛС.owner);
		КонецЕсли;
		УстановитьЗначениеАтрибута(ТекЛицевойСчет, "name",           СтрокаЛС.name);
		УстановитьЗначениеАтрибута(ТекЛицевойСчет, "house_id",       СтрокаЛС.house_id);
		УстановитьЗначениеАтрибута(ТекЛицевойСчет, "els_main",       СтрокаЛС.els_main);
		УстановитьЗначениеАтрибута(ТекЛицевойСчет, "els_overhaul",   СтрокаЛС.els_overhaul);
		УстановитьЗначениеАтрибута(ТекЛицевойСчет, "izhku_main",     СтрокаЛС.izhku_main);
		УстановитьЗначениеАтрибута(ТекЛицевойСчет, "izhku_overhaul", СтрокаЛС.izhku_overhaul);
		
		ПомещениеЛицевогоСчета = ДокументDOM.СоздатьЭлемент("room");
		ТекЛицевойСчет.ДобавитьДочерний(ПомещениеЛицевогоСчета);
		
		УстановитьЗначениеАтрибута(ПомещениеЛицевогоСчета, "num", СтрокаЛС.room.num);
		
		Если СтрокаЛС.room.Свойство("abbr") Тогда
			УстановитьЗначениеАтрибута(ПомещениеЛицевогоСчета, "abbr", СтрокаЛС.room.abbr);
		КонецЕсли;
		
		УстановитьЗначениеАтрибута(ПомещениеЛицевогоСчета, "type",          СтрокаЛС.room.type);
		УстановитьЗначениеАтрибута(ПомещениеЛицевогоСчета, "property_type", СтрокаЛС.room.property_type);
		УстановитьЗначениеАтрибута(ПомещениеЛицевогоСчета, "area",          СтрокаЛС.room.area);
		УстановитьЗначениеАтрибута(ПомещениеЛицевогоСчета, "habarea",       СтрокаЛС.room.habarea);
		УстановитьЗначениеАтрибута(ПомещениеЛицевогоСчета, "people",        СтрокаЛС.room.people);
		УстановитьЗначениеАтрибута(ПомещениеЛицевогоСчета, "reg",           СтрокаЛС.room.reg);
		УстановитьЗначениеАтрибута(ПомещениеЛицевогоСчета, "comp",          СтрокаЛС.room.comp);
	КонецЕсли;
	
	Возврат ТекЛицевойСчет;
	
КонецФункции

// Заполняет XML-документ сведениями о квитанции.
//
Процедура ЗаполнитьXMLСведениямиОКвитанции(СтрокаЛС, ДокументDOM, ЭлементDOMЛицевогоСчета, КвитанцияКР = Ложь)
	
	Если КвитанцияКР Тогда
		
		НаименованиеТегаКвитанции = "overhaul";
		СтруктураОбщихДанных      = СтрокаЛС.overhaul_com;
		МассивШтрихКодов          = СтрокаЛС.overhaul_barcode;
		ТаблицаНачислений         = СтрокаЛС.overhaul;
		ТаблицаУслугБезНачислений = СтрокаЛС.overhaul_debt;
		ТаблицаРассрочек          = СтрокаЛС.overhaul_credit;
		ТаблицаПерерасчетов       = СтрокаЛС.overhaul_correction;
		ТаблицаПоставщиков        = СтрокаЛС.overhaul_contractor;
		
	Иначе
		
		НаименованиеТегаКвитанции        = "main";
		СтруктураОбщихДанных             = СтрокаЛС.main_com;
		МассивШтрихКодов                 = СтрокаЛС.main_barcode;
		СтруктураШтрихКодаСоСтрахованием = СтрокаЛС.main_barcode_with_insurance;
		ТаблицаНачислений                = СтрокаЛС.main;
		ТаблицаСтрахования               = СтрокаЛС.main_insurance;
		ТаблицаУслугБезНачислений        = СтрокаЛС.main_debt;
		ТаблицаРассрочек                 = СтрокаЛС.main_credit;
		ТаблицаПерерасчетов              = СтрокаЛС.main_correction;
		ТаблицаПоставщиков               = СтрокаЛС.main_contractor;
		
	КонецЕсли;
	
	// ОСНОВНАЯ КВИТАНЦИЯ.
	ОсновнаяКвитанция = ДокументDOM.СоздатьЭлемент(НаименованиеТегаКвитанции);
	ЭлементDOMЛицевогоСчета.ДобавитьДочерний(ОсновнаяКвитанция);
	
	// Итоговые данные.
	УстановитьЗначениеАтрибута(ОсновнаяКвитанция, "ipd",               СтруктураОбщихДанных.ipd);
	УстановитьЗначениеАтрибута(ОсновнаяКвитанция, "debt_beg",          СтруктураОбщихДанных.debt_beg);
	УстановитьЗначениеАтрибута(ОсновнаяКвитанция, "debt_end",          СтруктураОбщихДанных.debt_end);
	УстановитьЗначениеАтрибута(ОсновнаяКвитанция, "debt_prev",         СтруктураОбщихДанных.debt_prev);
	УстановитьЗначениеАтрибута(ОсновнаяКвитанция, "prepayment",        СтруктураОбщихДанных.prepayment);
	УстановитьЗначениеАтрибута(ОсновнаяКвитанция, "sum_payed",         СтруктураОбщихДанных.sum_payed);
	УстановитьЗначениеАтрибута(ОсновнаяКвитанция, "credit_payed",      СтруктураОбщихДанных.credit_payed);
	УстановитьЗначениеАтрибута(ОсновнаяКвитанция, "peni",              СтруктураОбщихДанных.peni);
	УстановитьЗначениеАтрибута(ОсновнаяКвитанция, "last_payment_date", СтруктураОбщихДанных.last_payment_date);
	УстановитьЗначениеАтрибута(ОсновнаяКвитанция, "sum_to_pay",        СтруктураОбщихДанных.sum_to_pay);
	
	Если СтруктураОбщихДанных.Свойство("sum_to_pay_with_insurance") Тогда
		УстановитьЗначениеАтрибута(ОсновнаяКвитанция, "sum_to_pay_with_insurance", СтруктураОбщихДанных.sum_to_pay_with_insurance);
	КонецЕсли;
	
	Если СтруктураОбщихДанных.Свойство("sum_payed_insurance") Тогда
		УстановитьЗначениеАтрибута(ОсновнаяКвитанция, "sum_payed_insurance", СтруктураОбщихДанных.sum_payed_insurance);
	КонецЕсли;
	
	// ШК без добровольного страхования.
	ДобавитьЭлементыОсновныхШтрихкодов(ДокументDOM, ОсновнаяКвитанция, МассивШтрихКодов);
	
	Если НЕ КвитанцияКР Тогда
		ДобавитьЭлементШтрихкода(ДокументDOM, ОсновнаяКвитанция, СтруктураШтрихКодаСоСтрахованием);
	КонецЕсли;
	
	// Таблица начисления.
	Для Каждого СтрокаНачисления ИЗ ТаблицаНачислений Цикл
		
		ТекУслуга = ДокументDOM.СоздатьЭлемент("service");
		ОсновнаяКвитанция.ДобавитьДочерний(ТекУслуга);
		
		ЗаполнитьСведенияПоСтрокеНачисления(ТекУслуга, СтрокаНачисления);
	КонецЦикла;
	
	// Добровольное страхование.
	Если НЕ КвитанцияКР Тогда
		Для Каждого СтрокаНачисления ИЗ ТаблицаСтрахования Цикл
			
			ТекУслуга = ДокументDOM.СоздатьЭлемент("service_insurance");
			ОсновнаяКвитанция.ДобавитьДочерний(ТекУслуга);
			
			ЗаполнитьСведенияПоСтрокеДобровольногоСтрахования(ТекУслуга, СтрокаНачисления);
		КонецЦикла;
	КонецЕсли;
	
	// Услуги без начислений.
	Для Каждого СтрокаНачисления ИЗ ТаблицаУслугБезНачислений Цикл
		
		ТекУслуга = ДокументDOM.СоздатьЭлемент("service_debt");
		ОсновнаяКвитанция.ДобавитьДочерний(ТекУслуга);
		
		ЗаполнитьСведенияПоСтрокеУслугБезНачислений(ТекУслуга, СтрокаНачисления);
	КонецЦикла;
	
	// Таблица рассрочки.
	Для Каждого СтрокаРассрочки ИЗ ТаблицаРассрочек Цикл
		ТекРассрочка = ДокументDOM.СоздатьЭлемент("credit");
		ОсновнаяКвитанция.ДобавитьДочерний(ТекРассрочка);
		
		УстановитьЗначениеАтрибута(ТекРассрочка, "name",       СтрокаРассрочки.name);
		УстановитьЗначениеАтрибута(ТекРассрочка, "sum",        СтрокаРассрочки.sum);
		УстановитьЗначениеАтрибута(ТекРассрочка, "sum_credit", СтрокаРассрочки.sum_credit);
		УстановитьЗначениеАтрибута(ТекРассрочка, "rate",       СтрокаРассрочки.rate);
		УстановитьЗначениеАтрибута(ТекРассрочка, "balance",    СтрокаРассрочки.balance);
		УстановитьЗначениеАтрибута(ТекРассрочка, "sum_to_pay", СтрокаРассрочки.sum_to_pay);
		УстановитьЗначениеАтрибута(ТекРассрочка, "contractor", СтрокаРассрочки.contractor);
	КонецЦикла;
	
	// Таблица перерасчетов.
	Для Каждого СтрокаПерерасчета ИЗ ТаблицаПерерасчетов Цикл
		ТекПерерасчет = ДокументDOM.СоздатьЭлемент("correction");
		ОсновнаяКвитанция.ДобавитьДочерний(ТекПерерасчет);
		
		УстановитьЗначениеАтрибута(ТекПерерасчет, "name",       СтрокаПерерасчета.name);
		УстановитьЗначениеАтрибута(ТекПерерасчет, "grounds",    СтрокаПерерасчета.grounds);
		УстановитьЗначениеАтрибута(ТекПерерасчет, "sum",        СтрокаПерерасчета.sum);
		УстановитьЗначениеАтрибута(ТекПерерасчет, "contractor", СтрокаПерерасчета.contractor);
	КонецЦикла;
	
	// Таблица поставщиков.
	Для Каждого СтрокаПоставщика ИЗ ТаблицаПоставщиков Цикл
		ТекПоставщик = ДокументDOM.СоздатьЭлемент("contractor");
		ОсновнаяКвитанция.ДобавитьДочерний(ТекПоставщик);
		
		УстановитьЗначениеАтрибута(ТекПоставщик, "id",          СтрокаПоставщика.id);
		УстановитьЗначениеАтрибута(ТекПоставщик, "services",    СтрокаПоставщика.services);
		УстановитьЗначениеАтрибута(ТекПоставщик, "debt_beg",    СтрокаПоставщика.debt_beg);
		УстановитьЗначениеАтрибута(ТекПоставщик, "sum",         СтрокаПоставщика.sum);
		УстановитьЗначениеАтрибута(ТекПоставщик, "peni",        СтрокаПоставщика.peni);
		УстановитьЗначениеАтрибута(ТекПоставщик, "sum_payed",   СтрокаПоставщика.sum_payed);
		УстановитьЗначениеАтрибута(ТекПоставщик, "summ",        СтрокаПоставщика.summ);
		УстановитьЗначениеАтрибута(ТекПоставщик, "sum_to_pay",  СтрокаПоставщика.sum_to_pay);
		УстановитьЗначениеАтрибута(ТекПоставщик, "num",         СтрокаПоставщика.num);
		УстановитьЗначениеАтрибута(ТекПоставщик, "is_overhaul", СтрокаПоставщика.is_overhaul);
		
		// ШК поставщика.
		ДобавитьЭлементШтрихкода(ДокументDOM, ТекПоставщик, СтрокаПоставщика.barcode);
		
	КонецЦикла;
	
КонецПроцедуры

// Заполняет XML-документ сведениями о квитанции по пеням.
//
Процедура ЗаполнитьXMLСведениямиОПенях(СтрокаЛС, ДокументDOM, ЭлементDOMЛицевогоСчета, КвитанцияКР = Ложь)
	
	Если КвитанцияКР Тогда
		
		НаименованиеТегаКвитанции = "fines_overhaul";
		СтруктураОбщихДанных      = СтрокаЛС.finesOverhaul_com;
		МассивШтрихКодов          = СтрокаЛС.finesOverhaul_barcode;
		ТаблицаНачислений         = СтрокаЛС.finesOverhaul;
		ТаблицаУслугБезНачислений = СтрокаЛС.finesOverhaul_debt;
		ТаблицаПерерасчетов       = СтрокаЛС.finesOverhaul_correction;
		ТаблицаПоставщиков        = СтрокаЛС.finesOverhaul_contractor;
		
	Иначе
		
		НаименованиеТегаКвитанции = "fines_main";
		СтруктураОбщихДанных      = СтрокаЛС.finesMain_com;
		МассивШтрихКодов          = СтрокаЛС.finesMain_barcode;
		ТаблицаНачислений         = СтрокаЛС.finesMain;
		ТаблицаУслугБезНачислений = СтрокаЛС.finesMain_debt;
		ТаблицаПерерасчетов       = СтрокаЛС.finesMain_correction;
		ТаблицаПоставщиков        = СтрокаЛС.finesMain_contractor;
		
	КонецЕсли;
	
	КвитанцияПениОсновные = ДокументDOM.СоздатьЭлемент(НаименованиеТегаКвитанции);
	ЭлементDOMЛицевогоСчета.ДобавитьДочерний(КвитанцияПениОсновные);
	
	УстановитьЗначениеАтрибута(КвитанцияПениОсновные, "ipd",               СтруктураОбщихДанных.ipd);
	УстановитьЗначениеАтрибута(КвитанцияПениОсновные, "debt_beg",          СтруктураОбщихДанных.debt_beg);
	УстановитьЗначениеАтрибута(КвитанцияПениОсновные, "debt_end",          СтруктураОбщихДанных.debt_end);
	УстановитьЗначениеАтрибута(КвитанцияПениОсновные, "debt_prev",         СтруктураОбщихДанных.debt_prev);
	УстановитьЗначениеАтрибута(КвитанцияПениОсновные, "prepayment",        СтруктураОбщихДанных.prepayment);
	УстановитьЗначениеАтрибута(КвитанцияПениОсновные, "sum_payed",         СтруктураОбщихДанных.sum_payed);
	УстановитьЗначениеАтрибута(КвитанцияПениОсновные, "last_payment_date", СтруктураОбщихДанных.last_payment_date);
	УстановитьЗначениеАтрибута(КвитанцияПениОсновные, "sum_to_pay",        СтруктураОбщихДанных.sum_to_pay);
	
	ДобавитьЭлементыОсновныхШтрихкодов(ДокументDOM, КвитанцияПениОсновные, МассивШтрихКодов);
	
	Для Каждого СтрокаНачисления ИЗ ТаблицаНачислений Цикл
		
		ТекУслуга = ДокументDOM.СоздатьЭлемент("service");
		КвитанцияПениОсновные.ДобавитьДочерний(ТекУслуга);
		
		ЗаполнитьСведенияПоСтрокеНачисления(ТекУслуга, СтрокаНачисления, Истина);
	КонецЦикла;
	
	// Услуги без начислений.
	Для Каждого СтрокаНачисления ИЗ ТаблицаУслугБезНачислений Цикл
		
		ТекУслуга = ДокументDOM.СоздатьЭлемент("service_debt");
		КвитанцияПениОсновные.ДобавитьДочерний(ТекУслуга);
		
		ЗаполнитьСведенияПоСтрокеУслугБезНачислений(ТекУслуга, СтрокаНачисления, Истина);
	КонецЦикла;
	
	Для Каждого СтрокаПерерасчета ИЗ ТаблицаПерерасчетов Цикл
		ТекПерерасчет = ДокументDOM.СоздатьЭлемент("correction");
		КвитанцияПениОсновные.ДобавитьДочерний(ТекПерерасчет);
		
		УстановитьЗначениеАтрибута(ТекПерерасчет, "name",       СтрокаПерерасчета.name);
		УстановитьЗначениеАтрибута(ТекПерерасчет, "grounds",    СтрокаПерерасчета.grounds);
		УстановитьЗначениеАтрибута(ТекПерерасчет, "sum",        СтрокаПерерасчета.sum);
		УстановитьЗначениеАтрибута(ТекПерерасчет, "contractor", СтрокаПерерасчета.contractor);
	КонецЦикла;
	
	Для Каждого СтрокаПоставщика ИЗ ТаблицаПоставщиков Цикл
		ТекПоставщик = ДокументDOM.СоздатьЭлемент("contractor");
		КвитанцияПениОсновные.ДобавитьДочерний(ТекПоставщик);
		
		УстановитьЗначениеАтрибута(ТекПоставщик, "id",          СтрокаПоставщика.id);
		УстановитьЗначениеАтрибута(ТекПоставщик, "services",    СтрокаПоставщика.services);
		УстановитьЗначениеАтрибута(ТекПоставщик, "debt_beg",    СтрокаПоставщика.debt_beg);
		УстановитьЗначениеАтрибута(ТекПоставщик, "sum",         СтрокаПоставщика.sum);
		УстановитьЗначениеАтрибута(ТекПоставщик, "peni",        СтрокаПоставщика.peni);
		УстановитьЗначениеАтрибута(ТекПоставщик, "sum_payed",   СтрокаПоставщика.sum_payed);
		УстановитьЗначениеАтрибута(ТекПоставщик, "summ",        СтрокаПоставщика.summ);
		УстановитьЗначениеАтрибута(ТекПоставщик, "sum_to_pay",  СтрокаПоставщика.sum_to_pay);
		УстановитьЗначениеАтрибута(ТекПоставщик, "is_overhaul", СтрокаПоставщика.is_overhaul);
		
		// ШК поставщика.
		ДобавитьЭлементШтрихкода(ДокументDOM, ТекПоставщик, СтрокаПоставщика.barcode);
		
	КонецЦикла;
	
КонецПроцедуры

// Заполняет XML-документ сведениями по лицевым счетам за дополнительный период.
//
Процедура ЗаполнитьXMLСведенияПоЛСЗаДополнительныйПериод(СтруктураВыгрузки, ДокументDOM, КорневойЭлемент) Экспорт
	
	Если СтруктураВыгрузки.Свойство("additional_period") Тогда
		
		ЭлементДопПериод = ДокументDOM.СоздатьЭлемент("additional_period");
		КорневойЭлемент.ДобавитьДочерний(ЭлементДопПериод);
		
		УстановитьЗначениеАтрибута(ЭлементДопПериод, "period_date", СтруктураВыгрузки.additional_period.period_date);
		
		ГруппаЛС = ДокументDOM.СоздатьЭлемент("accs");
		ЭлементДопПериод.ДобавитьДочерний(ГруппаЛС);
		
		Для каждого ТекЛС из СтруктураВыгрузки.additional_period.accs Цикл
			
			ЭлементЛС = ДокументDOM.СоздатьЭлемент("acc");
			ГруппаЛС.ДобавитьДочерний(ЭлементЛС);
			
			УстановитьЗначениеАтрибута(ЭлементЛС, "id", ТекЛС.id);
			
			Если НЕ ТекЛС.meter = Неопределено Тогда
				ЗаполнитьXMLСведениямиПоСчетчикам(ТекЛС, ДокументDOM, ЭлементЛС);
			КонецЕсли;
			
			УстановитьСведенияПоКвитанциямДопПериодов("main",          ТекЛС, ДокументDOM, ЭлементЛС);
			УстановитьСведенияПоКвитанциямДопПериодов("overhaul",      ТекЛС, ДокументDOM, ЭлементЛС);
			УстановитьСведенияПоКвитанциямДопПериодов("finesMain",     ТекЛС, ДокументDOM, ЭлементЛС);
			УстановитьСведенияПоКвитанциямДопПериодов("finesOverhaul", ТекЛС, ДокументDOM, ЭлементЛС);
			
		КонецЦикла;
		
	КонецЕсли;
	
КонецПроцедуры

// Заполняет XML-документ сведениями по квитанциям лицевых счетов за дополнительный период.
//
Процедура УстановитьСведенияПоКвитанциямДопПериодов(ТипКвитанции, ДанныеЛС, ДокументDOM, ЭлементDOMОбъекта)
	
	Если НЕ ДанныеЛС[ТипКвитанции] = Неопределено Тогда
		ЭлементКвитанция = ДокументDOM.СоздатьЭлемент(ТипКвитанции);
		ЭлементDOMОбъекта.ДобавитьДочерний(ЭлементКвитанция);
		УстановитьЗначениеАтрибута(ЭлементКвитанция, "sum_payed", ДанныеЛС[ТипКвитанции].sum_payed);
	КонецЕсли;
	
КонецПроцедуры

// Заполняет XML-документ сведениями по счетчикам.
//
Процедура ЗаполнитьXMLСведениямиПоСчетчикам(СтрокаОбъекта, ДокументDOM, ЭлементDOMОбъекта)
	
	Для Каждого СтрокаСчетчика ИЗ СтрокаОбъекта.meter Цикл
		
		ТекСчетчик = ДокументDOM.СоздатьЭлемент("meter");
		ЭлементDOMОбъекта.ДобавитьДочерний(ТекСчетчик);
		
		УстановитьЗначениеАтрибута(ТекСчетчик, "id", СтрокаСчетчика.id);
		
		Если СтрокаСчетчика.del = "1" Тогда
			УстановитьЗначениеАтрибута(ТекСчетчик, "del", СтрокаСчетчика.del);
		Иначе
			УстановитьЗначениеАтрибута(ТекСчетчик, "name",              СтрокаСчетчика.name);
			УстановитьЗначениеАтрибута(ТекСчетчик, "service_name",      СтрокаСчетчика.service_name);
			УстановитьЗначениеАтрибута(ТекСчетчик, "num",               СтрокаСчетчика.num);
			УстановитьЗначениеАтрибута(ТекСчетчик, "use_consumption",   СтрокаСчетчика.use_consumption);
			УстановитьЗначениеАтрибута(ТекСчетчик, "values",            СтрокаСчетчика.values);
			УстановитьЗначениеАтрибута(ТекСчетчик, "capacity",          СтрокаСчетчика.capacity);
			УстановитьЗначениеАтрибута(ТекСчетчик, "verification_date", СтрокаСчетчика.verification_date);
			
			Если НЕ СтрокаСчетчика.date = "" Тогда
				
				УстановитьЗначениеАтрибута(ТекСчетчик, "date",    СтрокаСчетчика.date);
				УстановитьЗначениеАтрибута(ТекСчетчик, "val1",    СтрокаСчетчика.val1);
				УстановитьЗначениеАтрибута(ТекСчетчик, "charge1", СтрокаСчетчика.charge1);
				
				Если СтрокаСчетчика.values = "2" Тогда
					УстановитьЗначениеАтрибута(ТекСчетчик, "val2",    СтрокаСчетчика.val2);
					УстановитьЗначениеАтрибута(ТекСчетчик, "charge2", СтрокаСчетчика.charge2);
				ИначеЕсли СтрокаСчетчика.values = "3" Тогда
					УстановитьЗначениеАтрибута(ТекСчетчик, "val2",    СтрокаСчетчика.val2);
					УстановитьЗначениеАтрибута(ТекСчетчик, "charge2", СтрокаСчетчика.charge2);
					УстановитьЗначениеАтрибута(ТекСчетчик, "val3",    СтрокаСчетчика.val3);
					УстановитьЗначениеАтрибута(ТекСчетчик, "charge3", СтрокаСчетчика.charge3);
				КонецЕсли;
				
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Заполняет теги "service" данными о начислениях.
//
Процедура ЗаполнитьСведенияПоСтрокеНачисления(ТекУслуга, СтрокаНачисления, КвитанцияНаПени = Ложь)
	
	УстановитьЗначениеАтрибута(ТекУслуга, "group", СтрокаНачисления.group);
	
	Если СтрокаНачисления.name = "" Тогда
		ТекУслуга.УстановитьАтрибут("name", "");
	Иначе
		УстановитьЗначениеАтрибута(ТекУслуга, "name",  СтрокаНачисления.name);
	КонецЕсли;
	
	УстановитьЗначениеАтрибута(ТекУслуга, "units", СтрокаНачисления.units);
	
	// Данные дублируем для логичного порядка атрибутов.
	Если КвитанцияНаПени Тогда
		
		УстановитьЗначениеАтрибута(ТекУслуга, "debt_beg",    СтрокаНачисления.debt_beg);
		УстановитьЗначениеАтрибута(ТекУслуга, "debt_end",    СтрокаНачисления.debt_end);
		УстановитьЗначениеАтрибута(ТекУслуга, "csum",        СтрокаНачисления.csum);
		УстановитьЗначениеАтрибута(ТекУслуга, "correction",  СтрокаНачисления.correction);
		УстановитьЗначениеАтрибута(ТекУслуга, "sum_payed",   СтрокаНачисления.sum_payed);
		УстановитьЗначениеАтрибута(ТекУслуга, "csum_to_pay", СтрокаНачисления.csum_to_pay);
		УстановитьЗначениеАтрибута(ТекУслуга, "contractor",  СтрокаНачисления.contractor);
		
	Иначе
		
		УстановитьЗначениеАтрибута(ТекУслуга, "component",    СтрокаНачисления.component);
		УстановитьЗначениеАтрибута(ТекУслуга, "debt_beg",     СтрокаНачисления.debt_beg);
		УстановитьЗначениеАтрибута(ТекУслуга, "debt_end",     СтрокаНачисления.debt_end);
		УстановитьЗначениеАтрибута(ТекУслуга, "amount",       СтрокаНачисления.amount);
		УстановитьЗначениеАтрибута(ТекУслуга, "hamount",      СтрокаНачисления.hamount);
		УстановитьЗначениеАтрибута(ТекУслуга, "amountn",      СтрокаНачисления.amountn);
		УстановитьЗначениеАтрибута(ТекУслуга, "hamountn",     СтрокаНачисления.hamountn);
		УстановитьЗначениеАтрибута(ТекУслуга, "sum",          СтрокаНачисления.sum);
		УстановитьЗначениеАтрибута(ТекУслуга, "hsum",         СтрокаНачисления.hsum);
		УстановитьЗначениеАтрибута(ТекУслуга, "csum",         СтрокаНачисления.csum);
		УстановитьЗначениеАтрибута(ТекУслуга, "norm",         СтрокаНачисления.norm);
		УстановитьЗначениеАтрибута(ТекУслуга, "hnorm",        СтрокаНачисления.hnorm);
		УстановитьЗначениеАтрибута(ТекУслуга, "peni",         СтрокаНачисления.peni);
		УстановитьЗначениеАтрибута(ТекУслуга, "correction",   СтрокаНачисления.correction);
		УстановитьЗначениеАтрибута(ТекУслуга, "compensation", СтрокаНачисления.compensation);
		УстановитьЗначениеАтрибута(ТекУслуга, "sum_payed",    СтрокаНачисления.sum_payed);
		УстановитьЗначениеАтрибута(ТекУслуга, "sum_to_pay",   СтрокаНачисления.sum_to_pay);
		УстановитьЗначениеАтрибута(ТекУслуга, "hsum_to_pay",  СтрокаНачисления.hsum_to_pay);
		УстановитьЗначениеАтрибута(ТекУслуга, "csum_to_pay",  СтрокаНачисления.csum_to_pay);
		УстановитьЗначениеАтрибута(ТекУслуга, "tarif",        СтрокаНачисления.tarif);
		УстановитьЗначениеАтрибута(ТекУслуга, "volumep",      СтрокаНачисления.volumep);
		УстановитьЗначениеАтрибута(ТекУслуга, "volumea",      СтрокаНачисления.volumea);
		УстановитьЗначениеАтрибута(ТекУслуга, "volumeh",      СтрокаНачисления.volumeh);
		УстановитьЗначениеАтрибута(ТекУслуга, "amount_norm",  СтрокаНачисления.amount_norm);
		УстановитьЗначениеАтрибута(ТекУслуга, "amount_view",  СтрокаНачисления.amount_view);
		УстановитьЗначениеАтрибута(ТекУслуга, "bill_only",    СтрокаНачисления.bill_only);
		УстановитьЗначениеАтрибута(ТекУслуга, "raise_multiplier",   СтрокаНачисления.raise_multiplier);
		УстановитьЗначениеАтрибута(ТекУслуга, "raise_sum",          СтрокаНачисления.raise_sum);
		УстановитьЗначениеАтрибута(ТекУслуга, "sum_without_raise",  СтрокаНачисления.sum_without_raise);
		УстановитьЗначениеАтрибута(ТекУслуга, "csum_without_raise", СтрокаНачисления.csum_without_raise);
		УстановитьЗначениеАтрибута(ТекУслуга, "contractor",         СтрокаНачисления.contractor);
		
		УстановитьАтрибутыСоСчетчикамиВсе(ТекУслуга, СтрокаНачисления);
		
	КонецЕсли;
	
КонецПроцедуры

// Заполняет теги "service_debt" данными о начислениях.
//
Процедура ЗаполнитьСведенияПоСтрокеУслугБезНачислений(ТекУслуга, СтрокаНачисления, КвитанцияНаПени = Ложь)
	
	Если СтрокаНачисления.name = "" Тогда
		ТекУслуга.УстановитьАтрибут("name", "");
	Иначе
		УстановитьЗначениеАтрибута(ТекУслуга, "name",  СтрокаНачисления.name);
	КонецЕсли;
	
	УстановитьЗначениеАтрибута(ТекУслуга, "units",    СтрокаНачисления.units);
	УстановитьЗначениеАтрибута(ТекУслуга, "debt_beg", СтрокаНачисления.debt_beg);
	УстановитьЗначениеАтрибута(ТекУслуга, "debt_end", СтрокаНачисления.debt_end);
	
	Если НЕ КвитанцияНаПени Тогда
		УстановитьЗначениеАтрибута(ТекУслуга, "peni", СтрокаНачисления.peni);
		
		УстановитьАтрибутыСоСчетчикамиИПУ(ТекУслуга, СтрокаНачисления);
		
		УстановитьЗначениеАтрибута(ТекУслуга, "tarif", СтрокаНачисления.tarif);
	КонецЕсли;
	
	УстановитьЗначениеАтрибута(ТекУслуга, "sum_payed", СтрокаНачисления.sum_payed);
	
КонецПроцедуры

// Заполняет атрибуты счетчиков по услуге в теге "service".
//
Процедура УстановитьАтрибутыСоСчетчикамиВсе(ТекУслуга, СтрокаНачисления)
	
	УстановитьАтрибутыСоСчетчикамиИПУ(ТекУслуга, СтрокаНачисления);
	УстановитьАтрибутыСоСчетчикамиОПУ(ТекУслуга, СтрокаНачисления);
	
КонецПроцедуры

// Заполняет все атрибуты индивидуальных счетчиков по услуге в теге "service".
//
Процедура УстановитьАтрибутыСоСчетчикамиИПУ(ТекУслуга, СтрокаНачисления)
	
	Счетчик = 1;
	
	Для каждого ТекИПУ из СтрокаНачисления.meter Цикл
		
		УстановитьЗначениеАтрибута(ТекУслуга, "meter" + ?(Счетчик = 1, "", Строка(Счетчик)), ТекИПУ);
		
		Счетчик = Счетчик + 1;
		
	КонецЦикла;
	
КонецПроцедуры

// Заполняет все атрибуты общедомовых счетчиков по услуге в теге "service".
//
Процедура УстановитьАтрибутыСоСчетчикамиОПУ(ТекУслуга, СтрокаНачисления)
	
	Счетчик = 1;
	
	Для каждого ТекОПУ из СтрокаНачисления.hmeter Цикл
		
		УстановитьЗначениеАтрибута(ТекУслуга, "hmeter" + ?(Счетчик = 1, "", Строка(Счетчик)), ТекОПУ);
		
		Счетчик = Счетчик + 1;
		
	КонецЦикла;
	
КонецПроцедуры

// Устанавливает значение атрибута в указанном теге.
//
Процедура УстановитьЗначениеАтрибута(РодительскийЭлемент, НазваниеАтрибута, ЗначениеАтрибута) Экспорт
	
	Если НЕ ЗначениеАтрибута = Неопределено И НЕ ПустаяСтрока(ЗначениеАтрибута) Тогда
		РодительскийЭлемент.УстановитьАтрибут(НазваниеАтрибута, ПолучитьПредставлениеЗначения(ЗначениеАтрибута, Ложь));
	КонецЕсли;
	
КонецПроцедуры

// Заполняет сведения о начислениях по добровольному страхованию.
Процедура ЗаполнитьСведенияПоСтрокеДобровольногоСтрахования(ТекУслуга, СтрокаНачисления)

	УстановитьЗначениеАтрибута(ТекУслуга, "name",      СтрокаНачисления.name);
	УстановитьЗначениеАтрибута(ТекУслуга, "units",     СтрокаНачисления.units);
	УстановитьЗначениеАтрибута(ТекУслуга, "amount",    СтрокаНачисления.amount);
	УстановитьЗначениеАтрибута(ТекУслуга, "sum",       СтрокаНачисления.sum);
	УстановитьЗначениеАтрибута(ТекУслуга, "sum_payed", СтрокаНачисления.sum_payed);
	УстановитьЗначениеАтрибута(ТекУслуга, "tarif",     СтрокаНачисления.tarif);
	
КонецПроцедуры

// Добавляет тег штрихкода в указанный тег-родитель.
//
Процедура ДобавитьЭлементШтрихкода(ДокументDOM, ЭлементРодитель, СтруктураШтрихКода)
	
	Если НЕ СтруктураШтрихКода.type = "" И НЕ СтруктураШтрихКода.text = "" Тогда
		Штрихкод = ДокументDOM.СоздатьЭлемент("barcode");
		ЭлементРодитель.ДобавитьДочерний(Штрихкод);
		
		УстановитьЗначениеАтрибута(Штрихкод, "type", СтруктураШтрихКода.type);
		Штрихкод.ТекстовоеСодержимое = СтруктураШтрихКода.text;
	КонецЕсли;
	
КонецПроцедуры

// Добавляет теги основных штрихкодов квитанции.
//
Процедура ДобавитьЭлементыОсновныхШтрихкодов(ДокументDOM, ЭлементРодитель, МассивШтрихКодов)
	
	Для каждого ТекШК из МассивШтрихКодов Цикл
		ДобавитьЭлементШтрихкода(ДокументDOM, ЭлементРодитель, ТекШК);
	КонецЦикла;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// ЭЛЕКТРОННЫЕ ПАСПОРТА

// Выводит в HTML-документ таблицу с одноэтажной шапкой.
//
Процедура ВывестиПростуюТаблицу(ДокументHTML, ТекущийЭлемент, СтрокаПоказателя, ТаблицаСостоитИзДвухКолонок)
	
	// ШАПКА
	КорневойЭлемент = ДокументHTML.СоздатьЭлемент("table");
	КорневойЭлемент.УстановитьАтрибут("class", ?(ТаблицаСостоитИзДвухКолонок, "bordered col2", "bordered coln"));
	ТекущийЭлемент.ДобавитьДочерний(КорневойЭлемент);
	
	Элементthead = ДокументHTML.СоздатьЭлемент("thead");
	КорневойЭлемент.ДобавитьДочерний(Элементthead);
	
	Элементtr = ДокументHTML.СоздатьЭлемент("tr");
	Элементthead.ДобавитьДочерний(Элементtr);
	
	Для Каждого Колонка ИЗ СтрокаПоказателя.МассивКолонокТаблицы Цикл
		ЭлементКолонка = ДокументHTML.СоздатьЭлемент("th");
		ЭлементКолонка.ТекстовоеСодержимое = Колонка;
		Элементtr.ДобавитьДочерний(ЭлементКолонка);
	КонецЦикла;
	
	Если СтрокаПоказателя.ЗначениеПоказателя.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	// СТРОКИ
	ЭлементТелоТаблицы = ДокументHTML.СоздатьЭлемент("tbody");
	КорневойЭлемент.ДобавитьДочерний(ЭлементТелоТаблицы);
	
	Для Каждого ТекСтрокаПоказателя ИЗ СтрокаПоказателя.ЗначениеПоказателя Цикл
		ЭлементКореньСтроки = ДокументHTML.СоздатьЭлемент("tr");
		ЭлементТелоТаблицы.ДобавитьДочерний(ЭлементКореньСтроки);
		
		Для Каждого НазваниеКолонки ИЗ СтрокаПоказателя.МассивНазванийКолонокТаблицы Цикл
			ЭлементЗначение = ДокументHTML.СоздатьЭлемент("td");
			ЭлементЗначение.ТекстовоеСодержимое = ПолучитьПредставлениеЗначения(ТекСтрокаПоказателя[НазваниеКолонки]);
			ЭлементКореньСтроки.ДобавитьДочерний(ЭлементЗначение);
		КонецЦикла;
	КонецЦикла;
	
КонецПроцедуры // ВывестиПростуюТаблицу()

// Выводит в HTML-документ таблицу с двухэтажной шапкой.
//
Процедура ВывестиСложнуюТаблицу(ДокументHTML, ТекущийЭлемент, СтрокаПоказателя)
	
	// Определяем, колонки в каких строках нуждаются в объединении - основных или вложенных.
	ДлинаКолонокТаблицы          = Число(СтрокаПоказателя.ДлинаКолонокТаблицы);
	ДлинаКолонокВложеннойТаблицы = Число(СтрокаПоказателя.ДлинаКолонокВложеннойТаблицы);
	
	КоэфОбъединенияОсновныхСтрок  = 0;
	КоэфОбъединенияВложенныхСтрок = 0;
	
	Если ДлинаКолонокТаблицы > 0 И ДлинаКолонокВложеннойТаблицы > 0 Тогда
		Если ДлинаКолонокТаблицы > ДлинаКолонокВложеннойТаблицы Тогда
			КоэфОбъединенияОсновныхСтрок = ДлинаКолонокТаблицы / ДлинаКолонокВложеннойТаблицы;
		ИначеЕсли ДлинаКолонокТаблицы < ДлинаКолонокВложеннойТаблицы Тогда
			КоэфОбъединенияВложенныхСтрок = ДлинаКолонокВложеннойТаблицы / ДлинаКолонокТаблицы;
		КонецЕсли;
	КонецЕсли;
	
	КоэфОбъединенияОсновныхСтрок  = Строка(КоэфОбъединенияОсновныхСтрок);
	КоэфОбъединенияВложенныхСтрок = Строка(КоэфОбъединенияВложенныхСтрок);
	
	// ШАПКА
	КорневойЭлемент = ДокументHTML.СоздатьЭлемент("table");
	КорневойЭлемент.УстановитьАтрибут("class","bordered");
	ТекущийЭлемент.ДобавитьДочерний(КорневойЭлемент);
	
	Элементthead = ДокументHTML.СоздатьЭлемент("thead");
	КорневойЭлемент.ДобавитьДочерний(Элементthead);
	
	Элементtr = ДокументHTML.СоздатьЭлемент("tr");
	Элементthead.ДобавитьДочерний(Элементtr);
	
	// Основная шапка
	Для Каждого ОсновнаяКолонка ИЗ СтрокаПоказателя.МассивКолонокТаблицы Цикл
		ЭлементКолонка = ДокументHTML.СоздатьЭлемент("th");
		Если НЕ КоэфОбъединенияОсновныхСтрок = "0" Тогда
			ЭлементКолонка.УстановитьАтрибут("colspan", КоэфОбъединенияОсновныхСтрок);
		КонецЕсли;
		ЭлементКолонка.ТекстовоеСодержимое = ОсновнаяКолонка;
		Элементtr.ДобавитьДочерний(ЭлементКолонка);
	КонецЦикла;
	
	Элементtr = ДокументHTML.СоздатьЭлемент("tr");
	Элементthead.ДобавитьДочерний(Элементtr);
	
	// Вложенная шапка
	Для Каждого ВложеннаяКолонка ИЗ СтрокаПоказателя.МассивКолонокВложеннойТаблицы Цикл
		ЭлементКолонка = ДокументHTML.СоздатьЭлемент("th");
		Если НЕ КоэфОбъединенияВложенныхСтрок = "0" Тогда
			ЭлементКолонка.УстановитьАтрибут("colspan", КоэфОбъединенияВложенныхСтрок);
		КонецЕсли;
		ЭлементКолонка.ТекстовоеСодержимое = ВложеннаяКолонка;
		Элементtr.ДобавитьДочерний(ЭлементКолонка);
	КонецЦикла;
	
	Если СтрокаПоказателя.ЗначениеПоказателя.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	КолонкаСВложеннойТаблицей = НайтиКолонкуСоВложеннойТаблицей(СтрокаПоказателя.ЗначениеПоказателя);
	
	// СТРОКИ
	ЭлементТелоТаблицы = ДокументHTML.СоздатьЭлемент("tbody");
	КорневойЭлемент.ДобавитьДочерний(ЭлементТелоТаблицы);
	
	Для Каждого СтрокаОсновнойТаблицы ИЗ СтрокаПоказателя.ЗначениеПоказателя Цикл
		ЭлементКореньСтроки = ДокументHTML.СоздатьЭлемент("tr");
		ЭлементКореньСтроки.УстановитьАтрибут("class", "lighting");
		ЭлементТелоТаблицы.ДобавитьДочерний(ЭлементКореньСтроки);
		
		Для Каждого КолонкаОсновнойТаблицы ИЗ СтрокаПоказателя.МассивНазванийКолонокТаблицы Цикл
			ЭлементЗначение = ДокументHTML.СоздатьЭлемент("td");
			Если НЕ КоэфОбъединенияОсновныхСтрок = "0" Тогда
				ЭлементЗначение.УстановитьАтрибут("colspan", КоэфОбъединенияОсновныхСтрок);
			КонецЕсли;
			ЭлементЗначение.ТекстовоеСодержимое = ПолучитьПредставлениеЗначения(СтрокаОсновнойТаблицы[КолонкаОсновнойТаблицы]);
			ЭлементКореньСтроки.ДобавитьДочерний(ЭлементЗначение);
		КонецЦикла;
		
		Если КолонкаСВложеннойТаблицей = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		ВложеннаяТаблица = СтрокаОсновнойТаблицы[КолонкаСВложеннойТаблицей];
		
		Если ВложеннаяТаблица.Количество() = 0 Тогда
			Продолжить;
		КонецЕсли;
		
		Для Каждого СтрокаВложеннойТаблицы ИЗ ВложеннаяТаблица Цикл
			ЭлементКореньСтроки = ДокументHTML.СоздатьЭлемент("tr");
			ЭлементТелоТаблицы.ДобавитьДочерний(ЭлементКореньСтроки);
			
			Для Каждого КолонкаВложеннойТаблицы ИЗ СтрокаПоказателя.МассивНазванийКолонокВложеннойТаблицы Цикл
				ЭлементЗначение = ДокументHTML.СоздатьЭлемент("td");
				Если НЕ КоэфОбъединенияВложенныхСтрок = "0" Тогда
					ЭлементЗначение.УстановитьАтрибут("colspan", КоэфОбъединенияВложенныхСтрок);
				КонецЕсли;
				ЭлементЗначение.ТекстовоеСодержимое = ПолучитьПредставлениеЗначения(СтрокаВложеннойТаблицы[КолонкаВложеннойТаблицы]);
				ЭлементКореньСтроки.ДобавитьДочерний(ЭлементЗначение);
			КонецЦикла;
		КонецЦикла;
	КонецЦикла;
	
КонецПроцедуры // ВывестиСложнуюТаблицу()

// Выводит в HTML-документ группу (раздел) ЭП.
//
Процедура ДобавитьГруппуHTML(ДокументHTML, ТекущийЭлемент, СтрокаПоказателя)
	
	НоваяГруппа = ДокументHTML.СоздатьЭлемент("div");
	НоваяГруппа.УстановитьАтрибут("class", "section");
	ТекущийЭлемент.ДобавитьДочерний(НоваяГруппа);
	
	ТекущийЭлемент = НоваяГруппа;
	
	НазваниеГруппы = ДокументHTML.СоздатьЭлемент("h2");
	НазваниеГруппы.ТекстовоеСодержимое = СтрокаПоказателя.ЗначениеПоказателя;
	ТекущийЭлемент.ДобавитьДочерний(НазваниеГруппы);
	
КонецПроцедуры // ДобавитьГруппуHTML()

// Выводит в HTML-документ подгруппу (вложенный раздел) ЭП.
//
Процедура ДобавитьПодгруппуHTML(ДокументHTML, ТекущийЭлемент, СтрокаПоказателя)
	
	НоваяПодгруппа = ДокументHTML.СоздатьЭлемент("div");
	НоваяПодгруппа.УстановитьАтрибут("class", "subsection");
	ТекущийЭлемент.ДобавитьДочерний(НоваяПодгруппа);
	
	ТекущийЭлемент = НоваяПодгруппа;
	
	НазваниеПодгруппы = ДокументHTML.СоздатьЭлемент("h4");
	НазваниеПодгруппы.ТекстовоеСодержимое = СтрокаПоказателя.ЗначениеПоказателя;
	ТекущийЭлемент.ДобавитьДочерний(НазваниеПодгруппы);
	
КонецПроцедуры // ДобавитьПодгруппуHTML()

// Выводит в HTML-документ статичные элементы ЭП.
//
Процедура ДобавитьСтатичныеЭлементыHTML(ДокументHTML, ТекущийЭлемент, ТаблицаПоказателейHTML, СтрокаПоказателя)
	
	ИндексТекСтроки    = ТаблицаПоказателейHTML.Индекс(СтрокаПоказателя);
	МаксимальныйИндекс = ТаблицаПоказателейHTML.Количество() - 1;
	
	ТаблицаСтатичныхДанных = ДокументHTML.СоздатьЭлемент("table");
	ТаблицаСтатичныхДанных.УстановитьАтрибут("class", "col2");
	ТекущийЭлемент.ДобавитьДочерний(ТаблицаСтатичныхДанных);
	
	ТекСтрока = СтрокаПоказателя;
	
	Пока НЕ ТекСтрока = Неопределено Цикл
		Если ИндексТекСтроки > МаксимальныйИндекс Тогда
			ТекСтрока = Неопределено;
			Продолжить;
		Иначе
			ТекСтрока = ТаблицаПоказателейHTML.Получить(ИндексТекСтроки);
			Если НЕ ТекущийЭлементСтатичный(ТекСтрока) Тогда
				ТекСтрока = Неопределено;
				Продолжить;
			КонецЕсли;
		КонецЕсли;
		
		ДобавитьСтатичныйЭлементHTML(ДокументHTML, ТаблицаСтатичныхДанных, ТекСтрока);
		
		ТекСтрока.ЭлементДобавлен = Истина;
		ИндексТекСтроки           = ИндексТекСтроки + 1;
	КонецЦикла;
	
КонецПроцедуры //ДобавитьСтатичныйЭлементHTML()

// Выводит в HTML-документ текущий статичный элемент ЭП.
//
Процедура ДобавитьСтатичныйЭлементHTML(ДокументHTML, ТаблицаСтатичныхДанных, ТекСтрока)
	
	КорневойЭлемент = ДокументHTML.СоздатьЭлемент("tr");
	ТаблицаСтатичныхДанных.ДобавитьДочерний(КорневойЭлемент);
	
	ЭлементНазвание = ДокументHTML.СоздатьЭлемент("td");
	ЭлементНазвание.ТекстовоеСодержимое = ТекСтрока.НазваниеПоказателя;
	КорневойЭлемент.ДобавитьДочерний(ЭлементНазвание);
	
	ЭлементЗначение = ДокументHTML.СоздатьЭлемент("td");
	ЭлементЗначение.ТекстовоеСодержимое = ПолучитьПредставлениеЗначения(ТекСтрока.ЗначениеПоказателя);
	КорневойЭлемент.ДобавитьДочерний(ЭлементЗначение);
	
КонецПроцедуры // ДобавитьСтатичныйЭлементHTML()

// Выводить в HTML-документ таблицу.
//
Процедура ДобавитьТаблицуHTML(ДокументHTML, ТекущийЭлемент, СтрокаПоказателя)
	
	Если СтрокаПоказателя.МассивКолонокВложеннойТаблицы.Количество() = 0 Тогда
		// Простая таблица
		Если СтрокаПоказателя.МассивКолонокТаблицы.Количество() = 2 Тогда
			ВывестиПростуюТаблицу(ДокументHTML, ТекущийЭлемент, СтрокаПоказателя, Истина);
		Иначе
			ВывестиПростуюТаблицу(ДокументHTML, ТекущийЭлемент, СтрокаПоказателя, Ложь);
		КонецЕсли;
		
	Иначе
		// Сложная таблица
		ВывестиСложнуюТаблицу(ДокументHTML, ТекущийЭлемент, СтрокаПоказателя);
		
	КонецЕсли;
	
КонецПроцедуры // ДобавитьТаблицуHTML()

// Находит в текущей ТЗ колонку, хранящую вложенную ТЗ.
//
Функция НайтиКолонкуСоВложеннойТаблицей(Таблица)
	
	ПерваяСтрока = Таблица.Получить(0);
	
	Для Каждого Колонка ИЗ Таблица.Колонки Цикл
		Если ТипЗнч(ПерваяСтрока[Колонка.Имя]) = Тип("ТаблицаЗначений") Тогда
			Возврат Колонка.Имя;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Неопределено;
	
КонецФункции // НайтиКолонкуСоВложеннойТаблицей()

// Для текущего значения показателя формирует строковое представление, которое можно вывести в HTML-документ.
//
Функция ПолучитьПредставлениеЗначения(ЗначениеПоказателя, ДляHTMLФайла = Истина)
	
	Если ДляHTMLФайла Тогда
		Если ТипЗнч(ЗначениеПоказателя) = Тип("Строка") Тогда
			Возврат ЗначениеПоказателя;
		ИначеЕсли ТипЗнч(ЗначениеПоказателя) = Тип("Дата") Тогда
			Возврат Формат(ЗначениеПоказателя, "ДФ=dd.MM.yyyy");
		Иначе
			Возврат Строка(ЗначениеПоказателя);
		КонецЕсли;
	Иначе
		Если ТипЗнч(ЗначениеПоказателя) = Тип("Строка") Тогда
			Возврат ЗначениеПоказателя;
		ИначеЕсли ТипЗнч(ЗначениеПоказателя) = Тип("Дата") ИЛИ ТипЗнч(ЗначениеПоказателя) = Тип("Число") Тогда
			Возврат XMLСтрока(ЗначениеПоказателя);
		Иначе
			Возврат Строка(ЗначениеПоказателя);
		КонецЕсли;
	КонецЕсли;
	
КонецФункции // ПолучитьПредставлениеЗначения(

// Получается строковое представление кода HTML-документа.
//
Функция ПолучитьТекстHTMLИзОбъектаДокументHTML(Знач ДокументHTML)
	
	ЗаписьDOM = Новый ЗаписьDOM;
	ЗаписьHTML = Новый ЗаписьHTML;
	ЗаписьHTML.УстановитьСтроку();
	ЗаписьDOM.Записать(ДокументHTML, ЗаписьHTML);
	Возврат ЗаписьHTML.Закрыть();
	
КонецФункции

// Формирует HTML-документ.
//
Функция ПолучитьТекстHTMLФайла(ТаблицаДанных) Экспорт
	
	ДокументHTML = Новый ДокументHTML;
	
	ЭлементТело = ДокументHTML.СоздатьЭлемент("body");
	ДокументHTML.Тело = ЭлементТело;
	
	ТекущийЭлемент = ЭлементТело;
	
	ТаблицаДанных.Колонки.Добавить("ЭлементДобавлен", Новый ОписаниеТипов("Булево"));
	
	Для Каждого СтрокаПоказателя ИЗ ТаблицаДанных Цикл
		// Статичные данные в рамках подгрупп добавляются пачкой в процедуре ДобавитьСтатичныеЭлементыHTML().
		Если СтрокаПоказателя.ЭлементДобавлен Тогда
			Продолжить;
		КонецЕсли;
		
		Если СтрокаПоказателя.ТипПоказателя = "группа" Тогда
			ДобавитьГруппуHTML(ДокументHTML, ТекущийЭлемент, СтрокаПоказателя);
		ИначеЕсли СтрокаПоказателя.ТипПоказателя = "подгруппа" Тогда
			ДобавитьПодгруппуHTML(ДокументHTML, ТекущийЭлемент, СтрокаПоказателя);
		ИначеЕсли СтрокаПоказателя.ТипПоказателя = "статичные данные" Тогда
			ДобавитьСтатичныеЭлементыHTML(ДокументHTML, ТекущийЭлемент, ТаблицаДанных, СтрокаПоказателя);
		ИначеЕсли СтрокаПоказателя.ТипПоказателя = "таблица" Тогда
			ДобавитьТаблицуHTML(ДокументHTML, ТекущийЭлемент, СтрокаПоказателя);
		КонецЕсли;
	КонецЦикла;
	
	Возврат ПолучитьТекстHTMLИзОбъектаДокументHTML(ДокументHTML);
	
КонецФункции // ПолучитьТекстHTMLФайла()

// Получает текст блока HTML-документа.
//
Функция ПолучитьТекстБлокаHTMLФайла(ТаблицаДанных) Экспорт
	
	ТаблицаДанных.Удалить(0);
	
	ПолныйТекстФайла = ПолучитьТекстHTMLФайла(ТаблицаДанных);
	
	Возврат УбратьИзТекстаHTMLФайлаЛишниеДанные(ПолныйТекстФайла);
	
КонецФункции // ПолучитьТекстБлокаHTMLФайла()

// Убирает из текста HTML-документа лишние данные.
//
Функция УбратьИзТекстаHTMLФайлаЛишниеДанные(ПолныйТекстФайла)
	
	// Убираем вспомогательные данные из начала текста
	ПозицияПервогоСимвола = Найти(ПолныйТекстФайла, "<body>");
	Если ПозицияПервогоСимвола = 0 Тогда
		Возврат "";
	КонецЕсли;
	
	ПолныйТекстФайла = Сред(ПолныйТекстФайла, ПозицияПервогоСимвола + 6);
	
	// Убираем вспомогательные данные из конца текста (</body></html>)
	ПолныйТекстФайла = Лев(ПолныйТекстФайла, СтрДлина(ПолныйТекстФайла) - 14);
	
	Возврат ПолныйТекстФайла;
	
КонецФункции // УбратьИзТекстаHTMLФайлаЛишниеДанные()

// Проверяет является ли текущий элемент статичным.
//
Функция ТекущийЭлементСтатичный(ТекСтрока)
	
	Если ТекСтрока = Неопределено ИЛИ НЕ ТекСтрока.ТипПоказателя = "статичные данные" Тогда
		Возврат Ложь;
	Иначе
		Возврат Истина;
	КонецЕсли;
	
КонецФункции // ТекущийЭлементСтатичный()

// Формирует xml-файл с ЭП.
//
Функция ФормироватьФайлСДаннымиПоЭлектроннымПаспортам(СтруктураДанных) Экспорт

	// Получаем имя временного файла.
	ИмяВременногоФайла = ПолучитьИмяВременногоФайла("xml");
	
	// Создаем XML файл.
	ЗаписьXML = Новый ЗаписьXML;
	ЗаписьXML.ОткрытьФайл(ИмяВременногоФайла, "windows-1251");
	
	// Записываем сведения об организации в элемент "org".
	ДокументDOM = Новый ДокументDOM("", "org");
	КорневойЭлемент = ДокументDOM.ЭлементДокумента;
	
	УстановитьЗначениеАтрибута(КорневойЭлемент, "filedate", СтруктураДанных.filedate);
	УстановитьЗначениеАтрибута(КорневойЭлемент, "name",     СтруктураДанных.name);
	УстановитьЗначениеАтрибута(КорневойЭлемент, "inn",      СтруктураДанных.inn);
	УстановитьЗначениеАтрибута(КорневойЭлемент, "filetype", СтруктураДанных.filetype);
	УстановитьЗначениеАтрибута(КорневойЭлемент, "version",  СтруктураДанных.version);
	
	ГруппаДома = ДокументDOM.СоздатьЭлемент("houses");
	КорневойЭлемент.ДобавитьДочерний(ГруппаДома);
	
	Для Каждого СтрокаДома ИЗ СтруктураДанных.ТаблицаДомов Цикл
		ГруппаДом = ДокументDOM.СоздатьЭлемент("house");
		ГруппаДома.ДобавитьДочерний(ГруппаДом);
		
		УстановитьЗначениеАтрибута(ГруппаДом, "id",                    СтрокаДома.id);
		УстановитьЗначениеАтрибута(ГруппаДом, "type",                  СтрокаДома.type);
		УстановитьЗначениеАтрибута(ГруппаДом, "address_view_full",     СтрокаДома.address_view_full);
		УстановитьЗначениеАтрибута(ГруппаДом, "address",               СтрокаДома.address);
		УстановитьЗначениеАтрибута(ГруппаДом, "street",                СтрокаДома.street);
		УстановитьЗначениеАтрибута(ГруппаДом, "house",                 СтрокаДома.house);
		УстановитьЗначениеАтрибута(ГруппаДом, "series",                СтрокаДома.series);
		УстановитьЗначениеАтрибута(ГруппаДом, "year_of_built",         СтрокаДома.year_of_built);
		УстановитьЗначениеАтрибута(ГруппаДом, "date_of_commissioning", СтрокаДома.date_of_commissioning);
		УстановитьЗначениеАтрибута(ГруппаДом, "date_of_maintenance",   СтрокаДома.date_of_maintenance);
		УстановитьЗначениеАтрибута(ГруппаДом, "com_area",              СтрокаДома.com_area);
		УстановитьЗначениеАтрибута(ГруппаДом, "floors",                СтрокаДома.floors);
		Если СтрокаДома.type = "МКД" Тогда
			УстановитьЗначениеАтрибута(ГруппаДом, "wear",             СтрокаДома.wear);
			УстановитьЗначениеАтрибута(ГруппаДом, "porches",          СтрокаДома.porches);
			УстановитьЗначениеАтрибута(ГруппаДом, "living_rooms",     СтрокаДома.living_rooms);
			УстановитьЗначениеАтрибута(ГруппаДом, "nonliving_rooms",  СтрокаДома.nonliving_rooms);
			УстановитьЗначениеАтрибута(ГруппаДом, "people",           СтрокаДома.people);
			УстановитьЗначениеАтрибута(ГруппаДом, "accounts",         СтрокаДома.accounts);
			УстановитьЗначениеАтрибута(ГруппаДом, "people_accounts",  СтрокаДома.people_accounts);
			УстановитьЗначениеАтрибута(ГруппаДом, "company_accounts", СтрокаДома.company_accounts);
		Иначе
			УстановитьЗначениеАтрибута(ГруппаДом, "year_of_commissioning", СтрокаДома.year_of_commissioning);
			УстановитьЗначениеАтрибута(ГруппаДом, "reg_people",            СтрокаДома.reg_people);
		КонецЕсли;
		
		ГруппаHTML = ДокументDOM.СоздатьЭлемент("contents");
		ГруппаДом.ДобавитьДочерний(ГруппаHTML);
		
		Для Каждого СтрокаHTML Из СтрокаДома.contents Цикл
			БлокHTML = ДокументDOM.СоздатьЭлемент("content");
			УстановитьЗначениеАтрибута(БлокHTML, "name", СтрокаHTML.name);
			УстановитьЗначениеАтрибута(БлокHTML, "type", СтрокаHTML.type);
			БлокHTML.ТекстовоеСодержимое = СтрокаHTML.text;
			ГруппаHTML.ДобавитьДочерний(БлокHTML);
		КонецЦикла;
	КонецЦикла;
	
	Для Каждого СтрокаДомаБезЭП ИЗ СтруктураДанных.ТаблицаДомовБезЭП Цикл
		ГруппаДом = ДокументDOM.СоздатьЭлемент("house");
		ГруппаДома.ДобавитьДочерний(ГруппаДом);
		
		УстановитьЗначениеАтрибута(ГруппаДом, "id",                    СтрокаДомаБезЭП.id);
		УстановитьЗначениеАтрибута(ГруппаДом, "type",                  СтрокаДомаБезЭП.type);
		УстановитьЗначениеАтрибута(ГруппаДом, "address",               СтрокаДомаБезЭП.address);
		УстановитьЗначениеАтрибута(ГруппаДом, "address_view_full",     СтрокаДомаБезЭП.address_view_full);
		УстановитьЗначениеАтрибута(ГруппаДом, "street",                СтрокаДомаБезЭП.street);
		УстановитьЗначениеАтрибута(ГруппаДом, "house",                 СтрокаДомаБезЭП.house);
		УстановитьЗначениеАтрибута(ГруппаДом, "year_of_built",         СтрокаДомаБезЭП.year_of_built);
		УстановитьЗначениеАтрибута(ГруппаДом, "date_of_commissioning", СтрокаДомаБезЭП.date_of_commissioning);
		УстановитьЗначениеАтрибута(ГруппаДом, "date_of_maintenance",   СтрокаДомаБезЭП.date_of_maintenance);
		УстановитьЗначениеАтрибута(ГруппаДом, "com_area",              СтрокаДомаБезЭП.com_area);
		УстановитьЗначениеАтрибута(ГруппаДом, "floors",                СтрокаДомаБезЭП.floors);
		Если СтрокаДомаБезЭП.type = "МКД" Тогда
			УстановитьЗначениеАтрибута(ГруппаДом, "porches",         СтрокаДомаБезЭП.porches);
			УстановитьЗначениеАтрибута(ГруппаДом, "living_rooms",    СтрокаДомаБезЭП.living_rooms);
			УстановитьЗначениеАтрибута(ГруппаДом, "nonliving_rooms", СтрокаДомаБезЭП.nonliving_rooms);
		КонецЕсли;
	КонецЦикла;
	
	ЗаписьDOM = Новый ЗаписьDOM();
	ЗаписьDOM.Записать(ДокументDOM, ЗаписьXML);
	
	ЗаписьXML.Закрыть();
	
	Возврат ИмяВременногоФайла;

КонецФункции // ФормироватьФайлСДаннымиПоЭлектроннымПаспортам()

#КонецОбласти

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ЭКСПОРТА

#Область ПроцедурыИФункцииЭкспорта

// Отправляет на сайт запрос на передачу файла.
//
// Параметры:
//  мHTTPСоединение - объект, с помощью которого осуществляется соединение с сайтом.
//  АдресСайта - Строка - адрес сайта.
//  Логин - Строка - логин доступа к админской части сайта.
//  Пароль - Строка - пароль доступа к админской части сайта.
//  ФайлВыгрузки - Строка - полный путь к файлу выгрузки.
//  РазрешенныйРазмер - Число - максимальный возможный объем данных, который можно передать за 1 раз.
//  Куки - Структура - Cookie сайта.
//  ТипДанных - Строка - идентификатор передаваемых данных.
//  Организация - ссылка на "Организацию".
//  СтруктураИнформацииОСайте - Структура - информация о сайте.
//  СведенияОбОшибке - Строка - сведения об ошибке.
//
// Возвращаемое значение:
//  Строка, Неопределено.
//
Функция ПередатьФайлНаСайт(мHTTPСоединение, Логин, Пароль, ФайлВыгрузки, РазрешенныйРазмер, Куки, ТипДанных, Организация,
						   АдресМодуля, СтруктураИнформацииОСайте, СведенияОбОшибке = "", ПоследнийЭтапВыгрузки = Истина, ИспользуетсяПовторнаяОтправка = Ложь)
	
	РазмерПереданныхДанных = 0;
	
	ПередаваемыйФайл = Новый Файл(ФайлВыгрузки);
	ИмяФайла         = ПередаваемыйФайл.Имя;
	ТекстФайла       = Новый ЧтениеТекста(ФайлВыгрузки);
	СтрокаПередачи   = ТекстФайла.Прочитать() + Символы.ПС;
	ТекстФайла.Закрыть();
	
	РазмерФайла   = СтрДлина(СтрокаПередачи);
	ТекущийРазмер = ?(РазмерФайла <= РазрешенныйРазмер, РазмерФайла, РазрешенныйРазмер);
	
	// Т.к. на сайте имеется ограничение на объем передаваемых данных, передаем файл частями.
	Пока РазмерПереданныхДанных < РазмерФайла Цикл
		СтрокаТекста = Лев(СтрокаПередачи, ТекущийРазмер);
		Попытка
			
			// Если файл отправляется повторно, то добавляем параметр "debug_mode".
			// В настоящее время на сайте данный параметр никак не обрабатывается,
			// и добавлен для будущих доработок.
			ТекстЗапроса = СтрШаблон("%1?mode=file&type=%2&filename=%3%4", АдресМодуля, UrlEncode(ТипДанных), UrlEncode(ИмяФайла), ?(ИспользуетсяПовторнаяОтправка, "&debug_mode=1", ""));
			Ответ        = ОтправитьPOSTЗапросНаСайт(мHTTPСоединение, Куки, ТекстЗапроса, СтрокаТекста);
			
			Если Лев(Ответ, 7) = "success" Тогда
				РазмерПереданныхДанных = РазмерПереданныхДанных + ТекущийРазмер;
				СтрокаПередачи         = Сред(СтрокаПередачи, ТекущийРазмер + 1, РазмерФайла - РазмерПереданныхДанных);
				ТекущийРазмер          = РазмерФайла - РазмерПереданныхДанных;
				Если ТекущийРазмер > РазрешенныйРазмер Тогда
					ТекущийРазмер = РазрешенныйРазмер;
				КонецЕсли;
			Иначе
				ОшибкаОбмена = ПолучитьОписаниеОшибкиОбмена(Ответ);
				СведенияОбОшибке = "Не удалось загрузить файл на сайт" + ?(ПустаяСтрока(ОшибкаОбмена), ".", ": " + ОшибкаОбмена);
				УПЖКХ_ТиповыеМетодыКлиентСервер.СообщитьОбОшибке(СведенияОбОшибке);
				
				Возврат СформироватьСтруктуруОтветаПоНаборуПараметров(,, Ответ);
			КонецЕсли;
		Исключение
			СведенияОбОшибке = ОбработатьТекстОшибки(ОписаниеОшибки());
			УПЖКХ_ТиповыеМетодыКлиентСервер.СообщитьОбОшибке(СведенияОбОшибке);
			
			Возврат СформироватьСтруктуруОтветаПоНаборуПараметров(,, СведенияОбОшибке);
		КонецПопытки;
	КонецЦикла;
	
	СтруктураОтвета = ЗапросНаЭкспортФайла(мHTTPСоединение, Логин, Пароль, ТипДанных, ФайлВыгрузки, Куки, Организация,
										   АдресМодуля, СведенияОбОшибке, СтруктураИнформацииОСайте);
	
	Если НЕ СтруктураОтвета.status = "failure" И ПоследнийЭтапВыгрузки Тогда
		УПЖКХ_ТиповыеМетодыКлиентСервер.СообщитьПользователю("Данные загружены.");
	КонецЕсли;
	
	Возврат СтруктураОтвета;
	
КонецФункции // ПередатьФайлНаСайт()

// Передает на сайт файл с данными.
//
// Параметры:
//  ФайлВыгрузки - Строка - полный путь к файлу с данными.
//  ТипДанных - Строка - идентификатор передаваемых данных.
//  АдресСайта - Строка - адрес сайта.
//  Логин - Строка - логин доступа к админской части сайта.
//  Пароль - Строка - пароль доступа к админской части сайта.
//  СведенияОбОшибке - Строка - сведения об ошибке.
//  ИспользоватьSSL - Булево - необходимо ли использовать https.
//  СтруктураИнформацииОСайте - Структура - информация о сайте.
//  ПоследнийЭтапВыгрузки - Булево - при выгрузке по частям указывает, является ли текущий этап завершающим.
//
// Возвращаемое значение:
//  Строка, Неопределено.
//
Функция ПередатьДанныеНаСайт(ФайлВыгрузки, ТипДанных, НастройкаДоступа, Пароль, СведенияОбОшибке = "",
							 СтруктураИнформацииОСайте, ПоследнийЭтапВыгрузки = Истина, ИспользуетсяПовторнаяОтправка = Ложь) Экспорт
	
	Организация    = НастройкаДоступа.Организация;
	АдресСайта     = НастройкаДоступа.АдресСайта;
	Логин          = НастройкаДоступа.Логин;
	
	// Устанавливаем соединение.
	мHTTPСоединение = ПолучитьHTTPСоединение(АдресСайта, Логин, Пароль, СтруктураИнформацииОСайте.ИспользоватьSSL);
	
	// Получаем Cookie сайта.
	Куки = УстановитьСоединениеССайтом(мHTTPСоединение, Логин, Пароль, СведенияОбОшибке, СтруктураИнформацииОСайте);
	
	Если Куки = Неопределено Тогда
		Возврат СформироватьСтруктуруОтветаПоНаборуПараметров(,, "Неудачное соединение с сервером ЖКХ.");
	КонецЕсли;
	
	// Не актуально.
	АдресМодуля = ?(ТипДанных = "E-Passports", "bitrix/admin/tszh_epasport_exchange.php", "bitrix/admin/tszh_exchange.php");
	
	// Определяем максимально возмодный объем данных, который можно передать за 1 раз.
	РазрешенныйРазмер = ПолучитьРазрешенныйРазмерФайлаОбмена(мHTTPСоединение, Логин, Пароль,
															 Куки, АдресМодуля, СведенияОбОшибке);
	
	Если РазрешенныйРазмер = 0 Тогда
		Возврат СформироватьСтруктуруОтветаПоНаборуПараметров(,, "Не удалось установить разрешенный для передачи на сайт размер данных.");
	КонецЕсли;
	
	// Получаем ответ на запрос передачи файла.
	Возврат ПередатьФайлНаСайт(мHTTPСоединение, Логин, Пароль, ФайлВыгрузки, РазрешенныйРазмер, Куки, ТипДанных, Организация,
							   АдресМодуля, СтруктураИнформацииОСайте, СведенияОбОшибке, ПоследнийЭтапВыгрузки, ИспользуетсяПовторнаяОтправка);
	
КонецФункции // ПередатьДанныеНаСайт

// Экспорт файла на сайт.
//
// Параметры:
//  мHTTPСоединение - объект, с помощью которого осуществляется соединение с сайтом.
//  АдресСайта - Строка - адрес сайта.
//  Логин - Строка - логин доступа к админской части сайта.
//  Пароль - Строка - пароль доступа к админской части сайта.
//  ТипДанных - Строка - идентификатор передаваемых данных.
//  ФайлВыгрузки - Строка - полный путь к файлу с данными.
//  Куки - Структура - Cookie сайта.
//  Организация - Ссылка на "Организацию".
//  СведенияОбОшибке - Строка - сведения об ошибке.
//  КоличествоПопыток - Число - количество попыток передачи файла.
//
// Возвращаемое значение:
//  Строка, Неопределено.
//
Функция ЗапросНаЭкспортФайла(мHTTPСоединение, Логин, Пароль, ТипДанных, ФайлВыгрузки, Куки, Организация,
							 АдресМодуля, СведенияОбОшибке, СтруктураИнформацииОСайте, КоличествоПопыток = 100)
	
	ПередаваемыйФайл = Новый Файл(ФайлВыгрузки);
	ИмяФайла         = ПередаваемыйФайл.Имя;
	ИННОрганизации   = Организация.ИНН;
	КППОрганизации   = Организация.КПП;
	
	// Реализуем задержку между запросами в 3 секунды с помощью цикла.
	// Для этого создадим специальную переменную.
	ВремяВызоваЗапроса = ТекущаяДата();
	
	ном = 1;
	
	Пока ном <= КоличествоПопыток Цикл
		
		ТекущееВремя = ТекущаяДата();
		
		Если ТекущееВремя >= ВремяВызоваЗапроса Тогда
			
			Попытка
				
				ТекстЗапроса = СтрШаблон("%1?mode=import&type=%2&filename=%3&inn=%4&kpp=%5&build=%6", АдресМодуля, UrlEncode(ТипДанных), UrlEncode(ИмяФайла), UrlEncode(ИННОрганизации), UrlEncode(КППОрганизации), XMLСтрока(СтруктураИнформацииОСайте.НомерБилда));
				Ответ        = ОтправитьGETЗапросНаСайт(мHTTPСоединение, Куки, ТекстЗапроса);
				
				// Разбираем ответ и формируем структуру ответа.
				СтруктураОтвета = ПолучитьСтруктуруОтветаНаЗапросЭкпортаФайла(Ответ, СтруктураИнформацииОСайте);
				
				// Если загрузка еще выполняется, то отправляем запрос повторно.
				// В противном случае возвращаем ответ как есть.
				// Обработкой ответа теперь будет заниматься журнал обмена.
				Если СтруктураОтвета.status = "progress" Тогда
					ном = ном + 1;
				Иначе
					Если СтруктураОтвета.status = "warning" ИЛИ СтруктураОтвета.status = "failure" Тогда
						// Если при передаче данных на сайт произошла ошибка, то выводим ее описание.
						Если НЕ СтруктураИнформацииОСайте.НомерБилда = 1 Тогда
							УПЖКХ_ТиповыеМетодыКлиентСервер.СообщитьОбОшибке(?(ПустаяСтрока(СтруктураОтвета.error), "Не удалось загрузить файл на сайт.", СтруктураОтвета.error));
						КонецЕсли;
					КонецЕсли;
					
					Прервать;
				КонецЕсли;
				
				ВремяВызоваЗапроса = ТекущаяДата() + 3;
				
			Исключение
				СтруктураОтвета       = ПолучитьСтруктуруОтветаНаЗапросЭкпортаФайла("", СтруктураИнформацииОСайте);
				СведенияОбОшибке      = ОбработатьТекстОшибки(ОписаниеОшибки());
				СтруктураОтвета.error = СведенияОбОшибке;
				УПЖКХ_ТиповыеМетодыКлиентСервер.СообщитьОбОшибке(СведенияОбОшибке);
				
				Прервать;
			КонецПопытки;
		КонецЕсли;
	КонецЦикла;
	
	Возврат СтруктураОтвета;
	
КонецФункции // ЗапросНаЭкспортФайла()

#КонецОбласти

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ИМПОРТА

#Область ПроцедурыИФункцииИмпорта

// Получает объект соединения к сайту.
//
Функция ПолучитьHTTPСоединение(АдресСайта, Логин, Пароль, ИспользоватьSSL, Таймаут = 300) Экспорт
	
	SSLОбъект = ?(ИспользоватьSSL,
				  Новый ЗащищенноеСоединениеOpenSSL(Неопределено, Неопределено),
				  Неопределено);
	
	мHTTPСоединение = Новый HTTPСоединение(ЗакодироватьАдресСайта(АдресСайта), , Логин, Пароль,, Таймаут, SSLОбъект);
	
	Возврат мHTTPСоединение;
	
КонецФункции

// Подключается к сайту и получает Cookie.
// Параметры:
//  мHTTPСоединение - объект, с помощью которого осуществляется соединение с сайтом.
//  АдресСайта - Строка - адрес сайта.
//  Логин - Строка - логин доступа к админской части сайта.
//  Пароль - Строка - пароль доступа к админской части сайта.
//  СведенияОбОшибке - Строка - сведения об ошибке.
//  СтруктураИнформацииОСайте - Структура - информация о сайте.
//
// Возвращаемое значение:
//  Структура.
//
Функция УстановитьСоединениеССайтом(мHTTPСоединение, Логин, Пароль, СведенияОбОшибке = "", СтруктураИнформацииОСайте, ПовторноеПодключение = Ложь)
	
	// Формируем файл, необходимый для подключения.
	СтрокаBase64 = УПЖКХ_ВебИнтеграцияОбщегоНазначения.ПреобразоватьСтрокуВBase64(Логин + ":" + Пароль, КодировкаТекста.ANSI);
	
	// Отправляем запрос на получение Cookie.
	Попытка
		ЗаголовкиHTTP = Новый Соответствие;
		ЗаголовкиHTTP.Вставить("Authorization", "Basic " + СтрокаBase64);
		ЗаголовкиHTTP.Вставить("Host",          мHTTPСоединение.Сервер);
		ЗаголовкиHTTP.Вставить("User-Agent",    УПЖКХ_ВебИнтеграцияВзаимодействиеСБазойДанных.ПолучитьПредставлениеАгентаДляСайта());
		ЗапросHTTP = Новый HTTPЗапрос("bitrix/admin/tszh_exchange.php?mode=checkauth" + ?(СтруктураИнформацииОСайте.ВерсияФорматаОбмена = 3, "", "&version=" + Строка(СтруктураИнформацииОСайте.ВерсияФорматаОбмена)), ЗаголовкиHTTP);
		
		ОтветHTTP  = мHTTPСоединение.Получить(ЗапросHTTP);
		Ответ      = СокрЛ(ОтветHTTP.ПолучитьТелоКакСтроку());
	Исключение
		СведенияОбОшибке = "Неудачная авторизация: исключительная ошибка.";
		УПЖКХ_ТиповыеМетодыКлиентСервер.СообщитьОбОшибке(СведенияОбОшибке);
		Возврат Неопределено;
	КонецПопытки;
	
	// Если сайт перемещен, то пытаемся перейти на сайт, указанный в заголовке "Location".
	Если ОтветHTTP.КодСостояния = 301 ИЛИ ОтветHTTP.КодСостояния = 302 Тогда
		
		мHTTPСоединение = ИзменитьHTTPСоединениеВСлучаеЕслиРесурсПеремещен(мHTTPСоединение, ОтветHTTP, СведенияОбОшибке);
		
		Если мHTTPСоединение = Неопределено Тогда
			Возврат Неопределено;
		Иначе
			Возврат УстановитьСоединениеССайтом(мHTTPСоединение, Логин, Пароль, СведенияОбОшибке, СтруктураИнформацииОСайте);
		КонецЕсли;
		
	ИначеЕсли Не ОтветHTTP.КодСостояния = 200 И Не ПовторноеПодключение Тогда
		
		мHTTPСоединение = ПолучитьHTTPСоединение(мHTTPСоединение.Сервер, Логин, Пароль, Не СтруктураИнформацииОСайте.ИспользоватьSSL);
		
		Возврат УстановитьСоединениеССайтом(мHTTPСоединение, Логин, Пароль, СведенияОбОшибке, СтруктураИнформацииОСайте, Истина);
		
	ИначеЕсли ОтветHTTP.КодСостояния = 200 И ПовторноеПодключение Тогда
		
		СтруктураИнформацииОСайте.ИспользоватьSSL = НЕ СтруктураИнформацииОСайте.ИспользоватьSSL;
		
	КонецЕсли;
	
	// При удачной авторизации получим ответ "success".
	Если НЕ Лев(Ответ, 7) = "success" Тогда
		ОшибкаОбмена = ПолучитьОписаниеОшибкиОбмена(Ответ);
		СведенияОбОшибке = "Неудачная авторизация" + ?(ПустаяСтрока(ОшибкаОбмена), ".", ": " + ОшибкаОбмена);
		УПЖКХ_ТиповыеМетодыКлиентСервер.СообщитьОбОшибке(СведенияОбОшибке);
		Возврат Неопределено;
	КонецЕсли;
	
	Ответ = Прав(Ответ, СтрДлина(Ответ) - 8);
	ПозПС = Найти(Ответ, Символы.ПС);
	Если ПозПС = 0 Тогда
		СведенияОбОшибке = "Неудачная авторизация: не удалось получить Cookie.";
		УПЖКХ_ТиповыеМетодыКлиентСервер.СообщитьОбОшибке(СведенияОбОшибке);
		Возврат Неопределено;
	КонецЕсли;
	
	Куки  = Новый Структура("Имя", Лев(Ответ, ПозПС - 1));
	Ответ = Прав(Ответ, СтрДлина(Ответ) - ПозПС);
	Куки.Вставить("Cookie", Лев(Ответ, СтрДлина(Ответ) - 1));
	
	Возврат Куки;
	
КонецФункции // УстановитьСоединениеССайтом()

// Проверяет подключение к сайту по переданным параметрам доступа.
//
// Параметры:
//  АдресСайта - Строка - адрес сайта.
//  Логин - Строка - логин доступа к админской части сайта.
//  Пароль - Строка - пароль доступа к админской части сайта.
//  СведенияОбОшибке - Строка - сведения об ошибке.
//  ИспользоватьSSL- Булево - необходимо ли подключаться по https.
//  СтруктураИнформацииОСайте - Структура - информация о сайте.
//
// Возвращаемое значение:
//  Булево.
//
Функция ПроверитьПодключениеКСайту(АдресСайта, Логин, Пароль, СведенияОбОшибке = "", СтруктураИнформацииОСайте) Экспорт
	
	мHTTPСоединение = ПолучитьHTTPСоединение(АдресСайта, Логин, Пароль, СтруктураИнформацииОСайте.ИспользоватьSSL);
	
	Возврат ?(УстановитьСоединениеССайтом(мHTTPСоединение, Логин, Пароль,, СтруктураИнформацииОСайте) = Неопределено, Ложь, Истина);
	
КонецФункции // ПроверитьПодключениеКСайту()

// Получает максимально объем данных, который можно передать на сайт за 1 раз.
//
// Параметры:
//  мHTTPСоединение - объект, с помощью которого осуществляется соединение с сайтом.
//  АдресСайта - Строка - адрес сайта.
//  Логин - Строка - логин доступа к админской части сайта.
//  Пароль - Строка - пароль доступа к админской части сайта.
//  Куки - Структура - Cookie сайта.
//  СведенияОбОшибке - Строка - сведения об ошибке.
//
// Возвращаемое значение:
//  Число.
//
Функция ПолучитьРазрешенныйРазмерФайлаОбмена(мHTTPСоединение, Логин, Пароль, Куки, АдресМодуля, СведенияОбОшибке)
	
	Попытка
		ТекстЗапроса = СтрШаблон("%1?mode=init", АдресМодуля);
		Ответ        = ОтправитьGETЗапросНаСайт(мHTTPСоединение, Куки, ТекстЗапроса);
	Исключение
		СведенияОбОшибке = "Не удалось получить параметры загрузки данных на сайт: исключительная ошибка.";
		УПЖКХ_ТиповыеМетодыКлиентСервер.СообщитьОбОшибке(СведенияОбОшибке);
		Возврат 0;
	КонецПопытки;
	
	Если Лев(Ответ, 11) <> "file_limit=" Тогда
		ОшибкаОбмена     = ПолучитьОписаниеОшибкиОбмена(Ответ);
		СведенияОбОшибке = "Не удалось получить параметры загрузки данных на сайт" + ?(ПустаяСтрока(ОшибкаОбмена), ".", ": " + ОшибкаОбмена);
		УПЖКХ_ТиповыеМетодыКлиентСервер.СообщитьОбОшибке(СведенияОбОшибке);
		Возврат 0;
	КонецЕсли;
	
	Ответ = Сред(Ответ, 12, СтрДлина(Ответ) - 11);
	Попытка
		Возврат Число(Ответ);
	Исключение
		СведенияОбОшибке = "Не удалось получить параметры загрузки данных на сайт: некорректный ответ с сайта.";
		УПЖКХ_ТиповыеМетодыКлиентСервер.СообщитьОбОшибке(СведенияОбОшибке);
		Возврат 0;
	КонецПопытки;
	
КонецФункции // ПолучитьРазрешенныйРазмерФайлаОбмена()

// Выгружает файл с сайта.
//
// Параметры:
//  ТипДанных - Строка - идентификатор загружаемых данных.
//  НастройкаДоступа - текущая настройка доступа.
//  Пароль - Строка - пароль доступа к админской части сайта.
//  СведенияОбОшибке - Строка - сведения об ошибке.
//  СтруктураИнформацииОСайте - Структура - информация о сайте.
//
// Возвращаемое значение:
//  Строка, Неопределено.
//
Функция ЗагрузитьДанныеССайта(ТипДанных, НастройкаДоступа, Пароль, СведенияОбОшибке = "", СтруктураИнформацииОСайте) Экспорт
	
	АдресСайта = НастройкаДоступа.АдресСайта;
	Логин      = НастройкаДоступа.Логин;
	
	мHTTPСоединение = ПолучитьHTTPСоединение(АдресСайта, Логин, Пароль, СтруктураИнформацииОСайте.ИспользоватьSSL);
	
	Куки = УстановитьСоединениеССайтом(мHTTPСоединение, Логин, Пароль, СведенияОбОшибке, СтруктураИнформацииОСайте);
	
	Если Куки = Неопределено Тогда
		// Не удалось установить разрешенный для передачи на сайт размер данных.
		СведенияОбОшибке = "Неудачное соединение с сервером ЖКХ.";
		УПЖКХ_ТиповыеМетодыКлиентСервер.СообщитьОбОшибке(СведенияОбОшибке);
		
		Возврат СформироватьСтруктуруОтветаПоНаборуПараметров(,, СведенияОбОшибке);
	КонецЕсли;
	
	Ответ = ПолучитьФайлССайта(мHTTPСоединение, ТипДанных, Куки, Логин, Пароль, НастройкаДоступа, СведенияОбОшибке);
	
	Если ТипЗнч(Ответ) = Тип("Структура") Тогда
		Возврат Ответ;
	КонецЕсли;
	
	ИмяВременногоФайла = УПЖКХ_ВебИнтеграцияОбщегоНазначения.СформироватьТекстовыйФайл(Ответ);
	
	Возврат СформироватьСтруктуруОтветаПоНаборуПараметров("success", Новый Структура("temporary_file_name", ИмяВременногоФайла));
	
КонецФункции // ЗагрузитьДанныеССайта()

// Отправляет на сайт запрос на получение файла.
//
// Параметры:
//  мHTTPСоединение - объект, с помощью которого осуществляется соединение с сайтом.
//  ТипДанных - Строка - идентификатор передаваемых данных.
//  Куки - Структура - Cookie сайта.
//  АдресСайта - Строка - адрес сайта.
//  Логин - Строка - логин доступа к админской части сайта.
//  Пароль - Строка - пароль доступа к админской части сайта.
//  НастройкаДоступа - текущая настройка доступа.
//  СведенияОбОшибке - Строка - строка, содержащаясведения об ошибке.
//
// Возвращаемое значение:
//  Строка, Неопределено.
//
Функция ПолучитьФайлССайта(мHTTPСоединение, ТипДанных, Куки, Логин, Пароль, НастройкаДоступа, СведенияОбОшибке)
	
	Организация = НастройкаДоступа.Организация;
	
	Если ТипДанных = "meters" ИЛИ ТипДанных = "accexistence" Тогда
		
		ТекстЗапроса = СтрШаблон("bitrix/admin/tszh_exchange.php?mode=export&type=%1&inn=%2&kpp=%3&multipart=1", UrlEncode(ТипДанных), UrlEncode(Организация.ИНН), UrlEncode(Организация.КПП));
		
	ИначеЕсли ТипДанных = "payments" Тогда
		
		ДатаПоследнейЗагрузки = УПЖКХ_ВебИнтеграцияВзаимодействиеСБазойДанных.ПолучитьДатуПоследнейЗагрузкиРестраПлатежей(НастройкаДоступа);
		ТекстЗапроса          = СтрШаблон("bitrix/admin/tszh_exchange.php?mode=export&type=%1&inn=%2&kpp=%3&datebeg=%4&multipart=1", UrlEncode(ТипДанных), UrlEncode(Организация.ИНН), UrlEncode(Организация.КПП), UrlEncode(ДатаПоследнейЗагрузки));
		
	// Заявки АДС (временно закомментировано)
	//ИначеЕсли ТипДанных = "tickets" Тогда
	//	
	//	// Пока это будет здесь, возможно, будет перенос этого типа данных в одну из категорий выше.
	//	
	//	// Нужно ли, не ясно
	//	//Если ДатаПоследнейЗагрузки = Неопределено Тогда
	//	//	СведенияОбОшибке = "Не заданы параметры обмена: начальная дата";
	//	//	УПЖКХ_ТиповыеМетодыКлиентСервер.СообщитьОбОшибке(СведенияОбОшибке);
	//	//	
	//	//	Возврат Неопределено;
	//	//КонецЕсли;
	//	
	//	// Пока что без доп параметров, нужно уточнить
	//	ТекстЗапроса = "http://" + АдресСайта + "/bitrix/admin/tszh_exchange.php?mode=export&type=" +
	//				   UrlEncode(ТипДанных) + "&inn=" + UrlEncode(ИННОрганизации);
	//	
	Иначе
		СведенияОбОшибке = "Ошибка получения файла с сайта: неизвестный формат обмена.";
		УПЖКХ_ТиповыеМетодыКлиентСервер.СообщитьОбОшибке(СведенияОбОшибке);
		
		Возврат СформироватьСтруктуруОтветаПоНаборуПараметров(,, СведенияОбОшибке);
	КонецЕсли;
	
	// Выполняем отправку запросов пока не придет "success", "failure" или другая ошибка.
	ТекстФайлаОбмена  = "";
	ЗагрузкаЗавершена = Ложь;
	ПервыйЗапрос      = Истина;
	
	Пока НЕ ЗагрузкаЗавершена Цикл
		
		Ответ = ОтправитьGETЗапросНаСайт(мHTTPСоединение, Куки, ТекстЗапроса);
		
		// Если отправляем первый запрос, то проверяем необходимость загрузки файла по частям.
		Если ПервыйЗапрос Тогда
			
			ПервыйЗапрос = Ложь;
			
			Если СтрНайти(Ответ, "multipart=""1""") = 0 Тогда
				ЗагрузкаЗавершена = Истина;
			КонецЕсли;
		КонецЕсли;
		
		Если ЛЕВ(Ответ, 7) = "failure" ИЛИ ПустаяСтрока(Ответ) Тогда
			ОшибкаОбмена = ПолучитьОписаниеОшибкиОбмена(Ответ);
			СведенияОбОшибке = "Ошибка получения файла с сайта" + ?(ПустаяСтрока(ОшибкаОбмена), ".", ": " + ОшибкаОбмена);
			УПЖКХ_ТиповыеМетодыКлиентСервер.СообщитьОбОшибке(СведенияОбОшибке);
			
			Возврат СформироватьСтруктуруОтветаПоНаборуПараметров(,, Ответ);
			
		ИначеЕсли ЛЕВ(Ответ, 7) = "success" Тогда
			
			ЗагрузкаЗавершена = Истина;
			
		Иначе
			
			ТекстФайлаОбмена = ТекстФайлаОбмена + Ответ;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат ТекстФайлаОбмена;
	
КонецФункции // ПолучитьФайлССайта()

// Формирует ссылку на необходимую страницу сайта.
//
// Параметры:
//  РедактироватьНовости - Булево - признак того, что требуется открыть страницу редактирования новостей.
//  АдресСайта - Строка - адрес сайта.
//  Логин - Строка - логин доступа к админской части сайта.
//  Пароль - Строка - пароль доступа к админской части сайта.
//
// Возвращаемое значение:
//  Строка.
//
Функция ПолучитьАдресСтраницы(РедактироватьНовости, АдресСайта, Логин, Пароль) Экспорт
	
	Возврат "http://" + ЗакодироватьАдресСайта(АдресСайта) + ?(РедактироватьНовости, "/bitrix/tools/citrus_tszh_1c_auth.php?login=" +
												  UrlEncode(Логин) + "&password=" + UrlEncode(Пароль), "");
	
КонецФункции // ПолучитьАдресСтраницы()

#КонецОбласти

////////////////////////////////////////////////////////////////////////////////
// ФУНКЦИИ ОБРАБОТКИ ПОЛУЧЕННЫХ С САЙТА ОТВЕТОВ

#Область ФункцииОбработкиПолученныхССайтаОтветов

// Формирует структуру с детальным описанием ответа с сайта при выгрузке данных на сайт.
//
Функция ПолучитьСтруктуруОтветаНаЗапросЭкпортаФайла(Ответ, СтруктураИнформацииОСайте)
	
	СтруктураОтвета = СформироватьСтруктуруОтветаПоНаборуПараметров();
	
	Если СтруктураИнформацииОСайте.НомерБилда = 1 Тогда
		
		// 1-й билд (старая версия).
		
		ОшибкаДляВыводаПользователю = "";
		
		Если Лев(Ответ, 7) = "success" Тогда
			СтруктураОтвета.status = "success";
		ИначеЕсли Лев(Ответ, 8) = "progress" Тогда
			СтруктураОтвета.status = "progress";
			СтруктураОтвета.details.Вставить("progress_status", Прав(Ответ, СтрДлина(Ответ) - 8));
		ИначеЕсли Лев(Ответ, 7) = "warning" Тогда
			СтруктураОтвета.status = "warning";
			СтруктураОтвета.error = Прав(Ответ, СтрДлина(Ответ) - 7);
			
			ОшибкаДляВыводаПользователю = ПолучитьОписаниеОшибкиОбмена(Ответ);
			
		ИначеЕсли Лев(Ответ, 7) = "failure" Тогда
			СтруктураОтвета.error = Прав(Ответ, СтрДлина(Ответ) - 7);
			
			ОшибкаДляВыводаПользователю = ПолучитьОписаниеОшибкиОбмена(Ответ);
			
		Иначе
			ОшибкаОбмена = ПолучитьОписаниеОшибкиОбмена(Ответ);
			СведенияОбОшибке = "Не удалось загрузить файл на сайт" + ?(ПустаяСтрока(ОшибкаОбмена), ".", ": " + ОшибкаОбмена);
			
			СтруктураОтвета.error = СведенияОбОшибке;
		КонецЕсли;
		
		Если НЕ ПустаяСтрока(ОшибкаДляВыводаПользователю) Тогда
			УПЖКХ_ТиповыеМетодыКлиентСервер.СообщитьОбОшибке(ОшибкаДляВыводаПользователю);
		КонецЕсли;
		
	ИначеЕсли СтруктураИнформацииОСайте.НомерБилда > 1 Тогда
		
		// Во 2-м билде ответ представляет собой объект json со следующей структурой:
		// {“status”:<статус процесса>,
		//“details”: {
		//	“progress_status”: <статус прогресса>
		//	“houses”: <все дома загружены>,
		//	“houses_additional”: <доп.информация по зданиям загружена>,
		//	“houses_with_warnings”: [
		// <массив домов с ошибками>],
		//	“accs”: <все л/с загружены>,
		//	“accs_with_warnings”: [
		// <массив л/с с ошибками>]
		//	…
		//	тут можно добавить доп. информацию, например, сколько л/с загрузилось, или произошла 
		// },
		// “error”:<сведения об ошибке>}
		
		СтруктураОтветаВременная = ПолучитьСтруктуруОбъектаJSON(Ответ);
		
		Если ТипЗнч(СтруктураОтветаВременная) = Тип("Структура") И СтруктураОтветаВременная.Свойство("status") Тогда
			
			СтруктураОтвета.status = СтруктураОтветаВременная.status;
			
			Если СтруктураОтветаВременная.Свойство("details") И ТипЗнч(СтруктураОтветаВременная.details) = Тип("Структура") Тогда
				СтруктураОтвета.details = СтруктураОтветаВременная.details;
			КонецЕсли;
			
			Если СтруктураОтветаВременная.Свойство("error") Тогда
				СтруктураОтвета.error = СтруктураОтветаВременная.error;
			КонецЕсли;
			
		Иначе
			
			ОшибкаОбмена = ПолучитьОписаниеОшибкиОбмена(Ответ);
			СведенияОбОшибке = "Не удалось загрузить файл на сайт" + ?(ПустаяСтрока(ОшибкаОбмена), ".", ": " + ОшибкаОбмена);
			
			СтруктураОтвета.error = СведенияОбОшибке;
			
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат СтруктураОтвета;
	
КонецФункции

// Подготавливает новую структуру ответа с сайта.
//
Функция СформироватьСтруктуруОтветаПоНаборуПараметров(Статус = "failure", СтруктураДопИнформации = Неопределено, ТекстОшибки = "")
	
	Если НЕ ТипЗнч(СтруктураДопИнформации) = Тип("Структура") Тогда
		СтруктураДопИнформации = Новый Структура;
	КонецЕсли;
	
	Возврат Новый Структура("status, details, error", Статус, СтруктураДопИнформации, ТекстОшибки);
	
КонецФункции

// Формирует структуру с данными на основании объекта JSON.
//
Функция ПолучитьСтруктуруОбъектаJSON(ТекстОбъекта) Экспорт
	
	Попытка
		
		ЧтениеJSON = Новый ЧтениеJSON;
		ЧтениеJSON.УстановитьСтроку(ТекстОбъекта);
		
		СтруктураОбъектаJSON = ПрочитатьJSON(ЧтениеJSON);
		
		ЧтениеJSON.Закрыть();
		
	Исключение
		
		Возврат ТекстОбъекта;
		
	КонецПопытки;
	
	Возврат СтруктураОбъектаJSON;
	
КонецФункции

#КонецОбласти

////////////////////////////////////////////////////////////////////////////////
// ФУНКЦИИ ПОЛУЧЕНИЯ ИНФОРМАЦИИ О САЙТЕ

#Область ФункцииПолученияИнформацииОСайте

// Подготавливает структуру с информацией о сайте.
//
Функция ПолучитьИнформациюОСайте(НастройкаДоступа, ПовторноеПодключение = Ложь) Экспорт
	
	Если ПовторноеПодключение Тогда
		ИспользоватьSSL = НЕ НастройкаДоступа.ИспользоватьSSL;
	Иначе
		ИспользоватьSSL = НастройкаДоступа.ИспользоватьSSL;
	КонецЕсли;
		
	мHTTPСоединение = ПолучитьHTTPСоединение(НастройкаДоступа.АдресСайта, НастройкаДоступа.Логин, 
											 "", ИспользоватьSSL);
	
	Попытка
		Ответ = ОтправитьGETЗапрос(мHTTPСоединение,, "/bitrix/admin/tszh_exchange.php?mode=version");
	Исключение
		Ответ = "";
	КонецПопытки;
	
	СтруктураОтвета = ОбработатьОтветСИнформациейОСайте(Ответ, ИспользоватьSSL);
	
	// Если ответ пришел, но нам он не подходит, проверяем,
	// возможно необходимо попытаться подключиться
	// с использованием/без использования SSL.
	Если НЕ ПовторноеПодключение И (НЕ СтруктураОтвета.ЗапросВыполненУспешно ИЛИ СтруктураОтвета.ВерсияФорматаОбмена < 4) Тогда
		
		Возврат ПолучитьИнформациюОСайте(НастройкаДоступа, Истина);
		
	// Если повторный запрос выполнен успешно, то вносим изменения
	// в реквизит "ИспользоватьSSL" элемента справочника "Настройки доступа".
	ИначеЕсли СтруктураОтвета.ЗапросВыполненУспешно И ПовторноеПодключение Тогда
		
		Попытка
			ЭлементНастройкаДоступа = НастройкаДоступа.ПолучитьОбъект();
			ЭлементНастройкаДоступа.ИспользоватьSSL = ИспользоватьSSL;
			ЭлементНастройкаДоступа.Записать();
		Исключение
		КонецПопытки;
		
	// Не удалось подключиться совсем.
	ИначеЕсли НЕ СтруктураОтвета.ЗапросВыполненУспешно И ПовторноеПодключение Тогда
		
		Если Ответ = "" Тогда
			СведенияОбОшибке = "Неудачная авторизация: исключительная ошибка.";
		Иначе
			СведенияОбОшибке = "Не удалось получить версию формата обмена с сайтом.";
		КонецЕсли;
		
		УПЖКХ_ТиповыеМетодыКлиентСервер.СообщитьОбОшибке(СведенияОбОшибке);
		
	// Если имел место редирект (301, 302), связанный с использованием SSL, то отразим это в настройке доступа.
	ИначеЕсли СтруктураОтвета.ЗапросВыполненУспешно И НЕ ПовторноеПодключение Тогда
		
		ИспользоватьSSL = НЕ мHTTPСоединение.ЗащищенноеСоединение = Неопределено;
		
		Если НЕ НастройкаДоступа.ИспользоватьSSL = ИспользоватьSSL Тогда
			Попытка
				ЭлементНастройкаДоступа = НастройкаДоступа.ПолучитьОбъект();
				ЭлементНастройкаДоступа.ИспользоватьSSL = ИспользоватьSSL;
				ЭлементНастройкаДоступа.Записать();
			Исключение
			КонецПопытки;
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат СтруктураОтвета;
	
КонецФункции

// Обрабатывает ответ с информаией о сайте.
//
Функция ОбработатьОтветСИнформациейОСайте(ОтветССайта, ИспользоватьSSL)
	
	// Разбираем ответ с сайта, который должен иметь следующий вид:
	// {статус выполнения}
	// version={номер версии}
	// build={номер билда}
	// modules={модуль1,модуль2,модуль3,...}
	//
	// Пример:
	// success
	// version=4
	// build=2
	// modules=модуль1,модуль2,модуль3
	
	// Инициализация структуры.
	СтруктураОтвета = Новый Структура("ЗапросВыполненУспешно, ВерсияФорматаОбмена, НомерБилдаНаСайте, НомерБилдаВПрограмме, НомерБилда, МассивУстановленныхНаСайтеМодулей, СписокМодулейСтрокой, ИспользоватьSSL", Ложь, 0, 1, 1, 1, Новый Массив, "", ИспользоватьSSL);
	
	СтруктураОтвета.НомерБилдаВПрограмме = ПолучитьНомерБилдаФорматаОбменаВКонфигурации();
	
	Если ТипЗнч(ОтветССайта) = Тип("Строка") Тогда
		
		Если Лев(ОтветССайта, 7) = "success" Тогда
			
			СтруктураОтвета.ЗапросВыполненУспешно = Истина;
			
			ВерсияОбмена  = ПолучитьЗначениеПараметраИзОтветаСИнформациейОСайте(ОтветССайта, "version");
			Билд          = ПолучитьЗначениеПараметраИзОтветаСИнформациейОСайте(ОтветССайта, "build");
			СписокМодулей = ПолучитьЗначениеПараметраИзОтветаСИнформациейОСайте(ОтветССайта, "modules");
			
			Если НЕ ПустаяСтрока(ВерсияОбмена) Тогда
				Попытка
					СтруктураОтвета.ВерсияФорматаОбмена = Число(ВерсияОбмена);
				Исключение
				КонецПопытки;
			КонецЕсли;
			
			Если НЕ ПустаяСтрока(Билд) Тогда
				Попытка
					СтруктураОтвета.НомерБилдаНаСайте = Число(Билд);
				Исключение
				КонецПопытки;
			КонецЕсли;
			
			Если НЕ ПустаяСтрока(СписокМодулей) Тогда
				Попытка
					СтруктураОтвета.СписокМодулейСтрокой              = СписокМодулей;
					СтруктураОтвета.МассивУстановленныхНаСайтеМодулей = СтрРазделить(СписокМодулей,",", Ложь);
				Исключение
				КонецПопытки;
			КонецЕсли;
			
			СтруктураОтвета.НомерБилда = Мин(СтруктураОтвета.НомерБилдаВПрограмме, СтруктураОтвета.НомерБилдаНаСайте);
			
		ИначеЕсли Лев(ОтветССайта, 7) = "failure" Тогда
			
			СтруктураОтвета.ЗапросВыполненУспешно = Истина;
			СтруктураОтвета.ВерсияФорматаОбмена   = 3;
			
		КонецЕсли;
	КонецЕсли;
	
	Возврат СтруктураОтвета;
	
КонецФункции

// Возвращает значение параметра из ответа с информацией о сайте.
//
Функция ПолучитьЗначениеПараметраИзОтветаСИнформациейОСайте(ОтветССайта, НаименованиеПараметра)
	
	ЗначениеПараметра = "";
	
	ПозицияНачалаПараметра = СтрНайти(ОтветССайта, НаименованиеПараметра);
	
	Если НЕ ПозицияНачалаПараметра = 0 Тогда
		
		ДлинаНазванияПараметра         = СтрДлина(НаименованиеПараметра);
		ПозицияНачалаЗначенияПараметра = ПозицияНачалаПараметра + ДлинаНазванияПараметра + 1; // Добавляем 1, так как после наименования параметра идет знак "=".
		ПозицияРазделителя             = СтрНайти(ОтветССайта, Символы.ПС, , ПозицияНачалаЗначенияПараметра);
		
		ЗначениеПараметра = СокрЛП(?(ПозицияРазделителя = 0, Прав(ОтветССайта, СтрДлина(ОтветССайта) - ПозицияНачалаЗначенияПараметра + 1), Сред(ОтветССайта, ПозицияНачалаЗначенияПараметра, ПозицияРазделителя - ПозицияНачалаЗначенияПараметра)));
		
	КонецЕсли;
	
	Возврат ЗначениеПараметра;
	
КонецФункции

// Возвращает номер актуального билда формата обмена.
//
Функция ПолучитьНомерБилдаФорматаОбменаВКонфигурации() Экспорт
	
	// Текущий билд - 4-й.
	Возврат 4;
	
КонецФункции

// Возвращает наименование модуля электронных паспортов домов.
//
Функция ПолучитьНаименованиеМодуляЭПДНаСайте() Экспорт
	
	Возврат "vdgb.tszhepasport";
	
КонецФункции

// Возвращает наименование модуля оплат.
//
Функция ПолучитьНаименованиеМодуляОплатНаСайте() Экспорт
	
	Возврат "citrus.tszhpayment";
	
КонецФункции

#КонецОбласти

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ОБЩЕГО НАЗНАЧЕНИЯ

#Область ПроцедурыИФункцииОбщегоНазначения

// Возвращает адрес сайта в виде punycode.
//
Функция ЗакодироватьАдресСайта(Знач АдресСайта)
	
	Если ПроверитьНеобходимостьКодированияАдресаСайта(АдресСайта) Тогда
		
		АдресСайта = АдресСайта + ".";
		ЗакодированныйАдресСайта = "";
		
		// Массив доменов URL сайта
		МассивДоменов = Новый Массив;
		
		// Разбиваем адрес на субдомены.
		ПозицияРазделителя = Найти(АдресСайта, ".");
		
		Пока НЕ ПозицияРазделителя = 0 Цикл
			МассивДоменов.Добавить(Лев(АдресСайта, ПозицияРазделителя - 1));
			
			АдресСайта         = Прав(АдресСайта, СтрДлина(АдресСайта) - ПозицияРазделителя);
			ПозицияРазделителя = Найти(АдресСайта, ".");
		КонецЦикла;
		
		// Кодируем каждый субдомен по отдельности и добавляем к итоговой строке адреса.
		Если НЕ МассивДоменов.Количество() = 0 Тогда
			
			// Формируем итоговую строку адреса.
			Для каждого ТекДомен из МассивДоменов Цикл
				ЗакодированныйАдресСайта = ЗакодированныйАдресСайта + ЗакодироватьДомен(ТекДомен) + ".";
			КонецЦикла;
			
			// Удаляем точку из строки.
			ДлинаИтоговойСтроки = СтрДлина(ЗакодированныйАдресСайта);
			
			Если НЕ ДлинаИтоговойСтроки = 0 Тогда
				ЗакодированныйАдресСайта = Лев(ЗакодированныйАдресСайта, ДлинаИтоговойСтроки - 1);
			КонецЕсли;
			
		КонецЕсли;
		
		Возврат ЗакодированныйАдресСайта;
		
	Иначе
		Возврат АдресСайта;
	КонецЕсли;
	
КонецФункции

// Проверяет необходимость кодирования адреса сайта в punycode.
//
Функция ПроверитьНеобходимостьКодированияАдресаСайта(АдресСайта)
	
	Для ТекСимвол = 1 по СтрДлина(АдресСайта) Цикл
		Код = КодСимвола(АдресСайта, ТекСимвол);
		
		// Если код символа не входит в ASCII, то необходимо кодировать адрес.
		Если Код > 127 Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	
	// Не требует кодирования.
	Возврат Ложь;
	
КонецФункции

// Возвращает домен в виде punycode по стандарту RFC 3492.
//
Функция ЗакодироватьДомен(Домен)
	
	// Массив кодов символов домена
	МассивКодовСимволовДомена = Новый Массив;
	
	// Переменные
	КоличествоЗакодированныхСимволов = 0;
	ДлинаДомена         = СтрДлина(Домен);
	ЭтоПервый           = Истина;
	ПрефиксASCII        = "xn--";
	ЧастьДоменаASCII    = "";
	ЧастьДоменаНеASCII  = "";
	ЗакодированныйДомен = "";
	Домен               = НРег(Домен);
	
	// Стандартный переменные и константы алгоритма RFC 3492
	cur_code = 128;
	delta    = 0;
	base     = 36;
	tmin     = 1;
	tmax     = 26;
	skew     = 38;
	damp     = 700;
	bias     = 72;
	qDelta   = 0;
	kBase    = 0;
	diff     = 0;
	
	// Формирование ASCII части домена
	Для ТекСимвол = 1 по СтрДлина(Домен) Цикл
		Код = КодСимвола(Домен, ТекСимвол);
		МассивКодовСимволовДомена.Добавить(Код);
		
		Если Код < cur_code Тогда
			КоличествоЗакодированныхСимволов = КоличествоЗакодированныхСимволов + 1;
			ЧастьДоменаASCII                 = ЧастьДоменаASCII + Символ(Код);
		КонецЕсли;
	КонецЦикла;
	
	// Проверка необходимости кодирования
	ДлинаЧастиASCII = СтрДлина(ЧастьДоменаASCII);
	
	Если ДлинаЧастиASCII = ДлинаДомена Тогда
		// Не требует кодирования
		Возврат ЧастьДоменаASCII;
	Иначе
		// Требуется кодирование
		
		// Формируем часть ASCII
		ЧастьДоменаASCII = ПрефиксASCII + ЧастьДоменаASCII + ?(ДлинаЧастиASCII = 0, "", "-");
		
		// Получаем UTF часть (кодируем UTF часть в ASCII)
		Пока КоличествоЗакодированныхСимволов < ДлинаДомена Цикл
			
			Для НомерСимвола = 0 по ДлинаДомена - 1 Цикл
				
				Если МассивКодовСимволовДомена[НомерСимвола] < cur_code Тогда
					
					delta = delta + 1;
					
				ИначеЕсли МассивКодовСимволовДомена[НомерСимвола] = cur_code Тогда
					
					// Стандартные переменные алгоритма
					qDelta = delta;
					kBase  = base;
					diff   = 0;
					
					Пока Истина Цикл
						Если kBase <= bias Тогда
							diff = tmin;
						ИначеЕсли kBase >= bias + tmax Тогда
							diff = tmax;
						Иначе
							diff = kBase - bias;
						КонецЕсли;
						
						Если qDelta < diff Тогда
							ЧастьДоменаНеASCII = ЧастьДоменаНеASCII + Символ(qDelta + 22 + 75 * (?(qDelta < tmax, 1, 0)));
							Прервать;
						Иначе
							Модификатор = Цел(diff + ((qDelta - diff) % (base - diff)));
							ЧастьДоменаНеASCII = ЧастьДоменаНеASCII + Символ(Модификатор + 22 + 75 * (?(Модификатор < tmax, 1, 0)));
							qDelta = Цел((qDelta - diff) / (base - diff));
						КонецЕсли;
						
						kBase = kBase + base;
					КонецЦикла;
					
					КоличествоЗакодированныхСимволов = КоличествоЗакодированныхСимволов + 1;
					
					Если ЭтоПервый Тогда
						delta = Цел(delta / damp);
					Иначе
						delta = Цел(delta / 2);
					КонецЕсли;
					
					delta     = delta + Цел(delta / КоличествоЗакодированныхСимволов);
					bias      = Цел(base * delta / (delta + skew));
					delta     = 0;
					ЭтоПервый = Ложь;
					
				КонецЕсли;
			КонецЦикла;
			
			delta    = delta + 1;
			cur_code = cur_code + 1;
			
		КонецЦикла;
		
		// Формирование итоговой строки домена.
		ЗакодированныйДомен = ЧастьДоменаASCII + ЧастьДоменаНеASCII;
		
		Возврат ЗакодированныйДомен;
		
	КонецЕсли;
	
КонецФункции

// Возвращает строку urlencoded.
//
// Параметры:
//  стр - Строка - строка, которую требуется закодировать.
//
// Возвращаемое значение:
//  Строка.
//
Функция UrlEncode(стр)
	
	HEX = Новый Массив();
	Для сч = 48 По 57 Цикл 
		HEX.Добавить(Символ(сч));
	КонецЦикла;
	
	Для сч = 65 По 70 Цикл 
		HEX.Добавить(Символ(сч));
	КонецЦикла;
	
	рез="";
	Для сч = 1 По СтрДлина(стр) Цикл
		чар = Сред(стр, сч, 1);
		Если (чар >= "a") И (чар <= "z") Тогда рез = рез + чар; Продолжить; КонецЕсли;
		Если (чар >= "A") И (чар <= "Z") Тогда рез = рез + чар; Продолжить; КонецЕсли;
		Если (чар >= "0") И (чар <= "9") Тогда рез = рез + чар; Продолжить; КонецЕсли;
		Если чар = "-" Тогда рез = рез + чар; Продолжить; КонецЕсли;
		Если чар = "_" Тогда рез = рез + чар; Продолжить; КонецЕсли;
		Если чар = "=" Тогда рез = рез + чар; Продолжить; КонецЕсли;
		Если чар = "&" Тогда рез = рез + чар; Продолжить; КонецЕсли;
		Если чар = "." Тогда рез = рез + чар; Продолжить; КонецЕсли;
		Если чар = "!" Тогда рез = рез + чар; Продолжить; КонецЕсли;
		//Если чар = "#" Тогда рез = рез + %23; Продолжить; КонецЕсли;
		кс = КодСимволаASCII(чар);
		рез = рез+ "%" + HEX[Цел(кс/16)] + HEX[Цел(кс % 16)];
	КонецЦикла;
	
	Возврат рез;
	
КонецФункции // UrlEncode()

// Возвращает код символа в ASCII.
//
// Параметры:
//  Символ - Строка - симовол, код которого необходимо получить.
//
// Возвращаемое значение:
//  Число.
//
Функция КодСимволаASCII(Символ)
	
	КодUNICODE = КодСимвола(Символ);
	
	Если ((КодUNICODE > 1039) И (КодUNICODE < 1104)) Тогда
		Возврат (КодUNICODE - 848);
	ИначеЕсли КодUNICODE = 8470 Тогда
		Возврат 185;
	ИначеЕсли КодUNICODE = 1105 Тогда
		Возврат 184;
	ИначеЕсли КодUNICODE = 1025 Тогда
		Возврат 168;
	Иначе
		Возврат КодUNICODE;
	КонецЕсли;
	
КонецФункции // КодСимволаASCII()

// Записывает данные во временный XML файл и возвращает имя сформированного файла.
//
// Параметры:
//  СтруктураВыгрузки - Структура - содержит выгружаемые данные.
//  НастройкаДоступа - текущая настройка доступа.
//  ОбновлятьПараметрыДоступа - булево - обновлять ли параметры доступа на сайте.
//
// Возвращаемое значение:
//  Строка - имя файла выгрузки.
//
Функция СформироватьФайлXML(СтруктураВыгрузки, НастройкаДоступа, ОбновлятьПараметрыДоступа = Ложь) Экспорт
	
	Если НЕ ЗначениеЗаполнено(СтруктураВыгрузки) ИЛИ НЕ ТипЗнч(СтруктураВыгрузки) = Тип("Структура") Тогда
		// Если неопределенное значение.
		Возврат Неопределено;
	КонецЕсли;
	
	// Попытка на случай если передали что-то совсем неправильное
	Попытка
		Если СтруктураВыгрузки.filetype = "access" Тогда
			ВыгружатьВсеДанные = Ложь;
		ИначеЕсли СтруктураВыгрузки.filetype = "calculations"
			  ИЛИ СтруктураВыгрузки.filetype = "accounts" Тогда
			ВыгружатьВсеДанные = Истина;
		Иначе
			// Неверные данные
			Возврат Неопределено;
		КонецЕсли;
	Исключение
		// Неверные данные
		Возврат Неопределено;
	КонецПопытки;
	
	// Получаем имя временного файла.
	ИмяВременногоФайла = ПолучитьИмяВременногоФайла("xml");
	
	// Выгружать ли персональные данные
	ВыгружатьПерсональныеДанные = НЕ НастройкаДоступа.НеВыгружатьПерсональныеДанные;
	
	// Создаем XML файл.
	ЗаписьXML = Новый ЗаписьXML;
	ЗаписьXML.ОткрытьФайл(ИмяВременногоФайла, "windows-1251");
	
	// Записываем сведения об организации в элемент "ORG".
	ДокументDOM = Новый ДокументDOM("", "ORG");
	КорневойЭлемент = ДокументDOM.ЭлементДокумента;
	
	// Общие данные организации
	КорневойЭлемент.УстановитьАтрибут("filedate", СтруктураВыгрузки.filedate);
	КорневойЭлемент.УстановитьАтрибут("name",     СтруктураВыгрузки.name);
	КорневойЭлемент.УстановитьАтрибут("inn",      СтруктураВыгрузки.inn);
	КорневойЭлемент.УстановитьАтрибут("filetype", СтруктураВыгрузки.filetype);
	КорневойЭлемент.УстановитьАтрибут("version",  СтруктураВыгрузки.version);
	КорневойЭлемент.УстановитьАтрибут("strict",   "1");
	
	// Выгрузка в файл
	Если ВыгружатьВсеДанные Тогда
		
		// Банковский счет организации
		КорневойЭлемент.УстановитьАтрибут("kpp",  СтруктураВыгрузки.kpp);
		КорневойЭлемент.УстановитьАтрибут("bank", СтруктураВыгрузки.bank);
		КорневойЭлемент.УстановитьАтрибут("rs",   СтруктураВыгрузки.rs);
		КорневойЭлемент.УстановитьАтрибут("ks",   СтруктураВыгрузки.ks);
		КорневойЭлемент.УстановитьАтрибут("bik",  СтруктураВыгрузки.bik);
		
		// Поставщики
		Если ЗначениеЗаполнено(СтруктураВыгрузки.contractors)
		   И НЕ СтруктураВыгрузки.contractors.Количество() = 0 Тогда
			
			ГруппаПоставщики = ДокументDOM.СоздатьЭлемент("contractors");
			КорневойЭлемент.ДобавитьДочерний(ГруппаПоставщики);
			
			Для каждого ТекСтрока из СтруктураВыгрузки.contractors Цикл
				
				ТекПоставщик = ДокументDOM.СоздатьЭлемент("contractor");
				ГруппаПоставщики.ДобавитьДочерний(ТекПоставщик);
				
				// Общие обязательные атрибуты
				ТекПоставщик.УстановитьАтрибут("id",   ТекСтрока.id);
				ТекПоставщик.УстановитьАтрибут("name", ТекСтрока.name);
				ТекПоставщик.УстановитьАтрибут("inn",  ТекСтрока.inn);
				ТекПоставщик.УстановитьАтрибут("kpp",  ТекСтрока.kpp);
				
				Если ЗначениеЗаполнено(ТекСтрока.address) Тогда
					ТекПоставщик.УстановитьАтрибут("address", ТекСтрока.address);
				КонецЕсли;
				
				Если ЗначениеЗаполнено(ТекСтрока.phone) Тогда
					ТекПоставщик.УстановитьАтрибут("phone", ТекСтрока.phone);
				КонецЕсли;
				
				// Атрибуты исполнителя расчетов
				Если НЕ ТекСтрока.executor = "" Тогда
					ТекПоставщик.УстановитьАтрибут("executor", ТекСтрока.executor);
				КонецЕсли;
				
				// Общие дополнительные атрибуты
				Если НЕ ТекСтрока.services = "" Тогда
					ТекПоставщик.УстановитьАтрибут("services", ТекСтрока.services);
				КонецЕсли;
				
				// Платежные реквизиты
				ТекПоставщик.УстановитьАтрибут("rs",   ТекСтрока.rs);
				ТекПоставщик.УстановитьАтрибут("bank", ТекСтрока.bank);
				ТекПоставщик.УстановитьАтрибут("ks",   ТекСтрока.ks);
				ТекПоставщик.УстановитьАтрибут("bik",  ТекСтрока.bik);
				
				Если ЗначениеЗаполнено(ТекСтрока.textValue) Тогда
					ТекПоставщик.ТекстовоеСодержимое = ТекСтрока.textValue;
				КонецЕсли;
				
			КонецЦикла;
		КонецЕсли;
		
		// ОПУ
		Если ЗначениеЗаполнено(СтруктураВыгрузки.hmeters)
		   И НЕ СтруктураВыгрузки.hmeters.Количество() = 0 Тогда
			
			ГруппаОПУ = ДокументDOM.СоздатьЭлемент("hmeters");
			КорневойЭлемент.ДобавитьДочерний(ГруппаОПУ);
			
			Для каждого ТекСтрока из СтруктураВыгрузки.hmeters Цикл
				
				ТекОПУ = ДокументDOM.СоздатьЭлемент("hmeter");
				ГруппаОПУ.ДобавитьДочерний(ТекОПУ);
				
				ТекОПУ.УстановитьАтрибут("value_count", ТекСтрока.value_count);
				ТекОПУ.УстановитьАтрибут("kod",         ТекСтрока.kod);
				ТекОПУ.УстановитьАтрибут("name",        ТекСтрока.name);
				ТекОПУ.УстановитьАтрибут("num",         ТекСтрока.num);
				ТекОПУ.УстановитьАтрибут("service",     ТекСтрока.service);
				ТекОПУ.УстановитьАтрибут("indiccur1",   ТекСтрока.indiccur1);
				
				Если ТекСтрока.value_count = "2" Тогда
					ТекОПУ.УстановитьАтрибут("indiccur2", ТекСтрока.indiccur2);
				ИначеЕсли ТекСтрока.value_count = "3" Тогда
					ТекОПУ.УстановитьАтрибут("indiccur2", ТекСтрока.indiccur2);
					ТекОПУ.УстановитьАтрибут("indiccur3", ТекСтрока.indiccur3);
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
		
		// Лицевые счета
		Если ЗначениеЗаполнено(СтруктураВыгрузки.PersAcc) Тогда
			Для каждого ТекСтрокаЛС из СтруктураВыгрузки.PersAcc Цикл
				
				ТекЛС = ДокументDOM.СоздатьЭлемент("PersAcc");
				КорневойЭлемент.ДобавитьДочерний(ТекЛС);
				
				Если ВыгружатьПерсональныеДанные Тогда
					ТекЛС.УстановитьАтрибут("AddressCity",       ТекСтрокаЛС.AddressCity);
					ТекЛС.УстановитьАтрибут("AddressDistrict",   ТекСтрокаЛС.AddressDistrict);
					ТекЛС.УстановитьАтрибут("AddressFlat",       ТекСтрокаЛС.AddressFlat);
					ТекЛС.УстановитьАтрибут("FlatAbbr",          ТекСтрокаЛС.FlatAbbr);
					ТекЛС.УстановитьАтрибут("AddressHouse",      ТекСтрокаЛС.AddressHouse);
					ТекЛС.УстановитьАтрибут("AddressRegion",     ТекСтрокаЛС.AddressRegion);
					ТекЛС.УстановитьАтрибут("AddressSettlement", ТекСтрокаЛС.AddressSettlement);
					ТекЛС.УстановитьАтрибут("AddressStreet",     ТекСтрокаЛС.AddressStreet);
					ТекЛС.УстановитьАтрибут("name",              ТекСтрокаЛС.name);
				КонецЕсли;
				
				ТекЛС.УстановитьАтрибут("email",           ТекСтрокаЛС.email);
				ТекЛС.УстановитьАтрибут("name_ls",         ТекСтрокаЛС.name_ls);
				ТекЛС.УстановитьАтрибут("people",          ТекСтрокаЛС.people);
				ТекЛС.УстановитьАтрибут("num_of_reg",      ТекСтрокаЛС.num_of_reg);
				ТекЛС.УстановитьАтрибут("num_of_comp",     ТекСтрокаЛС.num_of_comp);
				ТекЛС.УстановитьАтрибут("FlatType",        ТекСтрокаЛС.FlatType);
				ТекЛС.УстановитьАтрибут("HouseArea",       ТекСтрокаЛС.HouseArea);
				ТекЛС.УстановитьАтрибут("FlatsArea",       ТекСтрокаЛС.FlatsArea);
				ТекЛС.УстановитьАтрибут("ComFlatsArea",    ТекСтрокаЛС.ComFlatsArea);
				ТекЛС.УстановитьАтрибут("commonarea",      ТекСтрокаЛС.commonarea);
				ТекЛС.УстановитьАтрибут("habarea",         ТекСтрокаЛС.habarea);
				ТекЛС.УстановитьАтрибут("Barcode",         ТекСтрокаЛС.Barcode.ТекстШтрихкода);
				ТекЛС.УстановитьАтрибут("kod_ls",          ТекСтрокаЛС.kod_ls);
				ТекЛС.УстановитьАтрибут("kod_ls_new",      ТекСтрокаЛС.kod_ls_new);
				ТекЛС.УстановитьАтрибут("login",           ТекСтрокаЛС.login);
				ТекЛС.УстановитьАтрибут("password",        ТекСтрокаЛС.password);
				ТекЛС.УстановитьАтрибут("debtbeg",         ТекСтрокаЛС.debtbeg);
				ТекЛС.УстановитьАтрибут("debtend",         ТекСтрокаЛС.debtend);
				ТекЛС.УстановитьАтрибут("debtprev",        ТекСтрокаЛС.debtprev);
				ТекЛС.УстановитьАтрибут("prepayment",      ТекСтрокаЛС.prepayment);
				ТекЛС.УстановитьАтрибут("sumtopay",        ТекСтрокаЛС.sumtopay);
				ТекЛС.УстановитьАтрибут("lastPaymentDate", ТекСтрокаЛС.lastPaymentDate);
				ТекЛС.УстановитьАтрибут("creditPayed",     ТекСтрокаЛС.creditPayed);
				
				// Штрихкод
				ТегШтрихкода = ДокументDOM.СоздатьЭлемент("barcode");
				ТекЛС.ДобавитьДочерний(ТегШтрихкода);
				ТегШтрихкода.УстановитьАтрибут("type", ТекСтрокаЛС.Barcode.ВидШтрихкода);
				ТегШтрихкода.ТекстовоеСодержимое = ТекСтрокаЛС.Barcode.ТекстШтрихкода;
				
				// Начисления
				Если ЗначениеЗаполнено(ТекСтрокаЛС.item) Тогда
					Для каждого ТекСтрокаНачисления из ТекСтрокаЛС.item Цикл
						
						ТекНачисление = ДокументDOM.СоздатьЭлемент("item");
						ТекЛС.ДобавитьДочерний(ТекНачисление);
						
						// Является ли строкой детализации
						Если НЕ ТекСтрокаНачисления.component = "" Тогда
							ТекНачисление.УстановитьАтрибут("component", ТекСтрокаНачисления.component);
						КонецЕсли;
						
						ТекНачисление.УстановитьАтрибут("group",        ТекСтрокаНачисления.group);
						ТекНачисление.УстановитьАтрибут("kod",          ТекСтрокаНачисления.kod);
						ТекНачисление.УстановитьАтрибут("name",         ТекСтрокаНачисления.name);
						ТекНачисление.УстановитьАтрибут("edizm",        ТекСтрокаНачисления.edizm);
						ТекНачисление.УстановитьАтрибут("debtbeg",      ТекСтрокаНачисления.debtbeg);
						ТекНачисление.УстановитьАтрибут("debtend",      ТекСтрокаНачисления.debtend);
						ТекНачисление.УстановитьАтрибут("ammount",      ТекСтрокаНачисления.ammount);
						ТекНачисление.УстановитьАтрибут("amountn",      ТекСтрокаНачисления.amountn);
						ТекНачисление.УстановитьАтрибут("hammount",     ТекСтрокаНачисления.hammount);
						ТекНачисление.УстановитьАтрибут("hamountn",     ТекСтрокаНачисления.hamountn);
						ТекНачисление.УстановитьАтрибут("sum",          ТекСтрокаНачисления.sum);
						ТекНачисление.УстановитьАтрибут("hsum",         ТекСтрокаНачисления.hsum);
						ТекНачисление.УстановитьАтрибут("norm",         ТекСтрокаНачисления.norm);
						ТекНачисление.УстановитьАтрибут("hnorm",        ТекСтрокаНачисления.hnorm);
						ТекНачисление.УстановитьАтрибут("peni",         ТекСтрокаНачисления.peni);
						ТекНачисление.УстановитьАтрибут("correction",   ТекСтрокаНачисления.correction);
						ТекНачисление.УстановитьАтрибут("compensation", ТекСтрокаНачисления.compensation);
						ТекНачисление.УстановитьАтрибут("sumpayed",     ТекСтрокаНачисления.sumpayed);
						ТекНачисление.УстановитьАтрибут("sumtopay",     ТекСтрокаНачисления.sumtopay);
						ТекНачисление.УстановитьАтрибут("hsumtopay",    ТекСтрокаНачисления.hsumtopay);
						ТекНачисление.УстановитьАтрибут("volumep",      ТекСтрокаНачисления.volumep);
						ТекНачисление.УстановитьАтрибут("volumea",      ТекСтрокаНачисления.volumea);
						ТекНачисление.УстановитьАтрибут("volumeh",      ТекСтрокаНачисления.volumeh);
						ТекНачисление.УстановитьАтрибут("ammountNorm",  ТекСтрокаНачисления.ammountNorm);
						
						// Начисления ИПУ
						Если ЗначениеЗаполнено(ТекСтрокаНачисления.meter) Тогда
							
							ЭтоПервый = Истина;
							Сч = 2;
							Для каждого ТекИПУ из ТекСтрокаНачисления.meter Цикл
								Если ЭтоПервый Тогда
									ТекНачисление.УстановитьАтрибут("meter", ТекИПУ);
									ЭтоПервый = Ложь;
								Иначе
									ТекНачисление.УстановитьАтрибут("meter" + Строка(Сч), ТекИПУ);
									Сч = Сч + 1;
								КонецЕсли;
							КонецЦикла;
							
						КонецЕсли;
						
						// Начисления ОПУ
						Если ЗначениеЗаполнено(ТекСтрокаНачисления.hmeter) Тогда
							
							ЭтоПервый = Истина;
							Сч = 2;
							Для каждого ТекОПУ из ТекСтрокаНачисления.hmeter Цикл
								Если ЭтоПервый Тогда
									ТекНачисление.УстановитьАтрибут("hmeter", ТекОПУ);
									ЭтоПервый = Ложь;
								Иначе
									ТекНачисление.УстановитьАтрибут("hmeter" + Строка(Сч), ТекОПУ);
									Сч = Сч + 1;
								КонецЕсли;
							КонецЦикла;
						
						КонецЕсли;
						
						// Тарифы
						ТекНачисление.УстановитьАтрибут("tarif1", ТекСтрокаНачисления.tarif1);
						
						Если НЕ ТекСтрокаНачисления.tarif2 = "" ИЛИ НЕ ТекСтрокаНачисления.tarif3 = "" Тогда
							ТекНачисление.УстановитьАтрибут("tarif2", ТекСтрокаНачисления.tarif2);
							ТекНачисление.УстановитьАтрибут("tarif3", ТекСтрокаНачисления.tarif3);
						КонецЕсли;
						
					КонецЦикла;
				КонецЕсли;
				
				// Рассрочка
				Если ЗначениеЗаполнено(ТекСтрокаЛС.credit) Тогда
					Для Каждого ТекСтрокаРассрочки Из ТекСтрокаЛС.credit Цикл
						ТекРассрочка = ДокументDOM.СоздатьЭлемент("credit");
						ТекЛС.ДобавитьДочерний(ТекРассрочка);
						
						ТекРассрочка.УстановитьАтрибут("name",       ТекСтрокаРассрочки.name);
						ТекРассрочка.УстановитьАтрибут("sum",        ТекСтрокаРассрочки.sum);
						ТекРассрочка.УстановитьАтрибут("sumcredit",  ТекСтрокаРассрочки.sumcredit);
						ТекРассрочка.УстановитьАтрибут("rate",       ТекСтрокаРассрочки.rate);
						ТекРассрочка.УстановитьАтрибут("balance",    ТекСтрокаРассрочки.balance);
						ТекРассрочка.УстановитьАтрибут("sumtopay",   ТекСтрокаРассрочки.sumtopay);
						ТекРассрочка.УстановитьАтрибут("contractor", ТекСтрокаРассрочки.contractor);
					КонецЦикла;
				КонецЕсли;
				
				// Перерасчеты
				Если ЗначениеЗаполнено(ТекСтрокаЛС.correction) Тогда
					Для Каждого ТекСтрокаРассрочки Из ТекСтрокаЛС.correction Цикл
					
						ТекПерерасчет = ДокументDOM.СоздатьЭлемент("correction");
						ТекЛС.ДобавитьДочерний(ТекПерерасчет);
						
						ТекПерерасчет.УстановитьАтрибут("contractor", Строка(ТекСтрокаРассрочки.contractor));
						ТекПерерасчет.УстановитьАтрибут("service",    Строка(ТекСтрокаРассрочки.service));
						ТекПерерасчет.УстановитьАтрибут("grounds",    Строка(ТекСтрокаРассрочки.grounds));
						ТекПерерасчет.УстановитьАтрибут("summ",       Строка(ТекСтрокаРассрочки.summ));
					КонецЦикла;
				КонецЕсли;
				
				// Начальное сальдо
				Если ЗначениеЗаполнено(ТекСтрокаЛС.item_debt) Тогда
					Для Каждого ТекСтрокаСальдо Из ТекСтрокаЛС.item_debt Цикл
						
						ТекСальдо = ДокументDOM.СоздатьЭлемент("item_debt");
						ТекЛС.ДобавитьДочерний(ТекСальдо);
						
						ТекСальдо.УстановитьАтрибут("name",     Строка(ТекСтрокаСальдо.name));
						ТекСальдо.УстановитьАтрибут("kod",      Строка(ТекСтрокаСальдо.kod));
						ТекСальдо.УстановитьАтрибут("edizm",    Строка(ТекСтрокаСальдо.edizm));
						ТекСальдо.УстановитьАтрибут("debtbeg",  Строка(ТекСтрокаСальдо.debtbeg));
						ТекСальдо.УстановитьАтрибут("debtend",  Строка(ТекСтрокаСальдо.debtend));
						ТекСальдо.УстановитьАтрибут("peni",     Строка(ТекСтрокаСальдо.peni));
						ТекСальдо.УстановитьАтрибут("sumpayed", Строка(ТекСтрокаСальдо.sumpayed));
					КонецЦикла;
				КонецЕсли;
				
				// ИПУ
				Если ЗначениеЗаполнено(ТекСтрокаЛС.meter) Тогда
					Для каждого ТекСтрокаИПУ из ТекСтрокаЛС.meter Цикл
						
						ТекИПУ = ДокументDOM.СоздатьЭлемент("meter");
						ТекЛС.ДобавитьДочерний(ТекИПУ);
						
						Если ТекСтрокаИПУ.del Тогда
							ТекИПУ.УстановитьАтрибут("del", "");
						КонецЕсли;
						
						ТекИПУ.УстановитьАтрибут("value_count",      ТекСтрокаИПУ.value_count);
						ТекИПУ.УстановитьАтрибут("kod",              ТекСтрокаИПУ.kod);
						ТекИПУ.УстановитьАтрибут("name",             ТекСтрокаИПУ.name);
						ТекИПУ.УстановитьАтрибут("num",              ТекСтрокаИПУ.num);
						ТекИПУ.УстановитьАтрибут("service",          ТекСтрокаИПУ.service);
						ТекИПУ.УстановитьАтрибут("capacity",         ТекСтрокаИПУ.capacity);
						ТекИПУ.УстановитьАтрибут("verificationDate", ТекСтрокаИПУ.verificationDate);
						ТекИПУ.УстановитьАтрибут("charge1",          ТекСтрокаИПУ.charge1);
						ТекИПУ.УстановитьАтрибут("charge2",          ТекСтрокаИПУ.charge2);
						ТекИПУ.УстановитьАтрибут("charge3",          ТекСтрокаИПУ.charge3);
						
						// Показания ИПУ
						Если ЗначениеЗаполнено(ТекСтрокаИПУ.date_indiccur) Тогда
							
							// Текущие
							ТекИПУ.УстановитьАтрибут("date_indiccur", ТекСтрокаИПУ.date_indiccur);
							ТекИПУ.УстановитьАтрибут("indiccur1",     ТекСтрокаИПУ.indiccur1);
							
							Если ТекСтрокаИПУ.value_count = "2" Тогда
								ТекИПУ.УстановитьАтрибут("indiccur2", ТекСтрокаИПУ.indiccur2);
							ИначеЕсли ТекСтрокаИПУ.value_count = "3" Тогда
								ТекИПУ.УстановитьАтрибут("indiccur2", ТекСтрокаИПУ.indiccur2);
								ТекИПУ.УстановитьАтрибут("indiccur3", ТекСтрокаИПУ.indiccur3);
							КонецЕсли;
							
							// Показания на начало месяца
							Если ЗначениеЗаполнено(ТекСтрокаИПУ.date_indicbef) Тогда
								
								ТекИПУ.УстановитьАтрибут("date_indicbef", ТекСтрокаИПУ.date_indicbef);
								ТекИПУ.УстановитьАтрибут("indicbef1", ТекСтрокаИПУ.indicbef1);
								
								Если ТекСтрокаИПУ.value_count = "2" Тогда
									ТекИПУ.УстановитьАтрибут("indicbef2", ТекСтрокаИПУ.indicbef2);
								ИначеЕсли ТекСтрокаИПУ.value_count = "3" Тогда
									ТекИПУ.УстановитьАтрибут("indicbef2", ТекСтрокаИПУ.indicbef2);
									ТекИПУ.УстановитьАтрибут("indicbef3", ТекСтрокаИПУ.indicbef3);
								КонецЕсли;
							КонецЕсли;
						КонецЕсли;
					КонецЦикла;
				КонецЕсли;
				
				// Поставщики
				Если ЗначениеЗаполнено(ТекСтрокаЛС.contractor) Тогда
					Для каждого ТекСтрокаПоставщика из ТекСтрокаЛС.contractor Цикл
						
						ТекПоставщик = ДокументDOM.СоздатьЭлемент("contractor");
						ТекЛС.ДобавитьДочерний(ТекПоставщик);
						
						ТекПоставщик.УстановитьАтрибут("id",       ТекСтрокаПоставщика.id);
						ТекПоставщик.УстановитьАтрибут("services", ТекСтрокаПоставщика.services);
						ТекПоставщик.УстановитьАтрибут("debtbeg",  ТекСтрокаПоставщика.debtbeg);
						ТекПоставщик.УстановитьАтрибут("sum",      ТекСтрокаПоставщика.sum);
						ТекПоставщик.УстановитьАтрибут("sumpayed", ТекСтрокаПоставщика.sumpayed);
						ТекПоставщик.УстановитьАтрибут("peni",     ТекСтрокаПоставщика.peni);
						ТекПоставщик.УстановитьАтрибут("sumtopay", ТекСтрокаПоставщика.sumtopay);
						ТекПоставщик.УстановитьАтрибут("summ",     ТекСтрокаПоставщика.summ);
						
						Если НЕ ТекСтрокаПоставщика.num = "" Тогда
							ТекПоставщик.УстановитьАтрибут("num", ТекСтрокаПоставщика.num);
						КонецЕсли;
						
					КонецЦикла;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
	Иначе
		// Вариант выгрузки "Access".
		Если ЗначениеЗаполнено(СтруктураВыгрузки.PersAcc) Тогда
			Для каждого ТекСтрока из СтруктураВыгрузки.PersAcc Цикл
				
				СтрокаЛС = ДокументDOM.СоздатьЭлемент("PersAcc");
				КорневойЭлемент.ДобавитьДочерний(СтрокаЛС);
				
				СтрокаЛС.УстановитьАтрибут("kod_ls",     ТекСтрока.kod_ls);
				СтрокаЛС.УстановитьАтрибут("kod_ls_new", ТекСтрока.kod_ls_new);
				СтрокаЛС.УстановитьАтрибут("login",      ТекСтрока.login);
				СтрокаЛС.УстановитьАтрибут("password",   ТекСтрока.password);
				СтрокаЛС.УстановитьАтрибут("email",      ТекСтрока.email);
				
				Если ОбновлятьПараметрыДоступа Тогда
					СтрокаЛС.УстановитьАтрибут("rewrite", "true");
				КонецЕсли;
				
			КонецЦикла;
		КонецЕсли;
	КонецЕсли;
	
	ЗаписьDOM = Новый ЗаписьDOM();
	ЗаписьDOM.Записать(ДокументDOM, ЗаписьXML);
	
	ЗаписьXML.Закрыть();
	
	Возврат ИмяВременногоФайла;
	
КонецФункции

// Формирует описание ошибки обмена с сайтом на основе полученного ответа.
//
// Параметры:
//  Ответ - Строка - ответ, пришедший с сайта.
//
// Возвращаемое значение:
//  Строка.
//
Функция ПолучитьОписаниеОшибкиОбмена(Ответ)
	
	ОшибкаОбмена = "";
	
	Если СтрЧислоСтрок(Ответ) > 1 Тогда
		ОшибкаОбмена = СтрПолучитьСтроку(Ответ, 2);
	КонецЕсли;
	
	Возврат ОшибкаОбмена;
	
КонецФункции // ПолучитьОписаниеОшибкиОбмена()

// Анализирует ошибки при обмене данными и возвращает их описание.
//
Функция ОбработатьТекстОшибки(ТекстОшибки)
	
	Если НЕ Найти(ТекстОшибки, "Превышено время ожидания") = 0 Тогда
		
		Возврат "Не удалось загрузить файл на сайт: превышено время ожидания ответа с сайта.";
		
	КонецЕсли;
	
	Возврат "Не удалось загрузить файл на сайт: исключительная ошибка.";
	
КонецФункции

// Создает http-соединение в случае ошибки 301 или 302 (ресурс перемещен).
Функция ИзменитьHTTPСоединениеВСлучаеЕслиРесурсПеремещен(HTTPСоединение, HTTPОтвет, СведенияОбОшибке)
	
	Попытка
		НовыйРесурс = HTTPОтвет.Заголовки["Location"];
		
		ИспользоватьSSL = Ложь;
		СтрокаДляЗамены = "http://";
		
		Если СтрНачинаетсяС(НовыйРесурс, "https") Тогда
			ИспользоватьSSL = Истина;
			СтрокаДляЗамены = "https://";
		КонецЕсли;
		
		НовыйРесурс = СтрЗаменить(НовыйРесурс, СтрокаДляЗамены, "");
		
		НачалоТекстаЗапроса = СтрНайти(НовыйРесурс, "/");
		
		Если Не НачалоТекстаЗапроса = 0 Тогда
			НовыйРесурс = Лев(НовыйРесурс, НачалоТекстаЗапроса - 1);
		КонецЕсли;
		
		мHTTPСоединение = ПолучитьHTTPСоединение(НовыйРесурс, HTTPСоединение.Пользователь, HTTPСоединение.Пароль, ИспользоватьSSL, HTTPСоединение.Таймаут);
		
		Возврат мHTTPСоединение;
		
	Исключение
		СведенияОбОшибке = "Ошибка при при переходе на перемещенный ресурс.";
		УПЖКХ_ТиповыеМетодыКлиентСервер.СообщитьОбОшибке(СведенияОбОшибке);
		Возврат Неопределено;
	КонецПопытки;
	
КонецФункции

#КонецОбласти

////////////////////////////////////////////////////////////////////////////////
// ОБЩИЕ ФУНКЦИИ ОТПРАВКИ HTTP-ЗАПРОСОВ

#Область ОбщиеФункцииОтправкиHTTPЗапросов

// Общая функция отправки POST-запросов.
//
Функция ОтправитьPOSTЗапрос(мHTTPСоединение, Заголовки = Неопределено, ТекстЗапроса, ТелоЗапроса, Кодировка = Неопределено) Экспорт
	
	Если Кодировка = Неопределено Тогда
		Кодировка = КодировкаТекста.ANSI;
	КонецЕсли;
	
	Если Заголовки = Неопределено Тогда
		ЗапросHTTP = Новый HTTPЗапрос(ТекстЗапроса);
	Иначе
		ЗапросHTTP = Новый HTTPЗапрос(ТекстЗапроса, Заголовки);
	КонецЕсли;
	
	ЗапросHTTP.УстановитьТелоИзСтроки(ТелоЗапроса, Кодировка);
	
	ОтветHTTP = мHTTPСоединение.ОтправитьДляОбработки(ЗапросHTTP);
	Ответ     = СокрЛ(ОтветHTTP.ПолучитьТелоКакСтроку());
	
	Возврат Ответ;
	
КонецФункции

// Общая функция отправки GET-запросов.
//
Функция ОтправитьGETЗапрос(мHTTPСоединение, Заголовки = Неопределено, ТекстЗапроса) Экспорт
	
	Если Заголовки = Неопределено Тогда
		ЗапросHTTP = Новый HTTPЗапрос(ТекстЗапроса);
	Иначе
		ЗапросHTTP = Новый HTTPЗапрос(ТекстЗапроса, Заголовки);
	КонецЕсли;
	
	ОтветHTTP = мHTTPСоединение.Получить(ЗапросHTTP);
	
	КодОтвета = ОтветHTTP.КодСостояния;
	
	Если КодОтвета = 200 Тогда
		Ответ = СокрЛП(ОтветHTTP.ПолучитьТелоКакСтроку());
		
	// Если сайт перемещен, то пытаемся перейти на сайт, указанный в заголовке "Location".
	ИначеЕсли ОтветHTTP.КодСостояния = 301 ИЛИ ОтветHTTP.КодСостояния = 302 Тогда
		
		СведенияОбОшибке = "";
		мHTTPСоединение  = ИзменитьHTTPСоединениеВСлучаеЕслиРесурсПеремещен(мHTTPСоединение, ОтветHTTP, СведенияОбОшибке);
		
		Если мHTTPСоединение = Неопределено Тогда
			Ответ = СтрШаблон("failure(%1): %2", КодОтвета, СведенияОбОшибке);
		Иначе
			Ответ = ОтправитьGETЗапрос(мHTTPСоединение, Заголовки, ТекстЗапроса);
		КонецЕсли;
		
	Иначе
		Ответ = СтрШаблон("failure(%1): %2", КодОтвета, СокрЛП(ОтветHTTP.ПолучитьТелоКакСтроку()));
	КонецЕсли;
	
	Возврат Ответ;
	
КонецФункции

#КонецОбласти

////////////////////////////////////////////////////////////////////////////////
// ФУНКЦИИ ОТПРАВКИ HTTP-ЗАПРОСОВ НА САЙТ

#Область ФункцииОтправкиHTTPЗапросовНаСайт

// Функция отправки стандартных POST-запросов на сайт.
//
Функция ОтправитьPOSTЗапросНаСайт(мHTTPСоединение, Куки, ТекстЗапроса, ТелоЗапроса)
	
	Возврат ОтправитьPOSTЗапрос(мHTTPСоединение, ПолучитьЗаголовкиДляHTTPЗапроса(мHTTPСоединение, Куки), ТекстЗапроса, ТелоЗапроса);
	
КонецФункции

// Функция отправки стандартных GET-запросов на сайт.
//
Функция ОтправитьGETЗапросНаСайт(мHTTPСоединение, Куки, ТекстЗапроса)
	
	Возврат ОтправитьGETЗапрос(мHTTPСоединение, ПолучитьЗаголовкиДляHTTPЗапроса(мHTTPСоединение, Куки), ТекстЗапроса);
	
КонецФункции

// Функция для подготовки HTTP-заголовков для стандартных запросов на сайт.
//
Функция ПолучитьЗаголовкиДляHTTPЗапроса(мHTTPСоединение, Куки)
	
	ЗаголовкиHTTP = Новый Соответствие;
	ЗаголовкиHTTP.Вставить("Host",       мHTTPСоединение.Сервер);
	ЗаголовкиHTTP.Вставить("User-Agent", УПЖКХ_ВебИнтеграцияВзаимодействиеСБазойДанных.ПолучитьПредставлениеАгентаДляСайта());
	ЗаголовкиHTTP.Вставить("Cookie",     Куки.Имя + "=" + Куки.Cookie);
	
	Возврат ЗаголовкиHTTP;
	
КонецФункции

#КонецОбласти

