////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Универсальные механизмы библиотек интеграции с государственными информационными системами:
//  * ЕГАИС,
//  * ГИСМ,
//  * ВетИС,
//  * ИС МОТП
// Состав модуля:
//
//  * Функции работы с прикладными документами (вывод привязки библиотечных документов, оповещений итп).
//  * Общие функции проведения документов.
//  * Общие функции для работы с протоколом обмена (Присоединенные файлы)
//  * Функции общего назначения.

#Область ПрограммныйИнтерфейс

#Область ОбменСИспользованиемЭДО

// Получает структуру настроек обмена через ЭДО, извлекая из константы НастройкиОбменаГосИС.
// 
// Возвращаемое значение:
//  ТаблицаЗначений, Неопределено - Настройки обмена.
//
Функция НастройкиОбменаГосИС() Экспорт
	
	ХранилищеЗначения = Константы.НастройкиОбменаГосИС.Получить();
	
	Если ХранилищеЗначения = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	НастройкиОбмена = ХранилищеЗначения.Получить();
	
	Возврат НастройкиОбмена;
	
КонецФункции

#КонецОбласти

#Область ФорматированиеXML

// Инициализирует объект ПараметрыЗаписиXML.
//
// Параметры:
//  ИспользоватьОтступы - Булево - признак использования отступов, по умолчанию Истина.
//  СимволОтступа       - Строка - символ, которым отображается отступ, по умолчанию два пробела.
//  Кодировка           - Строка - Кодировка текста.
// 
// Возвращаемое значение:
//  ПараметрыЗаписиXML - набор параметров, который используется при записи XML.
//
Функция ПараметрыФорматированияXML(ИспользоватьОтступы = Истина, СимволОтступа = "  ", Кодировка = "UTF-8") Экспорт
	
	ПараметрыЗаписи = Новый ПараметрыЗаписиXML(
		Кодировка,
		"1.0",
		ИспользоватьОтступы,
		ИспользоватьОтступы,
		СимволОтступа);
	
	Возврат ПараметрыЗаписи;
	
КонецФункции

// Форматирует текст сообщения в формате XML
//
// Параметры:
//  ТекстСообщенияXML       - Строка - текст сообщения, который.
//  ПараметрыФорматирования - ПараметрыЗаписиXML - параметры записи XML.
// 
// Возвращаемое значение:
//  Строка - отформатированная строка XML.
//
Функция ФорматироватьXMLСПараметрами(ТекстСообщенияXML, ПараметрыФорматирования) Экспорт
	
	ЧтениеXML = Новый ЧтениеXML;
	ЧтениеXML.УстановитьСтроку(ТекстСообщенияXML);
	
	ПостроительDOM = Новый ПостроительDOM;
	ДокументDOM = ПостроительDOM.Прочитать(ЧтениеXML);
	
	ЗаписьXML = Новый ЗаписьXML;
	ЗаписьXML.УстановитьСтроку(ПараметрыФорматирования);
	
	ЗаписьDOM = Новый ЗаписьDOM;
	ЗаписьDOM.Записать(ДокументDOM, ЗаписьXML);
	
	Возврат ЗаписьXML.Закрыть();
	
КонецФункции

// Форматирует текст сообщения в формате XML
//
// Параметры:
//  ТекстСообщенияXML   - Строка - текст сообщения, который.
//  ИспользоватьОтступы - Булево - признак использования отступов, по умолчанию Истина.
//  СимволОтступа       - Строка - символ, которым отображается отступ, по умолчанию два пробела.
// 
// Возвращаемое значение:
//  Строка - отформатированная строка XML.
//
Функция ФорматироватьXML(ТекстСообщенияXML, ИспользоватьОтступы = Истина, СимволОтступа = " ") Экспорт
	
	ПараметрыФорматирования = ПараметрыФорматированияXML(ИспользоватьОтступы, СимволОтступа);
	
	Возврат ФорматироватьXMLСПараметрами(ТекстСообщенияXML, ПараметрыФорматирования);
	
КонецФункции

#КонецОбласти

#Область РаботаСXDTO

// Возвращает все пространства зависимые пространства имен из коллекции пакетов.
//
Процедура ЗависимыеПространстваИмен(ЗависимыеПакеты, ПространстваИмен) Экспорт
	
	Для Каждого ПакетXDTO Из ЗависимыеПакеты Цикл
		Если ПространстваИмен.Найти(ПакетXDTO.URIПространстваИмен) <> Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		ПространстваИмен.Добавить(ПакетXDTO.URIПространстваИмен);
		
		ЗависимыеПространстваИмен(ПакетXDTO.Зависимости, ПространстваИмен);
	КонецЦикла;
	
КонецПроцедуры

// Создает ОбъектXDTO из пространства имен по имени свойства.
//
Функция ОбъектXDTOПоИмениТипа(ОбъектXDTOРодитель, ИмяТипа) Экспорт
	
	Если ТипЗнч(ОбъектXDTOРодитель) = Тип("СписокXDTO") Тогда
		ТипОбъекта = ОбъектXDTOРодитель.ВладеющееСвойство.Тип.Свойства.Получить(ИмяТипа).Тип;
	Иначе
		ТипОбъекта = ОбъектXDTOРодитель.Тип().Свойства.Получить(ИмяТипа).Тип;
	КонецЕсли; 
	
	Возврат ФабрикаXDTO.Создать(ТипОбъекта);
	
КонецФункции

// Создает ОбъектXDTO из пространства имен по имени свойства.
//
Функция ОбъектXDTOПоИмениСвойства(ПространствоИмен, ИмяСвойства, ОбъектXDTOРодитель = Неопределено) Экспорт
	
	Если ОбъектXDTOРодитель = Неопределено Тогда
		ТипОбъекта = ФабрикаXDTO.Пакеты.Получить(ПространствоИмен).КорневыеСвойства.Получить(ИмяСвойства).Тип;
	Иначе
		ТипОбъекта = ОбъектXDTOРодитель.Тип().Свойства.Получить(ИмяСвойства).Тип;
	КонецЕсли;
	
	Возврат ФабрикаXDTO.Создать(ТипОбъекта);
	
КонецФункции

// Преобразует объект XDTO в структуру
//
// Параметры:
//  ОбъектXDTO - ОбъектXDTO - Объект XDTO.
// 
// Возвращаемое значение:
//  Структура - Структура объекта.
//
Функция ОбъектXDTOВСтруктуру(ОбъектXDTO, ПараметрыПреобразования = Неопределено) Экспорт
	
	Структура      = Новый Структура;
	ТипОбъектаXDTO = ОбъектXDTO.Тип();
	
	Для Каждого Свойство Из ОбъектXDTO.Свойства() Цикл
		
		ИмяСвойства      = Свойство.Имя;
		ЗначениеСвойства = ОбъектXDTO[ИмяСвойства];
		
		Если ТипЗнч(ЗначениеСвойства) = Тип("ОбъектXDTO") Тогда
			
			Структура.Вставить(ИмяСвойства, ИнтеграцияИС.ОбъектXDTOВСтруктуру(ЗначениеСвойства, ПараметрыПреобразования));
			
		ИначеЕсли ТипЗнч(ЗначениеСвойства) = Тип("СписокXDTO") Тогда
			
			Структура.Вставить(ИмяСвойства, Новый Массив);
			Для Индекс = 0 По ЗначениеСвойства.Количество() - 1 Цикл
				
				ЭлементСписка = ЗначениеСвойства.Получить(Индекс);
				Если ТипЗнч(ЭлементСписка) = Тип("ОбъектXDTO") Тогда
					Структура[ИмяСвойства].Добавить(ИнтеграцияИС.ОбъектXDTOВСтруктуру(ЭлементСписка, ПараметрыПреобразования));
				Иначе
					Структура[ИмяСвойства].Добавить(ЭлементСписка);
				КонецЕсли;
				
			КонецЦикла;
			
		Иначе
			
			Структура.Вставить(ИмяСвойства, ЗначениеСвойства);
			
			Если ПараметрыПреобразования <> Неопределено
				И ПараметрыПреобразования.НайтиИдентификаторы
				И Свойство.Тип = ПараметрыПреобразования.ТипUUID Тогда
				
				РезультатПоиска = ПараметрыПреобразования.ТипыИдентификаторов[ТипОбъектаXDTO];
				Если РезультатПоиска <> Неопределено
					И РезультатПоиска.ИмяПоля = ИмяСвойства Тогда
					ПараметрыПреобразования.Идентификаторы[РезультатПоиска.ИмяТаблицы].Вставить(ЗначениеСвойства, РезультатПоиска.ПустоеЗначение);
				КонецЕсли;
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Структура;
	
КонецФункции

// Устанавливает значение свойства объекта XDTO, 
//с проверкой на наличие свойства и необходимость заполнения.
//
// Параметры:
//  ОбъектXDTO       - ОбъектXDTO   - объект в котором заполняется свойство
//  ИмяСвойства      - Строка       - имя свойства
//  ЗначениеСвойства - Произвольный - значение свойства
//  КешОшибок        - Структура    - см. ИнтеграцияИСКлиентСервер.ДобавитьТекстОшибки()
//  Расшифровки      - Структура    - см. ДанныеДляРасшифровкиОшибок()
//
Процедура ЗаполнитьСвойствоXDTO(ОбъектXDTO, ИмяСвойства, ЗначениеСвойства, КешОшибок, Расшифровки) Экспорт
	
	Если Не ОбщегоНазначенияКлиентСервер.ЕстьРеквизитИлиСвойствоОбъекта(ОбъектXDTO, ИмяСвойства) Тогда
		Возврат;
	КонецЕсли;
	
	РазрешеноНеЗаполнять = ОбъектXDTO.Тип().Свойства.Получить(ИмяСвойства).НижняяГраница = 0;
	Если Не ЗначениеЗаполнено(ЗначениеСвойства)
		И РазрешеноНеЗаполнять Тогда
		Возврат;
	КонецЕсли;
	
	УстановитьСвойствоXDTO(ОбъектXDTO, ИмяСвойства, ЗначениеСвойства, КешОшибок, Расшифровки);
	
КонецПроцедуры

// Устанавливает значение свойства объекта XDTO (для списка - добавляет элемент в список), без проверок
//
// Параметры:
//  ОбъектXDTO       - ОбъектXDTO   - объект в котором заполняется свойство
//  ИмяСвойства      - Строка       - имя свойства
//  ЗначениеСвойства - Произвольный - значение свойства
//  КешОшибок        - Структура    - см ИнтеграцияИСКлиентСервер.ДобавитьТекстОшибки()
//  Расшифровки      - Структура    - см ДанныеДляРасшифровкиОшибок()
//
Процедура УстановитьСвойствоXDTO(ОбъектXDTO, ИмяСвойства, ЗначениеСвойства, КешОшибок, Расшифровки) Экспорт
	
	Попытка
		Если ТипЗнч(ОбъектXDTO[ИмяСвойства]) = Тип("СписокXDTO") Тогда
			ОбъектXDTO[ИмяСвойства].Добавить(ЗначениеСвойства);
		Иначе
			ОбъектXDTO[ИмяСвойства] = ЗначениеСвойства;
		КонецЕсли;
	Исключение
		ЧтениеXML = Новый Структура;
		ЧтениеXML.Вставить("Имя"                , ИмяСвойства);
		ЧтениеXML.Вставить("ЛокальноеИмя"       , ИмяСвойства);
		ЧтениеXML.Вставить("Значение"           , ЗначениеСвойства);
		ЧтениеXML.Вставить("ТипУзла"            , ТипУзлаXML.КонецЭлемента);
		ЧтениеXML.Вставить("URIПространстваИмен", ОбъектXDTO.Тип().URIПространстваИмен);
		
		ТекстОшибки = КраткоеПредставлениеОшибки(ИнформацияОбОшибке());
		ТекстОшибки = ПредставлениеОшибкиXDTO(ТекстОшибки, ЧтениеXML, Расшифровки);
		
		Если КешОшибок <> Неопределено Тогда
			ИнтеграцияИСКлиентСервер.ДобавитьТекстОшибки(КешОшибок, ТекстОшибки);
		КонецЕсли;
		
	КонецПопытки;
	
КонецПроцедуры

// Возвращает пользовательское представление ошибки
//
// Параметры:
//  ПредставлениеОшибки	 - Строка               - представление ошибки до обработки
//  ЧтениеXML            - ЧтениеXML, Структура - ошибочный узел данных
//  Расшифровки          - Структура            - см. ДанныеДляРасшифровкиОшибок()
// 
// Возвращаемое значение:
//  Строка - представление ошибки после обработки
//
Функция ПредставлениеОшибкиXDTO(ПредставлениеОшибки, ЧтениеXML, Расшифровки) Экспорт
	
	Если СтрНайти(ПредставлениеОшибки, НСтр("ru = 'Ошибка проверки данных XDTO'")) = 0
		И СтрНайти(ПредставлениеОшибки, НСтр("ru = 'Несоответствие типов XDTO'")) = 0 Тогда
		Возврат ПредставлениеОшибки;
	КонецЕсли;
	
	ЗначениеПоля = ЧтениеXML.Значение;
	Если ЧтениеXML.ТипУзла = ТипУзлаXML.Текст Тогда
		ЧтениеXML.Прочитать();
	КонецЕсли;
	
	Если Расшифровки.Таблица = Неопределено Тогда
		Расшифровки.Таблица = ПредставленияПолей(Расшифровки.ИмяМакета);
	КонецЕсли;
	
	Отбор = Новый Структура;
	Отбор.Вставить("ПространствоИмен", ЧтениеXML.URIПространстваИмен);
	Отбор.Вставить("ЛокальноеИмя",     ЧтениеXML.ЛокальноеИмя);
	
	МассивСтрок = Расшифровки.Таблица.НайтиСтроки(Отбор);
	
	СтрокаТаблицы = Неопределено;
	Если МассивСтрок.Количество() = 1 Тогда
		СтрокаТаблицы = МассивСтрок[0];
	ИначеЕсли МассивСтрок.Количество() > 1 И НЕ Расшифровки.Глубина = Неопределено Тогда
		Отбор.Вставить("Глубина", Расшифровки.Глубина);
		МассивСтрокПоГлубине = Расшифровки.Таблица.НайтиСтроки(Отбор);
		Если МассивСтрокПоГлубине.Количество() > 0 Тогда
			СтрокаТаблицы = МассивСтрокПоГлубине[0];
		Иначе
			СтрокаТаблицы = МассивСтрок[0];
		КонецЕсли;
	КонецЕсли;
	
	Если СтрокаТаблицы <> Неопределено Тогда
		Если ЧтениеXML.ТипУзла = ТипУзлаXML.КонецЭлемента Тогда
			Если НЕ ЗначениеЗаполнено(ЗначениеПоля) Тогда
				ПредставлениеОшибки = НСтр("ru = 'Не заполнено значение поля ""%1"" (%2)'");
				ПредставлениеОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ПредставлениеОшибки, СтрокаТаблицы.Представление, ЧтениеXML.Имя);
			Иначе
				ПредставлениеОшибки = НСтр("ru = 'Некорректное значение ""%1"" поля ""%2"" (%3)'");
				ПредставлениеОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ПредставлениеОшибки, ЗначениеПоля, СтрокаТаблицы.Представление, ЧтениеXML.Имя);
			КонецЕсли;
		Иначе
			ИндексСтроки = Расшифровки.Таблица.Индекс(СтрокаТаблицы);
			
			Пока ИндексСтроки > 0 Цикл
				ПредыдущееПоле = Расшифровки.Таблица[ИндексСтроки - 1];
				Если ПредыдущееПоле.ПространствоИмен <> СтрокаТаблицы.ПространствоИмен Тогда
					Прервать;
				КонецЕсли;
				Если ПредыдущееПоле.Обязательное Тогда
					ПредставлениеОшибки = НСтр("ru = 'Отсутствует обязательное поле ""%1"" (%2)'");
					ПредставлениеОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ПредставлениеОшибки, ПредыдущееПоле.Представление, ПредыдущееПоле.ЛокальноеИмя);
					Прервать;
				КонецЕсли;
				ИндексСтроки = ИндексСтроки - 1;
			КонецЦикла;
		КонецЕсли;
	КонецЕсли;
	
	Возврат ПредставлениеОшибки;
	
КонецФункции

// Возвращает Объект XDTO, получаемый из текста сообщения XML
//
// Параметры:
//  ТекстСообщенияXML - Строка - Текст сообщения XML
// 
// Возвращаемое значение:
//  ОбъектXDTO - Объект XDTO
//
Функция ПроизвольныйОбъектXDTOПоТекстуСообщенияXML(ТекстСообщенияXML) Экспорт
	
	ЧтениеXML = Новый ЧтениеXML;
	ЧтениеXML.УстановитьСтроку(ТекстСообщенияXML);
	
	ОбъектXDTO = ФабрикаXDTO.ПрочитатьXML(ЧтениеXML);
	
	Возврат ОбъектXDTO;
	
КонецФункции


#КонецОбласти

#Область РаботаСЗапросами

// Формирует пакет запросов и возвращает результат каждого запроса
//
// Параметры:
//  Запрос				 - Запрос	 - запрос, параметры которого предварительно установлены.
//  ТекстыЗапроса		 - СписокЗначений	 - в списке перечислены тексты запросов и их имена.
//  ВыгрузитьРезультат	 - Булево			 - Истина, если результат запроса нужно выгрузить в таблицы значений.
// 
// Возвращаемое значение:
//  Структура - структура в которую помещены полученные таблицы
//
Функция ВыполнитьПакетЗапросов(Запрос, ТекстыЗапроса, ВыгрузитьРезультат = Ложь) Экспорт

	Таблицы = Новый Структура;
	
	МассивТекстаЗапроса = Новый Массив;
	
	// Формирование текст запроса.
	Для Каждого ТекстЗапроса из ТекстыЗапроса Цикл
		Если ЗначениеЗаполнено(ТекстЗапроса.Представление) Тогда
			МассивТекстаЗапроса.Добавить("// " + ТекстЗапроса.Представление);
		КонецЕсли;
		МассивТекстаЗапроса.Добавить(ТекстЗапроса.Значение);
		
		МассивТекстаЗапроса.Добавить(
		";
		|
		|////////////////////////////////////////////////////////////////////////////////
		|");
	КонецЦикла;
	
	Запрос.Текст = СтрСоединить(МассивТекстаЗапроса, Символы.ПС);
	
	// Выполнение запроса.
	Результат = Запрос.ВыполнитьПакет();

	КоличествоЗапросовВПакете = 0;
	
	// Помещение результатов запроса в таблицы
	Для Каждого ТекстЗапроса из ТекстыЗапроса Цикл
		
		Если СтрЧислоВхождений(ТекстЗапроса.Значение, ";") > 0 Тогда
			Подзапросы = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ТекстЗапроса.Значение, ";");
			КоличествоПодзапросов = Подзапросы.Количество();
			ИндексЗапросаРезультате = Неопределено;
			Для Индекс = -(КоличествоПодзапросов - 1) По 0 Цикл
				Если Найти(Подзапросы[-Индекс], "#РезультатЗапроса#") > 0 Тогда
					ИндексЗапросаРезультате = -Индекс;
					Прервать;
				КонецЕсли;
			КонецЦикла;
			Если ИндексЗапросаРезультате = Неопределено Тогда
				ИндексЗапросаРезультате = КоличествоПодзапросов - 1;
			КонецЕсли;
		Иначе
			КоличествоПодзапросов = 1;
			ИндексЗапросаРезультате = 0;
		КонецЕсли;
		
		Если ЗначениеЗаполнено(ТекстЗапроса.Представление) Тогда
			РезультатТаблица = Результат[КоличествоЗапросовВПакете + ИндексЗапросаРезультате];
			РезультатТаблица = ?(ВыгрузитьРезультат, РезультатТаблица.Выгрузить(), РезультатТаблица);
			Таблицы.Вставить(ТекстЗапроса.Представление, РезультатТаблица);
		КонецЕсли;
		
		КоличествоЗапросовВПакете = КоличествоЗапросовВПакете + КоличествоПодзапросов;
		
	КонецЦикла;
	
	Возврат Таблицы;
	
КонецФункции

#КонецОбласти

#Область ФормыДокументовОснований

//Вывод гиперссылок на документы ИС в форме документа-основания.
//
// Для подключения документа-основания ВЕТИС к этому механизму нужно в модуле формы документа-основания добавить вызовы
//	- ИнтеграцияИС.ПриСозданииНаСервереВФормеДокументаОснования
//	- ИнтеграцияИС.ПриЧтенииНаСервереВФормеДокументаОснования
//	- ИнтеграцияИС.ПослеЗаписиНаСервереВФормеДокументаОснования
//	- ИнтеграцияИСКлиент.ОбработкаОповещенияВФормеДокументаОснования
// Также нужно добавить в модуле формы процедуры
//	- Подключаемый_ПолеИнтеграцииИСОбработкаНавигационнойСсылки
//	- Подключаемый_ОбновитьПолеИнтеграцииИСВФормеДокументаОснования
//	- ОбновитьПолеИнтеграцииИСВФормеДокументаОснования

// Параметры вывода гиперссылок на документы ИС в форме документа-основания.
//
// Параметры:
//  ИменаПодсистем           - Строка - имена подсистем (через запятую), на объекты которых нужны гиперссылки
//  ИмяЭлементаДляРазмещения - Строка - имя реквизита формы, для размещения гиперссылок
// 
// Возвращаемое значение:
//  Структура - согласно параметрам
//
Функция ПараметрыИнтеграцииВФорме(ИменаПодсистем = "", ИмяЭлементаДляРазмещения = "") Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("ИменаПодсистем",           ИменаПодсистем);
	Результат.Вставить("ИмяЭлементаДляРазмещения", ИмяЭлементаДляРазмещения);
	Возврат Результат;
	
КонецФункции

Функция ИмяЭлементаДляРазмещения() Экспорт
	
	Возврат "ГруппаИнтеграция";
	
КонецФункции

// Процедура - При создании на сервере в форме документа основания
//
// Параметры:
//  Форма                  - УправляемаяФорма        - форма прикладного объекта для встраивания библиотечной гиперссылки
//  Объект                 - ДанныеФормыСтруктура    - данные прикладного объекта
//  УстановленныеПараметры - Структура, Неопределено - см ПараметрыИнтеграцииВФорме()
//
Процедура ПриСозданииНаСервереВФормеДокументаОснования(Форма, Объект, УстановленныеПараметры = Неопределено) Экспорт
	
	ПараметрыИнтеграции = ПараметрыИнтеграцииВФорме();
	
	Если ЗначениеЗаполнено(УстановленныеПараметры) Тогда
		ЗаполнитьЗначенияСвойств(ПараметрыИнтеграции, УстановленныеПараметры);
	Иначе 
		ЗаполнитьЗначенияСвойств(ПараметрыИнтеграции, ПараметрыИнтеграцииВФормеПоОбъекту(Объект));
	КонецЕсли;
	
	ИнтегрируемыеПодсистемы = Новый Структура;
	Реквизиты = Новый Массив;
	
	Для Каждого КлючИЗначение Из Новый Структура(ПараметрыИнтеграции.ИменаПодсистем) Цикл
		
		// Проверим использование подсистемы.
		ИмяПодсистемы = КлючИЗначение.Ключ;
		
		ИспользованиеПодсистемы = Ложь;
		Если ПодсистемаСуществует(ИмяПодсистемы) Тогда
			
			МодульИнтеграции = ОбщийМодуль(ИмяПодсистемы);
			ИспользованиеПодсистемы = МодульИнтеграции.ИспользуетсяИнтеграцияВФормеДокументаОснования(Форма, Объект);
			
		КонецЕсли;
		
		Если НЕ ИспользованиеПодсистемы Тогда
			Продолжить;
		КонецЕсли;
		
		ИнтегрируемыеПодсистемы.Вставить(ИмяПодсистемы);
		
		// Добавим реквизит формы для подсистемы.
		Реквизиты.Добавить(Новый РеквизитФормы(
			ИнтеграцияИСКлиентСервер.ИмяПоляИнтеграцииВФормеДокументаОснования(ИмяПодсистемы),
			Новый ОписаниеТипов("ФорматированнаяСтрока")));
		
	КонецЦикла;
	
	Если ИнтегрируемыеПодсистемы.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	// Добавим служебный реквизит описания всех используемых подсистем.
	Реквизиты.Добавить(Новый РеквизитФормы(
		ИнтеграцияИСКлиентСервер.ИмяПоляОписанияИнтеграцийВФормеДокументаОснования(),
		Новый ОписаниеТипов()));
	
	// Создадим реквизиты формы.
	Форма.ИзменитьРеквизиты(Реквизиты);
	
	Форма[ИнтеграцияИСКлиентСервер.ИмяПоляОписанияИнтеграцийВФормеДокументаОснования()] =
		Новый ФиксированнаяСтруктура(ИнтегрируемыеПодсистемы);
		
	ЭлементРодитель = Форма.Элементы.Найти(ПараметрыИнтеграции.ИмяЭлементаДляРазмещения);
	Если ЭлементРодитель <> Неопределено Тогда
		Для Каждого КлючИЗначение Из ИнтегрируемыеПодсистемы Цикл
			
			ИмяПодсистемы = КлючИЗначение.Ключ;
			
			// Создадим элемент формы для подсистемы.
			ПолеНадписи = Форма.Элементы.Добавить(
				ИнтеграцияИСКлиентСервер.ИмяПоляИнтеграцииВФормеДокументаОснования(ИмяПодсистемы),
				Тип("ПолеФормы"),
				ЭлементРодитель);
			
			ПолеНадписи.Вид                     = ВидПоляФормы.ПолеНадписи;
			ПолеНадписи.ПутьКДанным             = ИнтеграцияИСКлиентСервер.ИмяПоляИнтеграцииВФормеДокументаОснования(ИмяПодсистемы);
			ПолеНадписи.ПоложениеЗаголовка      = ПоложениеЗаголовкаЭлементаФормы.Нет;
			ПолеНадписи.АвтоМаксимальнаяШирина  = Ложь;
			ПолеНадписи.АвтоМаксимальнаяВысота  = Ложь;
			ПолеНадписи.МаксимальнаяВысота      = 2;
			
			ПолеНадписи.УстановитьДействие(
				"ОбработкаНавигационнойСсылки",
				"Подключаемый_ПолеИнтеграцииИСОбработкаНавигационнойСсылки");
			
		КонецЦикла;
	КонецЕсли;
	
	ОбновитьПолеИнтеграцииВФормеДокументаОснования(Форма, Объект);
	
КонецПроцедуры

Процедура ПриЧтенииНаСервереВФормеДокументаОснования(Форма, Объект) Экспорт
	
	ОбновитьПолеИнтеграцииВФормеДокументаОснования(Форма, Объект);
	
КонецПроцедуры

Процедура ПослеЗаписиНаСервереВФормеДокументаОснования(Форма, Объект) Экспорт
	
	ОбновитьПолеИнтеграцииВФормеДокументаОснования(Форма, Объект);
	
КонецПроцедуры

Процедура ОбновитьПолеИнтеграцииВФормеДокументаОснования(Форма, Объект, ДополнительныеПараметры = Неопределено) Экспорт
	
	Если ТипЗнч(ДополнительныеПараметры) = Тип("Структура")
	 И ДополнительныеПараметры.Свойство("АвтоТест") Тогда
		Возврат; // проверка встраивания поля интеграции в форму
	КонецЕсли;
	
	ИнтегрируемыеПодсистемы = ИнтеграцияИСКлиентСервер.ИнтегрируемыеПодсистемыВФормеДокументаОснования(Форма);
	
	Если НЕ ЗначениеЗаполнено(ИнтегрируемыеПодсистемы) Тогда
		Возврат;
	КонецЕсли;
	
	Если ТипЗнч(ДополнительныеПараметры) = Тип("Структура") И ДополнительныеПараметры.Свойство("ИмяПодсистемы") Тогда
		ИмяПодсистемыИзПараметров = ДополнительныеПараметры.ИмяПодсистемы;
	Иначе
		ИмяПодсистемыИзПараметров = Неопределено;
	КонецЕсли;
	
	Для Каждого КлючИЗначение Из ИнтегрируемыеПодсистемы Цикл
		
		ИмяПодсистемы = КлючИЗначение.Ключ;
		
		Если ЗначениеЗаполнено(ИмяПодсистемыИзПараметров) И ИмяПодсистемыИзПараметров <> ИмяПодсистемы Тогда
			Продолжить;
		КонецЕсли;
		
		ИмяПоляФормы = ИнтеграцияИСКлиентСервер.ИмяПоляИнтеграцииВФормеДокументаОснования(ИмяПодсистемы);
		
		Если Форма.Элементы.Найти(ИмяПоляФормы) = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		// Получим текст надписи на форме.
		ТекстНадписи = "";
		Если ПодсистемаСуществует(ИмяПодсистемы) Тогда
			
			МодульИнтеграции = ОбщийМодуль(ИмяПодсистемы);
			ТекстНадписи = МодульИнтеграции.ТекстНадписиПоляИнтеграцииВФормеДокументаОснования(Форма, Объект);
			
		КонецЕсли;
		
		Форма[ИмяПоляФормы] = ТекстНадписи;
		Форма.Элементы[ИмяПоляФормы].Видимость = ЗначениеЗаполнено(ТекстНадписи);
		
	КонецЦикла;
	
КонецПроцедуры

#КонецОбласти

#Область ФормыДокументовИС

Процедура ПослеЗаписиНаСервереВФормеОбъектаДокументаИС(Форма, Объект, ИмяПодсистемы, ПараметрыЗаписи) Экспорт
	
	Если Объект.ДополнительныеСвойства.Свойство("ПредыдущийДокументОснование") Тогда
		
		// Заполняется в подписке РассчитатьСтатусОформленияВЕТИСПередЗаписьюДокумента
		ПараметрыЗаписи.Вставить(
			"ПредыдущийДокументОснование",
			Объект.ДополнительныеСвойства.ПредыдущийДокументОснование);
		
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти

#Область ДокументыИС

// Функция возвращает оформленные документы по документу-основанию
//   * в документе должен быть реквизит "ДокументОснование"
//   * допустимый тип документа определяется из регистра статусов
// Параметры:
//  ДокументОснование					 - ДокументСсылка   - значение реквизита "ДокументОснование"
//  МетаданныеРегистраСтатусовДокументов - ОбъектМетаданных - используемый регистр статусов документов
//   * Должен содержать измерение "Документ"
//   * Должен содержать поле "Статус"
// Возвращаемое значение:
//  Структура - описание документов по основанию с полями
//   * [ИмяДокумента] - имя метаданных оформленного документа - массив структур с полями:
//     ** Ссылка - [ИмяДокумента]Ссылка - ссылка на оформленный документ
//     ** Дата   - Дата                 - дата документа
//     ** Статус - Произвольный         - статус документа по регистру
//
Функция ДокументыИСПоДокументуОснованию(ДокументОснование, МетаданныеРегистраСтатусовДокументов) Экспорт
	
	ДокументыИС = Новый Структура;
	
	ИмяРегистра = МетаданныеРегистраСтатусовДокументов.Имя;
	МассивТекстов = Новый Массив;
	
	ШаблонВыборки =
	"ВЫБРАТЬ
	|	""%1""									КАК ИмяДокумента,
	|	Таблица.Ссылка							КАК Ссылка,
	|	Таблица.Дата							КАК Дата,
	|	ЕСТЬNULL(Статусы.Статус, НЕОПРЕДЕЛЕНО) 	КАК Статус
	|ИЗ
	|	Документ.%1 КАК Таблица
	|	ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.%2 КАК Статусы
	|		ПО Статусы.Документ = Таблица.Ссылка
	|ГДЕ
	|	Таблица.ДокументОснование = &ДокументОснование
	|	И НЕ Таблица.ПометкаУдаления";
	
	ШаблонОбъединения = "
	|
	|ОБЪЕДИНИТЬ ВСЕ
	|
	|";
	
	Для Каждого ТипДокумента Из МетаданныеРегистраСтатусовДокументов.Измерения.Документ.Тип.Типы() Цикл
		
		МетаданныеДокумента = Метаданные.НайтиПоТипу(ТипДокумента);
		
		Если РеквизитДокументОснованиеДокументаИС(МетаданныеДокумента) = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		ДокументыИС.Вставить(МетаданныеДокумента.Имя, Новый Массив);
		МассивТекстов.Добавить(СтрШаблон(ШаблонВыборки,МетаданныеДокумента.Имя,ИмяРегистра));
		
	КонецЦикла;
	
	Если НЕ ЗначениеЗаполнено(ДокументОснование) Тогда
		Возврат ДокументыИС;
	ИначеЕсли ДокументыИС.Количество() = 0 Тогда 
		Возврат ДокументыИС;
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.Текст = СтрСоединить(МассивТекстов,ШаблонОбъединения);
	Запрос.УстановитьПараметр("ДокументОснование", ДокументОснование);
	
	УстановитьПривилегированныйРежим(Истина);
	Выборка = Запрос.Выполнить().Выбрать();
	УстановитьПривилегированныйРежим(Ложь);
	
	Пока Выборка.Следующий() Цикл
		
		ОписаниеДокумента = Новый Структура("Ссылка, Дата, Статус");
		ЗаполнитьЗначенияСвойств(ОписаниеДокумента, Выборка);
		
		ДокументыИС[Выборка.ИмяДокумента].Добавить(ОписаниеДокумента);
		
	КонецЦикла;
	
	Возврат ДокументыИС;
	
КонецФункции

#КонецОбласти

#Область МетаданныеИС

Функция РеквизитДокументОснованиеДокументаИС(МетаданныеДокумента) Экспорт
	
	Возврат МетаданныеДокумента.Реквизиты.Найти("ДокументОснование");
	
КонецФункции

// Возвращает значение по умолчанию переданного определяемого типа.
//
Функция ПустоеЗначениеОпределяемогоТипа(ИмяТипа) Экспорт
	
	Возврат Метаданные.ОпределяемыеТипы[ИмяТипа].Тип.ПривестиЗначение();
	
КонецФункции

// Формирует массив пустых значений определяемого типа.
// 
// Возвращаемое значение:
//  Массив - Пустые значения определяемого типа.
//
Функция НезаполненныеЗначенияОпределяемогоТипа(ОпределяемыйТипИлиИмяТипа) Экспорт
	
	Если ТипЗнч(ОпределяемыйТипИлиИмяТипа) = Тип("Строка") Тогда
		ОпределяемыйТип = Метаданные.ОпределяемыеТипы[ОпределяемыйТипИлиИмяТипа];
	Иначе
		ОпределяемыйТип = ОпределяемыйТипИлиИмяТипа;
	КонецЕсли;
	
	МассивПустыхЗначений = Новый Массив;
	Для Каждого ТипЗначения Из ОпределяемыйТип.Тип.Типы() Цикл
		МассивТипов = Новый Массив;
		МассивТипов.Добавить(ТипЗначения);
		ОписаниеТипа = Новый ОписаниеТипов(МассивТипов);
		МассивПустыхЗначений.Добавить(ОписаниеТипа.ПривестиЗначение());
	КонецЦикла;
	
	Если МассивПустыхЗначений.Количество() > 1 Тогда
		МассивПустыхЗначений.Добавить(Неопределено);
	КонецЕсли;
	
	Возврат МассивПустыхЗначений;
	
КонецФункции

// Проверяет наличие права изменения документов определяемого типа у текущего пользователя.
//
// Возвращаемое значение:
//  Булево - Истина, если есть право изменения хотя бы одного документа, Ложь в обратном случае.
//
Функция ПравоИзмененияДокументовИзОпределяемогоТипа(ОпределяемыйТип) Экспорт

	Для Каждого ВозможныйТип Из ОпределяемыйТип.Тип.Типы() Цикл
		МетаданныеТипа = Метаданные.НайтиПоТипу(ВозможныйТип);
		Если МетаданныеТипа <> Неопределено Тогда
			Если ПравоДоступа("Изменение", МетаданныеТипа) Тогда
				Возврат Истина;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Ложь;

КонецФункции

Функция ПодсистемаСуществует(КраткоеИмяПодсистемы)
	
	ПолноеИмяПодсистемы = ИнтеграцияИСКлиентСервер.ПолноеИмяПодсистемы(КраткоеИмяПодсистемы);
	Возврат ОбщегоНазначения.ПодсистемаСуществует(ПолноеИмяПодсистемы);
	
КонецФункции

Функция ОбщийМодуль(КраткоеИмяПодсистемы)
	
	ИмяМодуля = ИнтеграцияИСКлиентСервер.МодульСервер(КраткоеИмяПодсистемы);
	Возврат ОбщегоНазначения.ОбщийМодуль(ИмяМодуля);
	
КонецФункции

#КонецОбласти

#Область ПодготовкаИЗаписьДвиженийДокумента

// Процедура инициализирует общие структуры, используемые при проведении документов.
// Вызывается из модуля документов при проведении.
//
Процедура ИнициализироватьДополнительныеСвойстваДляПроведения(ДокументСсылка, ДополнительныеСвойства, РежимПроведения = Неопределено) Экспорт

	// В структуре "ДополнительныеСвойства" создаются свойства с ключами "ТаблицыДляДвижений", "ДляПроведения".

	// "ТаблицыДляДвижений" - структура, которая будет содержать таблицы значений с данными для выполнения движений.
	ДополнительныеСвойства.Вставить("ТаблицыДляДвижений", Новый Структура);

	// "ДляПроведения" - структура, содержащая свойства и реквизиты документа, необходимые для проведения.
	ДополнительныеСвойства.Вставить("ДляПроведения", Новый Структура);
	
	// Структура, содержащая ключ с именем "МенеджерВременныхТаблиц", в значении которого хранится менеджер временных таблиц.
	// Содержит для каждой временной таблицы ключ (имя временной таблицы) и значение (признак наличия записей во временной таблице).
	ДополнительныеСвойства.ДляПроведения.Вставить("СтруктураВременныеТаблицы", Новый Структура("МенеджерВременныхТаблиц", Новый МенеджерВременныхТаблиц));
	ДополнительныеСвойства.ДляПроведения.Вставить("РежимПроведения",           РежимПроведения);
	ДополнительныеСвойства.ДляПроведения.Вставить("МетаданныеДокумента",       ДокументСсылка.Метаданные());
	ДополнительныеСвойства.ДляПроведения.Вставить("Ссылка",                    ДокументСсылка);
	
КонецПроцедуры

// Процедура выполняет подготовку наборов записей документа к записи движений.
// 1. Очищает наборы записей от "старых записей" (ситуация возможна только в толстом клиенте)
// 2. Взводит флаг записи у наборов, по которым документ имеет движения
// Вызывается из модуля документов при проведении.
//
Процедура ПодготовитьНаборыЗаписейКРегистрацииДвижений(Объект, ЭтоНовый = Ложь) Экспорт
	Перем ЭтоНовыйДокумент, МетаданныеДвижения;
	
	Для Каждого НаборЗаписей Из Объект.Движения Цикл

		Если НаборЗаписей.Количество() > 0 Тогда
			НаборЗаписей.Очистить();
		КонецЕсли;

	КонецЦикла;
	
	Если НЕ Объект.ДополнительныеСвойства.Свойство("ЭтоНовый", ЭтоНовыйДокумент) Тогда
		ЭтоНовыйДокумент = ЭтоНовый;
	КонецЕсли;
	
	Если НЕ ЭтоНовыйДокумент Тогда

		Если Объект.ДополнительныеСвойства.Свойство("ДляПроведения")
		 И Объект.ДополнительныеСвойства.ДляПроведения.Свойство("МетаданныеДокумента") Тогда
			МетаданныеДвижения = Объект.ДополнительныеСвойства.ДляПроведения.МетаданныеДокумента.Движения;
		Иначе
			МетаданныеДвижения = Объект.Метаданные().Движения;
		КонецЕсли;
		
		МассивИменРегистров = ПолучитьИспользуемыеРегистры(Объект.Ссылка, МетаданныеДвижения);

		Для Каждого ИмяРегистра Из МассивИменРегистров Цикл
			Объект.Движения[ИмяРегистра].Записывать = Истина;
		КонецЦикла;

	КонецЕсли;

КонецПроцедуры

// Функция формирует массив имен регистров, по которым документ имеет движения.
// Вызывается при подготовке записей к регистрации движений.
//
Функция ПолучитьИспользуемыеРегистры(Регистратор, Движения, МассивИсключаемыхРегистров = Неопределено) Экспорт

	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Регистратор", Регистратор);

	Результат = Новый Массив;
	МаксимумТаблицВЗапросе = 256;

	СчетчикТаблиц   = 0;
	СчетчикДвижений = 0;

	ВсегоДвижений = Движения.Количество();
	МассивТекстаЗапроса = Новый Массив;
	
	Разделитель = 
	"
	|
	|ОБЪЕДИНИТЬ ВСЕ
	|";
	
	Для Каждого Движение Из Движения Цикл

		СчетчикДвижений = СчетчикДвижений + 1;

		ПропуститьРегистр = МассивИсключаемыхРегистров <> Неопределено
							И МассивИсключаемыхРегистров.Найти(Движение.Имя) <> Неопределено;

		Если Не ПропуститьРегистр Тогда

			СчетчикТаблиц = СчетчикТаблиц + 1;

			МассивТекстаЗапроса.Добавить(
			"
			|ВЫБРАТЬ ПЕРВЫЕ 1
			|""" + Движение.Имя + """ КАК ИмяРегистра
			|
			|ИЗ " + Движение.ПолноеИмя() + "
			|
			|ГДЕ Регистратор = &Регистратор
			|");

		КонецЕсли;

		Если СчетчикТаблиц = МаксимумТаблицВЗапросе Или СчетчикДвижений = ВсегоДвижений Тогда

			Запрос.Текст = СтрСоединить(МассивТекстаЗапроса, Разделитель);
			МассивТекстаЗапроса.Очистить();
			
			СчетчикТаблиц = 0;

			Если Результат.Количество() = 0 Тогда

				Результат = Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("ИмяРегистра");

			Иначе

				Выборка = Запрос.Выполнить().Выбрать();
				Пока Выборка.Следующий() Цикл
					Результат.Добавить(Выборка.ИмяРегистра);
				КонецЦикла;

			КонецЕсли;
		КонецЕсли;
	КонецЦикла;

	Возврат Результат;

КонецФункции

// Процедура записывает движения документа. Дополнительно происходит копирование параметров
// в модули наборов записей для выполнения регистрации изменений в движениях.
// Процедура вызывается из модуля документов при проведении.
//
Процедура ЗаписатьНаборыЗаписей(Объект) Экспорт
	Перем РегистрыДляКонтроля, РассчитыватьИзменения;
	
	Для Каждого Движение Из Объект.Движения Цикл
		
		Движение.ДополнительныеСвойства.Вставить("ЭтоНовый", Объект.ДополнительныеСвойства.ЭтоНовый);
		Движение.ДополнительныеСвойства.Вставить("РежимЗаписи", Объект.ДополнительныеСвойства.РежимЗаписи);
		Движение.ДополнительныеСвойства.Вставить("ДатаРегистратора", Объект.Дата);
		
		Движение.ДополнительныеСвойства.Вставить("ДляПроведения", 
			Новый Структура("СтруктураВременныеТаблицы",
				// Структура для передачи данных в модули наборов записей.
				Объект.ДополнительныеСвойства.ДляПроведения.СтруктураВременныеТаблицы));
		
	КонецЦикла;
	
	// Регистры, для которых будут рассчитаны таблицы изменений движений.
	Если Объект.ДополнительныеСвойства.ДляПроведения.Свойство("РегистрыДляКонтроля", РегистрыДляКонтроля) Тогда
		
		// Установка флага регистрации изменений в наборе записей.
		Если НЕ Объект.ДополнительныеСвойства.Свойство("РассчитыватьИзменения", РассчитыватьИзменения) Тогда
			РассчитыватьИзменения = Истина;
		КонецЕсли;
		
		Для Каждого НаборЗаписей Из РегистрыДляКонтроля Цикл
			Если НаборЗаписей.Записывать Тогда
				
				НаборЗаписей.ДополнительныеСвойства.Вставить("РассчитыватьИзменения", РассчитыватьИзменения);
				
			КонецЕсли;
		КонецЦикла;

	КонецЕсли;
	
	Объект.Движения.Записать();
	
КонецПроцедуры

// Выполняет закрытие менеджера временных таблиц в структуре дополнительных свойств документа, используемых 
// при проведении.
//
// Параметры:
//	ДополнительныеСвойства - Структура - структура с дополнительными свойствами документа, используемыми
//		при проведении.
//
Процедура ОчиститьДополнительныеСвойстваДляПроведения(ДополнительныеСвойства) Экспорт

	ДополнительныеСвойства.ДляПроведения.СтруктураВременныеТаблицы.МенеджерВременныхТаблиц.Закрыть();

КонецПроцедуры

#КонецОбласти

#Область ПрисоединенныеФайлы

// Получает текст сообщения XML из присоединенного файла, в котором хранится сообщение протокола обмена.
//
// Параметры:
//  Сообщение - ОпределяемыйТип.ПрисоединенныйФайл, Строка - хранимый файл сообщения, из которого извлекается текст сообщения XML.
// 
// Возвращаемое значение:
//  Строка - полученный текст сообщения XML.
//
Функция ТекстСообщенияXMLИзПротокола(Сообщение) Экспорт
	
	Если ТипЗнч(Сообщение) = Тип("Строка") Тогда
		Возврат Сообщение;
	КонецЕсли;
	
	ДвоичныеДанные = РаботаСФайлами.ДвоичныеДанныеФайла(Сообщение);
	Если ДвоичныеДанные = Неопределено Тогда
		Возврат "";
	КонецЕсли;
	
	ИмяВременногоФайла = ПолучитьИмяВременногоФайла();
	ДвоичныеДанные.Записать(ИмяВременногоФайла);
	
	ТекстовыйДокумент = Новый ТекстовыйДокумент;
	ТекстовыйДокумент.Прочитать(ИмяВременногоФайла, КодировкаТекста.UTF8, "");
	ТекстСообщенияXML = ТекстовыйДокумент.ПолучитьТекст();
	
	Попытка
		УдалитьФайлы(ИмяВременногоФайла);
	Исключение
		ИнтеграцияИСВызовСервера.ЗаписатьОшибкуВЖурналРегистрации(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
	КонецПопытки;
	
	Возврат ТекстСообщенияXML;
	
КонецФункции

// Добавить запись в протокол обмена.
//
// Параметры:
//   Протокол              - ОбъектМетаданныхСправочник - протокол обмена
//   ТекстСообщенияXML     - Строка                     - Текст сообщения XML.
//   Реквизиты - Структура                              - Значения реквизитов сообщения, с обязательными полями:
//    * Документ       - документ по которому ведется протокол обмена,
//    * ВладелецФайлов - элемент по которому ведется обмен с ГосИС.
//   ПроверятьХешБезСсылки - Булево                     - Признак проверки хеша без ссылки.
// 
// Возвращаемое значение:
//   Структура - Структура со свойствами:
//    * НовоеСообщение - Булево - Это новое сообщение.
//    * Ссылка - СправочникСсылка[Протокол.Имя] - Ссылка на присоединенный файл.
//
Функция ДобавитьЗаписьВПротоколОбмена(Протокол, ТекстСообщенияXML, Реквизиты, ПроверятьХешБезСсылки) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	ХешированиеДанныхОбъект = Новый ХешированиеДанных(ХешФункция.SHA256);
	ХешированиеДанныхОбъект.Добавить(ТекстСообщенияXML);
	ХешСуммаBase64 = Base64Строка(ХешированиеДанныхОбъект.ХешСумма);
	
	Если ПроверятьХешБезСсылки Тогда
		
		Запрос = Новый Запрос(
		"ВЫБРАТЬ ПЕРВЫЕ 1
		|	Протокол.Ссылка КАК Ссылка,
		|	Протокол.Документ КАК Документ
		|ИЗ
		|	&Протокол КАК Протокол
		|ГДЕ
		|	Протокол.ХешСумма = &ХешСумма
		|	И Протокол.Документ ССЫЛКА &ИмяТаблицы");
		
		Запрос.Текст = СтрЗаменить(Запрос.Текст, "&Протокол",   Протокол.ПолноеИмя());
		Запрос.Текст = СтрЗаменить(Запрос.Текст, "&ИмяТаблицы", Реквизиты.Документ.Метаданные().ПолноеИмя());
		Запрос.УстановитьПараметр("ХешСумма", ХешСуммаBase64);
		
	Иначе
		
		СообщениеОснование = Справочники[Протокол.Имя].ПустаяСсылка();
		Если Реквизиты.Свойство("СообщениеОснование") Тогда
			СообщениеОснование = Реквизиты.СообщениеОснование;
		КонецЕсли;
		
		Запрос = Новый Запрос(
		"ВЫБРАТЬ ПЕРВЫЕ 1
		|	Протокол.Ссылка КАК Ссылка,
		|	Протокол.Документ КАК Документ
		|ИЗ
		|	&Протокол КАК Протокол
		|ГДЕ
		|	Протокол.Документ = &Документ
		|	И Протокол.СообщениеОснование = &СообщениеОснование
		|	И Протокол.ХешСумма = &ХешСумма");
		
		Запрос.Текст = СтрЗаменить(Запрос.Текст, "&Протокол",   Протокол.ПолноеИмя());
		Запрос.УстановитьПараметр("Документ",           Реквизиты.Документ);
		Запрос.УстановитьПараметр("ХешСумма",           ХешСуммаBase64);
		Запрос.УстановитьПараметр("СообщениеОснование", СообщениеОснование);
		
	КонецЕсли;
	
	Результат = Запрос.Выполнить();
	Выборка = Результат.Выбрать();
	
	ДокументОснование = Неопределено;
	
	Если Выборка.Следующий() Тогда
		
		НовоеСообщение = Ложь;
		
		Ссылка   = Выборка.Ссылка;
		Документ = Выборка.Документ;
		
		Если ЗначениеЗаполнено(Выборка.Документ)
			И Выборка.Документ.Метаданные().Реквизиты.Найти("ДокументОснование") <> Неопределено Тогда
			ДокументОснование = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(Выборка.Документ, "ДокументОснование");
		КонецЕсли;
		
	Иначе
		
		НовоеСообщение = Истина;
		
		ИмяВременногоФайла = ПолучитьИмяВременногоФайла();
		ТекстовыйДокумент = Новый ТекстовыйДокумент;
		ТекстовыйДокумент.УстановитьТекст(ТекстСообщенияXML);
		ТекстовыйДокумент.Записать(ИмяВременногоФайла, КодировкаТекста.UTF8, "");
		ДвоичныеДанные = Новый ДвоичныеДанные(ИмяВременногоФайла);
		АдресФайлаВоВременномХранилище = ПоместитьВоВременноеХранилище(ДвоичныеДанные);
		
		Попытка
			УдалитьФайлы(ИмяВременногоФайла);
		Исключение
			ИнтеграцияИСВызовСервера.ЗаписатьОшибкуВЖурналРегистрации(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		КонецПопытки;
		
		ПараметрыФайла = Новый Структура();
		ПараметрыФайла.Вставить("Автор",              Пользователи.АвторизованныйПользователь());
		ПараметрыФайла.Вставить("ВладелецФайлов",     Реквизиты.ВладелецФайлов);
		ПараметрыФайла.Вставить("ИмяБезРасширения",   Строка(Новый УникальныйИдентификатор));
		ПараметрыФайла.Вставить("РасширениеБезТочки", "xml");
		ПараметрыФайла.Вставить("ВремяИзмененияУниверсальное");
		
		ПрисоединенныйФайл = РаботаСФайлами.ДобавитьФайл(
			ПараметрыФайла,
			АдресФайлаВоВременномХранилище,,,
			Справочники[Протокол.Имя].ПолучитьСсылку());
		
		ПрисоединенныйФайлОбъект = ПрисоединенныйФайл.ПолучитьОбъект();
		ПрисоединенныйФайлОбъект.ХешСумма = ХешСуммаBase64;
		
		ЗаполнитьЗначенияСвойств(ПрисоединенныйФайлОбъект, Реквизиты);
		
		ПрисоединенныйФайлОбъект.Записать();
		
		Ссылка   = ПрисоединенныйФайлОбъект.Ссылка;
		Документ = ПрисоединенныйФайлОбъект.Документ;
		
	КонецЕсли;
	
	ВозвращаемоеЗначение = Новый Структура;
	ВозвращаемоеЗначение.Вставить("НовоеСообщение",    НовоеСообщение);
	ВозвращаемоеЗначение.Вставить("Ссылка",            Ссылка);
	ВозвращаемоеЗначение.Вставить("Документ",          Документ);
	ВозвращаемоеЗначение.Вставить("ДокументОснование", ДокументОснование);
	
	Возврат ВозвращаемоеЗначение;
	
КонецФункции

// Вызывает исключение при открытии формы протокола обмена с незаполненным параметром "Документ"
//  (форма предназначается для просмотра протокола обмена по конкретному объекту)
// Параметры:
//  Форма - УправляемаяФорма - форма протокола обмена
//
Процедура ОтработатьВходящийДокументПротоколаОбмена(Форма) Экспорт
	
	Если ЗначениеЗаполнено(Форма.Параметры.Документ) Тогда
		Форма.Документ = Форма.Параметры.Документ;
	Иначе
		ВызватьИсключение НСтр("ru = 'Протокол обмена может быть открыт только в контексте документа.'");
	КонецЕсли;
	
КонецПроцедуры

// Устанавливает типовое условное оформление протокола обмена
//
// Параметры:
//  Форма	 - УправляемаяФорма - форма протокола обмена
//
Процедура УстановитьУсловноеОформлениеПротоколаОбмена(Форма) Экспорт
	
	УсловноеОформление = Форма.УсловноеОформление;
	Элементы = Форма.Элементы;
	
	УсловноеОформление.Элементы.Очистить();
	
#Область ДеревоЗачеркнутый
	
	Элемент = УсловноеОформление.Элементы.Добавить();
	
	ПолеЭлемента = Элемент.Поля.Элементы.Добавить();
	ПолеЭлемента.Поле = Новый ПолеКомпоновкиДанных(Элементы.ДеревоФайловПредставление.Имя);
	
	ОтборЭлемента = Элемент.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	ОтборЭлемента.ЛевоеЗначение  = Новый ПолеКомпоновкиДанных("ДеревоФайлов.УсловноеОформление");
	ОтборЭлемента.ВидСравнения   = ВидСравненияКомпоновкиДанных.Равно;
	ОтборЭлемента.ПравоеЗначение = "УсловноеОформлениеЗачеркнутый";
	
	Элемент.Оформление.УстановитьЗначениеПараметра("Шрифт", Новый Шрифт(,,,,,Истина));
	
#КонецОбласти

#Область ДеревоСерый

	Элемент = УсловноеОформление.Элементы.Добавить();
	
	ПолеЭлемента = Элемент.Поля.Элементы.Добавить();
	ПолеЭлемента.Поле = Новый ПолеКомпоновкиДанных(Элементы.ДеревоФайловПредставление.Имя);
	
	ОтборЭлемента = Элемент.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	ОтборЭлемента.ЛевоеЗначение  = Новый ПолеКомпоновкиДанных("ДеревоФайлов.УсловноеОформление");
	ОтборЭлемента.ВидСравнения   = ВидСравненияКомпоновкиДанных.Равно;
	ОтборЭлемента.ПравоеЗначение = "УсловноеОформлениеСерый";
	
	Элемент.Оформление.УстановитьЗначениеПараметра("ЦветТекста", ЦветаСтиля.ЦветТекстаНеТребуетВниманияГосИС);
	
#КонецОбласти

#Область ДеревоЖирный

	Элемент = УсловноеОформление.Элементы.Добавить();

	ПолеЭлемента = Элемент.Поля.Элементы.Добавить();
	ПолеЭлемента.Поле = Новый ПолеКомпоновкиДанных(Элементы.ДеревоФайловПредставление.Имя);

	ОтборЭлемента = Элемент.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	ОтборЭлемента.ЛевоеЗначение  = Новый ПолеКомпоновкиДанных("ДеревоФайлов.УсловноеОформление");
	ОтборЭлемента.ВидСравнения   = ВидСравненияКомпоновкиДанных.Равно;
	ОтборЭлемента.ПравоеЗначение = "УсловноеОформлениеЖирный";

	Элемент.Оформление.УстановитьЗначениеПараметра("Шрифт", Новый Шрифт(,,Истина));
	
#КонецОбласти

#Область ДеревоОтказ
	
	Элемент = УсловноеОформление.Элементы.Добавить();
	
	ПолеЭлемента = Элемент.Поля.Элементы.Добавить();
	ПолеЭлемента.Поле = Новый ПолеКомпоновкиДанных(Элементы.ДеревоФайловПредставление.Имя);
	
	ОтборЭлемента = Элемент.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	ОтборЭлемента.ЛевоеЗначение  = Новый ПолеКомпоновкиДанных("ДеревоФайлов.УсловноеОформление");
	ОтборЭлемента.ВидСравнения   = ВидСравненияКомпоновкиДанных.Равно;
	ОтборЭлемента.ПравоеЗначение = "УсловноеОформлениеОшибка";
	
	Элемент.Оформление.УстановитьЗначениеПараметра("ЦветТекста", ЦветаСтиля.СтатусОбработкиОшибкаПередачиГосИС);
	
#КонецОбласти

#Область ДатаНеПередана
	
	СтандартныеПодсистемыСервер.УстановитьУсловноеОформлениеПоляДата(Форма, "ДеревоФайлов.Дата", Элементы.ДеревоФайловДата.Имя);
	
	// Представление даты "<не передано>"
	ЭлементУсловногоОформления = УсловноеОформление.Элементы.Добавить();
	ЭлементУсловногоОформления.Использование = Истина;
	
	ПолеЭлемента = ЭлементУсловногоОформления.Поля.Элементы.Добавить();
	ПолеЭлемента.Поле = Новый ПолеКомпоновкиДанных("ДеревоФайловДата");
	
	ПредставлениеЭлемента = НСтр("ru = 'Представление даты ""<не передано>""'");
	ЭлементУсловногоОформления.Представление = ПредставлениеЭлемента;
	
	ЭлементОтбораДанных = ЭлементУсловногоОформления.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	ЭлементОтбораДанных.ЛевоеЗначение = Новый ПолеКомпоновкиДанных("ДеревоФайлов.Дата");
	ЭлементОтбораДанных.ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
	ЭлементОтбораДанных.ПравоеЗначение = '00010101';
	ЭлементОтбораДанных.Использование = Истина;
	
	ЭлементУсловногоОформления.Оформление.УстановитьЗначениеПараметра("Текст", НСтр("ru = '<не передано>'"));
	ЭлементУсловногоОформления.Оформление.УстановитьЗначениеПараметра("ЦветТекста", ЦветаСтиля.ЦветТекстаНеТребуетВниманияГосИС);
	
#КонецОбласти

КонецПроцедуры

// Возвращает индекс картинки запроса в коллекции "ПротоколОбменаИС"
//
// Параметры:
//  СтрокаПоследовательности - Произвольный - коллекция с типом запроса (входящий, исходящий)
//  НеВыполнен				 - Булево - серые стрелки (по умолчанию Ложь)
// 
// Возвращаемое значение:
//  Число - индекс соответствующей картинки запроса
//
Функция ИндексКартинкиЗапроса(СтрокаПоследовательности, НеВыполнен = Ложь) Экспорт
	
	ИндексКартинки = 0;
	
	Смещение = 0;
	Если НеВыполнен Тогда
		Смещение = 6;
	КонецЕсли;
	
	Если СтрокаПоследовательности = Неопределено Тогда
	ИначеЕсли СтрокаПоследовательности.ТипСообщения = Перечисления.ТипыЗапросовИС.Исходящий Тогда
		ИндексКартинки = 1 + Смещение;
	ИначеЕсли СтрокаПоследовательности.ТипСообщения = Перечисления.ТипыЗапросовИС.Входящий Тогда
		ИндексКартинки = 2 + Смещение;
	КонецЕсли;
	
	Возврат ИндексКартинки;
	
КонецФункции

#КонецОбласти


#КонецОбласти

#Область СлужебныйПрограммныйИнтерфейс

#Область РаботаСXDTO

// Функция - Данные для расшифровки ошибок
//
// Параметры:
//  ИмяМакета - Строка - макет в котором искать описание ошибки
//  Глубина   - Число  - уровень вложенности ошибки в макете
// 
// Возвращаемое значение:
//  Структура - из переданных параметров
//
Функция ДанныеДляРасшифровкиОшибок(ИмяМакета = Неопределено, Глубина = Неопределено) Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("ИмяМакета", ИмяМакета);
	Результат.Вставить("Глубина",   Глубина);
	Результат.Вставить("Таблица",   Неопределено);
	Возврат Результат;
	
КонецФункции

#КонецОбласти

#Область РаботаСЧасовымиПоясами

// Формирует представление даты с часовым поясом.
//
// Параметры:
//  Дата        - ДатаВремя - дата, для которой нужно вывести представление.
//  ЧасовойПояс - Строка - идентификатор часового пояса.
// 
// Возвращаемое значение:
//  Строка - представление даты с часовым поясом.
//
Функция ДатаСЧасовымПоясом(Дата, Знач ЧасовойПояс = Неопределено) Экспорт
	
	Если ЧасовойПояс = Неопределено Тогда
		ЧасовойПояс = ЧасовойПоясСеанса();
	КонецЕсли;
	
	Смещение = (Дата - УниверсальноеВремя(Дата, ЧасовойПояс)) / 3600;
	Если Смещение > 0 Тогда
		Результат = Формат(Дата, "ДФ=yyyy-MM-ddTЧЧ:мм:сс") + "+" + Формат(+Смещение, "ЧЦ=2; ЧН=; ЧВН=") + ":00";
	Иначе
		Результат = Формат(Дата, "ДФ=yyyy-MM-ddTЧЧ:мм:сс") + "-" + Формат(-Смещение, "ЧЦ=2; ЧН=; ЧВН=") + ":00";
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Формирует представление даты в формате Coordinated Universal Time
//
// Параметры:
//  Дата - ДатаВремя - дата, представление которой необходимо получить.
// 
// Возвращаемое значение:
//  Строка - представление даты в формате Coordinated Universal Time(UTC).
//
Функция ДатаUTC(Дата) Экспорт
	
	Результат = Формат(Дата, "ДФ=yyyy-MM-ddTЧЧ:мм:сс") + "Z";
	
	Возврат Результат;
	
КонецФункции

// Возвращает временную дату, которая будет в дальнейшем преобразована в дату с часовым поясом.
//
// Параметры:
//  Дата - Дата - Дата для преобразования.
// 
// Возвращаемое значение:
//  Дата - Временная дата
//
Функция ВременнаяДата(Дата) Экспорт
	
	Возврат ДобавитьМесяц(Дата, -12 * 1000);
	
КонецФункции

// Устанавливает в ОбъектXDTO вместо даты со смещением временную дату. В дальнейшем временная дата будет заменена датой
// со смещением в результирующем ХМL. Тем самым обходится ограничение ОбъектXDTO, который не позволяет устанавливать в
// свойство дату со смещением.
//
// Параметры:
//  ОбъектXDTO            - ОбъектXDTO - в свойство данного объекта помещается дата.
//  ИмяСвойства           - ИмяСвойства - имя свойства, в которое устанавливается дата.
//  Дата                  - ДатаВремя - дата, которая устанавливается в свойство.
//  ХранилищеВременныхДат - Соответствие - в нем хранится соответствие временных дат и дат со смещением.
//
Процедура УстановитьДатуСЧасовымПоясом(ОбъектXDTO, ИмяСвойства, Дата, ХранилищеВременныхДат) Экспорт
	
	ДатаСЧасовымПоясом = ДатаСЧасовымПоясом(Дата);
	
	ВременнаяДатаUTC = ДатаUTC(ВременнаяДата(Дата));
	
	ОбъектXDTO[ИмяСвойства] = ВременнаяДатаUTC;
	ЛексическоеЗначениеВременнойДаты = ОбъектXDTO.ПолучитьXDTO(ИмяСвойства).ЛексическоеЗначение;
	
	ХранилищеВременныхДат.Вставить(ЛексическоеЗначениеВременнойДаты, ДатаСЧасовымПоясом);
	
КонецПроцедуры

// Заменяет временные даты в тексте сообщения в формате XML на даты со смещением, согласно соответствию.
//
// Параметры:
//  ХранилищеВременныхДат - Соответствие - хранит временные даты, которые нужно заменить на даты со смещением
//  ТекстСообщенияXML     - Строка - текст сообщения, в котором выполняется замена.
// 
// Возвращаемое значение:
//  Строка - ТекстСообщенияXML, в котором выполнена замена.
//
Функция ПреобразоватьВременныеДаты(ХранилищеВременныхДат, Знач ТекстСообщенияXML) Экспорт
	
	Текст = ТекстСообщенияXML;
	
	Для Каждого КлючИЗначение Из ХранилищеВременныхДат Цикл
		
		ВременнаяДата = КлючИЗначение.Ключ;
		Дата = КлючИЗначение.Значение;
		
		Текст = СтрЗаменить(Текст, ВременнаяДата, Дата);
		
	КонецЦикла;
	
	Возврат Текст;
	
КонецФункции

#КонецОбласти

#Область ПроцедурыИФункцииДляПечати

// Функция раскладывает переданный массив ссылок в соответствие по типам этих ссылок.
//
//	Параметры:
//		МассивСсылок - Массив - массив ссылок на объекты информационной базы
//  Возвращаемое значение:
//		Соответствие:
//			Ключ - полное имя типа ссылки
//	        Значение - массив ссылок этого типа.
//
Функция СоответствиеМассивовПоТипамОбъектов(МассивСсылок) Экспорт
	
	СоответствиеТипов = Новый Соответствие;
	
	Для Каждого Объект Из МассивСсылок Цикл
		
		ТипОбъекта = Объект.Метаданные().ПолноеИмя();
		ТекущийТипОбъекта = СоответствиеТипов.Получить(ТипОбъекта);
		
		Если ТекущийТипОбъекта = Неопределено Тогда
			СоответствиеТипов.Вставить(ТипОбъекта, Новый Массив);
			ТекущийТипОбъекта = СоответствиеТипов.Получить(ТипОбъекта);
		КонецЕсли;
		ТекущийТипОбъекта.Добавить(Объект);
		
	КонецЦикла;
	
	Возврат СоответствиеТипов;
	
КонецФункции

#КонецОбласти

#Область ОбщиеПредставления

// Заполняет представление регламентного задания (реквизиты ЗаданиеАктивно, ТекстРасписания)
//
// Параметры:
//  Задание				 - РегламентноеЗадание, Неопределено - регламентное задание представление которого необходимо получить
//  ТекстРасписания		 - Строка - представление расписания (выходной)
//  РасписаниеАктивно	 - Булево - использование задания (выходной)
//
Процедура ПолучитьТекстЗаголовкаИРасписанияРегламентнойНастройки(Задание, ТекстРасписания, РасписаниеАктивно) Экспорт
	
	РасписаниеАктивно = Ложь;
	
	Если Задание = Неопределено Тогда
		
		ТекстРасписания = НСтр("ru = '<Расписание не задано>'");
		
	Иначе
		
		Если Задание.Использование Тогда
			РасписаниеАктивно = Истина;
			ТекстРасписания = СтрШаблон(НСтр("ru = 'Расписание: %1'"), Строка(Задание.Расписание));
		Иначе
			ТекстРасписания = СтрШаблон(НСтр("ru = 'Расписание (НЕ АКТИВНО): %1'"), Строка(Задание.Расписание));
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти

#Область ФункцииИспользующиеПереопределение

#Область Номенклатура

Функция ПредставлениеНоменклатуры(Номенклатура, Характеристика, Упаковка = Неопределено, Серия = Неопределено) Экспорт
	
	Представление = "";
	ИнтеграцияИСПереопределяемый.ЗаполнитьПредставлениеНоменклатуры(
		Представление, Номенклатура, Характеристика, Упаковка, Серия);
	
	Если Представление = "" Тогда
		МассивФормированияПредставления = Новый Массив;
		Если ЗначениеЗаполнено(Номенклатура) Тогда
			МассивФормированияПредставления.Добавить(СокрЛП(Номенклатура));
		КонецЕсли;
		Если ЗначениеЗаполнено(Характеристика) Тогда
			МассивФормированияПредставления.Добавить(СокрЛП(Характеристика));
		КонецЕсли;
		Если ЗначениеЗаполнено(Упаковка) Тогда
			МассивФормированияПредставления.Добавить(СокрЛП(Упаковка));
		КонецЕсли;
		Если ЗначениеЗаполнено(Серия) Тогда
			МассивФормированияПредставления.Добавить(СокрЛП(Серия));
		КонецЕсли;
		Представление = СтрСоединить(МассивФормированияПредставления);
	КонецЕсли;
	
	Возврат Представление;
	
КонецФункции

#Область ХарактеристикиНоменклатуры

Функция ПризнакИспользованияХарактеристик(Номенклатура) Экспорт
	
	Используются = Ложь;
	ИнтеграцияИСПереопределяемый.ИспользованиеХарактеристик(Используются, Номенклатура);
	Возврат Используются;
	
КонецФункции

Функция ХарактеристикиИспользуются() Экспорт
	
	Используются = Ложь;
	ИнтеграцияИСПереопределяемый.ИспользованиеХарактеристик(Используются, Неопределено);
	Возврат Используются;
	
КонецФункции

#КонецОбласти

#Область СерииНоменклатуры

Функция СерииИспользуются() Экспорт
	
	Используются = Ложь;
	ИнтеграцияИСПереопределяемый.ИспользованиеСерий(Используются, Неопределено);
	Возврат Используются;
	
КонецФункции

Функция ПризнакИспользованияСерий(Номенклатура) Экспорт
	
	Используются = Ложь;
	ИнтеграцияИСПереопределяемый.ИспользованиеСерий(Используются, Номенклатура);
	Возврат Используются;
	
КонецФункции

// Возвращает параметры указания серий для товаров, указанных в объекте.
//
// Параметры:
//	Объект   - Объект, ДанныеФормыСтруктура - Объект, для формы которого нужно сформировать параметры указания серий.
//	Менеджер - Менеджер                     - Менеджер объекта, для формы которого нужно сформировать параметры указания серий.
//
// Возвращаемое значение:
//	Произвольный - параметры, уточняющие особенности указания серий в каждом объекте
//
Функция ПараметрыУказанияСерийФормыОбъекта(Объект, Менеджер) Экспорт
	
	Параметры = Неопределено;
	ИнтеграцияИСПереопределяемый.ЗаполнитьПараметрыУказанияСерийФормыОбъекта(Параметры, Объект, Менеджер);
	Возврат Параметры;
	
КонецФункции

// Имена реквизитов, от значений которых зависят параметры указания серий.
//
// Возвращаемое значение:
//	Строка - Имена реквизитов, перечисленные через запятую.
//
Функция ИменаРеквизитовДляЗаполненияПараметровУказанияСерий(ТипОбъекта) Экспорт
	
	ИменаРеквизитов = "";
	ИнтеграцияИСПереопределяемый.ЗаполнитьИменаРеквизитовДляЗаполненияПараметровУказанияСерий(ИменаРеквизитов, ТипОбъекта);
	Возврат ИменаРеквизитов;
	
КонецФункции

// Возвращает параметры указания серий для товаров, указанных в объекте.
//
// Параметры:
//	ТипОбъекта - ОбъектМетаданных - Тип объекта коллекции объектов метаданных.
//	Объект     - Структура        - Структура значений реквизитов объекта, необходимых для заполнения параметров указания серий.
//
// Возвращаемое значение:
//  (см. ИнтеграцияИСПереопределяемый.ЗаполнитьПараметрыУказанияСерий) - параметры, уточняющие особенности указания серий.
//
Функция ПараметрыУказанияСерий(ТипОбъекта, Объект) Экспорт
	
	Параметры = Неопределено;
	ИнтеграцияИСПереопределяемый.ЗаполнитьПараметрыУказанияСерий(Параметры, ТипОбъекта, Объект);
	Возврат Параметры;
	
КонецФункции

// Возвращает текст запроса заполнения статусов указания серий для товаров, указанных в документе.
//
// Параметры:
//   ТипОбъекта             - ОбъектМетаданных - Тип документа коллекции объектов метаданных.
//   ПараметрыУказанияСерий - (см. ИнтеграцияИСПереопределяемый.ЗаполнитьПараметрыУказанияСерий).
//
// Возвращаемое значение:
//   Строка - Текст запроса заполнения статусов указания серий для товаров, указанных в объекте.
//
Функция ТекстЗапросаЗаполненияСтатусовУказанияСерий(ТипОбъекта, ПараметрыУказанияСерий) Экспорт
	
	ТекстЗапроса = "";
	ИнтеграцияИСПереопределяемый.ЗаполнитьТекстЗапросаЗаполненияСтатусовУказанияСерий(
		ТекстЗапроса,
		ТипОбъекта,
		ПараметрыУказанияСерий);
	Возврат ТекстЗапроса;
	
КонецФункции

// Возвращает текст запроса для проверки заполнения серий
//
// Параметры:
//   ТипОбъекта             - ОбъектМетаданных - Тип документа коллекции объектов метаданных.
//   ПараметрыУказанияСерий - (см. ИнтеграцияИСПереопределяемый.ЗаполнитьПараметрыУказанияСерий) - параметры указания серий
//
// Возвращаемое значение:
//   Строка - текст запроса.
//
Функция ТекстЗапросаПроверкиЗаполненияСерий(ТипОбъекта, ПараметрыУказанияСерий) Экспорт
	
	ТекстЗапроса = "";
	ИнтеграцияИСПереопределяемый.ЗаполнитьТекстЗапросаПроверкиЗаполненияСерий(
		ТекстЗапроса,
		ТипОбъекта,
		ПараметрыУказанияСерий);
	Возврат ТекстЗапроса;
	
КонецФункции

#КонецОбласти

#КонецОбласти

// Выполняет поиск организации предприятия по ИНН и/или КПП.
//
// Параметры:
//   ИНН - Строка - ИНН искомой организации,
//   КПП - Строка - КПП искомой организации.
// 
// Возвращаемое значение:
//   ОпределяемыйТип.ОрганизацияКонтрагентГосИС, Неопределено - найденная организация
//
Функция ОрганизацияПоИННКПП(ИНН, КПП) Экспорт
	
	Организация = Неопределено;
	ИнтеграцияИСПереопределяемый.ЗаполнитьОрганизациюПоИННКПП(Организация, ИНН, КПП);
	Возврат Организация;
	
КонецФункции

// Определяет контрагента по ИНН и КПП
//
// Параметры:
//  ИНН  - Строка - ИНН контрагента.
//  КПП  - Строка - КПП контрагента.
//
// Возвращаемое значение:
//   ОпределяемыйТип.КонтрагентГосИС, ОпределяемыйТип.ОрганизацияКонтрагентГосИС, Неопределено  - Найденный контрагент или Неопределено, если поиск завершился неудачей.
//
Функция КонтрагентПоИННКПП(ИНН, КПП) Экспорт
	
	Контрагент = Неопределено;
	ИнтеграцияИСПереопределяемый.ЗаполнитьКонтрагентаПоИННКПП(Контрагент, ИНН, КПП);
	Возврат Контрагент;
	
КонецФункции

// Возвращает строковое представление руководителя организации.
//
// Параметры:
//  Организация - ОпределяемыйТип.ОрганизацияКонтрагентГосИС - ссылка на собственную организацию или контрагента,
//  ДатаСведений - Дата - дата, на которую требуется получить информацию.
//
// Возвращаемое значение:
//  Структура - данные руководителя:
//   * Руководитель - Строка - ФИО руководителя,
//   * Должность - Строка - должность руководителя.
//
Функция ДанныеРуководителяОрганизации(Организация, ДатаСведений = Неопределено) Экспорт
	
	ПредставлениеРуководителя = Новый Структура("Руководитель, Должность", "", "");
	ИнтеграцияИСПереопределяемый.ОпределитьДанныеРуководителяОрганизации(ПредставлениеРуководителя,Организация,ДатаСведений);
	Возврат ПредставлениеРуководителя;
	
КонецФункции

#Область ПраваДоступа

Функция ЕстьПравоСозданияКонтрагента() Экспорт
	
	ДоступРазрешен = Ложь;
	ИнтеграцияИСПереопределяемый.ПравоСозданияКонтрагента(ДоступРазрешен);
	Возврат  ДоступРазрешен;
	
КонецФункции

#КонецОбласти

Функция ПараметрыИнтеграцииВФормеПоОбъекту(Объект)
	
	ПараметрыИнтеграции = ПараметрыИнтеграцииВФорме();
	ПараметрыИнтеграции.ИмяЭлементаДляРазмещения = ИмяЭлементаДляРазмещения();
	МетаданныеОбъекта = Объект.Ссылка.Метаданные();
	ИнтеграцияИСПереопределяемый.ЗаполнитьПараметрыИнтеграцииВФормеПоОбъекту(ПараметрыИнтеграции, МетаданныеОбъекта);
	Возврат ПараметрыИнтеграции;
	
КонецФункции

Функция ПредставлениеОбъекта(ПараметрОбъект) Экспорт
	
	Представление = НСтр("ru = '<Не задано>'");
	ИнтеграцияИСПереопределяемый.УстановитьПредставлениеОбъекта(Представление, ПараметрОбъект);
	Возврат Представление;
	
КонецФункции

#КонецОбласти

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

#Область РаботаСXDTO

// Функция возвращает пустую таблицу значений пользовательских представлений полей
// 
// Возвращаемое значение:
//  ТаблицаЗначений - пустая таблица (отсутствия пользовательской расшифровки полей)
//
Функция ПустаяТаблицаПредставленийПолей()
	
	ТаблицаПредставлений = Новый ТаблицаЗначений;
	ТаблицаПредставлений.Колонки.Добавить("ПространствоИмен", Новый ОписаниеТипов("Строка"));
	ТаблицаПредставлений.Колонки.Добавить("ЛокальноеИмя",     Новый ОписаниеТипов("Строка"));
	ТаблицаПредставлений.Колонки.Добавить("Представление",    Новый ОписаниеТипов("Строка"));
	ТаблицаПредставлений.Колонки.Добавить("Обязательное",     Новый ОписаниеТипов("Булево"));
	ТаблицаПредставлений.Колонки.Добавить("Глубина",          Новый ОписаниеТипов("Число"));
	Возврат ТаблицаПредставлений;
	
КонецФункции

// Функция возвращает таблицу значений пользовательских представлений полей из макета
//
// Параметры:
//  ИмяМакета - Строка - имя общего макета из которого берутся представления
//    Структура макета: Табличный документ с XML:
//     * Элементы (список): Items,
//       * Вложенный элемент списка: Item, с атрибутами соответствующими колонкам результата
// Возвращаемое значение:
//  ТаблицаЗначений - см. ПустаяТаблицаПредставленийПолей()
//
Функция ПредставленияПолей(ИмяМакета)
	
	ТаблицаПредставлений = ПустаяТаблицаПредставленийПолей();
	
	Если ИмяМакета = Неопределено Тогда
		Возврат ТаблицаПредставлений;
	КонецЕсли;
	
	Макет = УправлениеПечатью.МакетПечатнойФормы(ИмяМакета);
	
	ЧтениеXML = Новый ЧтениеXML;
	ЧтениеXML.УстановитьСтроку(Макет.ПолучитьТекст());
	
	Если Не ЧтениеXML.Прочитать() Тогда //пустой макет вполне валиден
		Возврат ТаблицаПредставлений;
	ИначеЕсли ЧтениеXML.Имя <> "Items" Тогда
		ВызватьИсключение НСтр("ru = 'Ошибка в структуре XML'");
	КонецЕсли;
	
	Пока ЧтениеXML.Прочитать() Цикл
		
		Если ЧтениеXML.ТипУзла = ТипУзлаXML.КонецЭлемента И ЧтениеXML.Имя = "Items" Тогда
			Прервать;
		ИначеЕсли ЧтениеXML.ТипУзла <> ТипУзлаXML.НачалоЭлемента Тогда
			Продолжить;
		ИначеЕсли ЧтениеXML.Имя <> "Item" Тогда
			ВызватьИсключение НСтр("ru = 'Ошибка в структуре XML'");
		КонецЕсли;
		
		СтрокаПредставления = ТаблицаПредставлений.Добавить();
		СтрокаПредставления.ПространствоИмен = ЧтениеXML.ПолучитьАтрибут("ПространствоИмен");
		СтрокаПредставления.ЛокальноеИмя     = ЧтениеXML.ПолучитьАтрибут("ЛокальноеИмя");
		СтрокаПредставления.Представление    = ЧтениеXML.ПолучитьАтрибут("Представление");
		СтрокаПредставления.Глубина          = СтроковыеФункцииКлиентСервер.СтрокаВЧисло(ЧтениеXML.ПолучитьАтрибут("Глубина"));
		СтрокаПредставления.Обязательное     = Булево(СтроковыеФункцииКлиентСервер.СтрокаВЧисло(ЧтениеXML.ПолучитьАтрибут("Обязательное")));
		
	КонецЦикла;
	
	ТаблицаПредставлений.Сортировать("ПространствоИмен Возр");
	
	Возврат ТаблицаПредставлений;
	
КонецФункции

#КонецОбласти

#КонецОбласти