
////////////////////////////////////////////////////////////////////////////////
// ФУНКЦИЯ ПОЛУЧЕНИЯ АДРЕСОВ HTML СТРАНИЦ

#Область ФункцияПолученияАдресовHtmlСтраниц

// Возвращает адрес страницы с описанием обмена с голосовыми сервисами (загрузка показаний).
//
Функция ПолучитьАдресСтраницыОписанияСервисаЗагрузкаПоказаний() Экспорт
	
	Возврат "https://vgkh.ru/jsk/priem_pu/";
	
КонецФункции

// Возвращает адрес страницы с описанием обмена с голосовыми сервисами (автообзвон должников).
//
Функция ПолучитьАдресСтраницыОписанияСервисаАвтообзвонДолжников() Экспорт
	
	Возврат "https://vgkh.ru/jsk/avtoobzvon/";
	
КонецФункции

// Возвращает адрес страницы обратной связи.
//
Функция ПолучитьАдресСтраницыОбратнойСвязи() Экспорт
	
	Возврат "https://otr-soft.ru/contacts/#feedback";
	
КонецФункции

#КонецОбласти

////////////////////////////////////////////////////////////////////////////////
// ФУНКЦИИ УПРАВЛЕНИЯ ПОДКЛЮЧЕНИЕМ К СЕРВИСУ И АУТЕНТИФИКАЦИИ

#Область ФункцииУправленияПодключениемКСервисуИАутентификации

// Получает объект соединения к сайту.
//
Функция ПолучитьHTTPСоединение(Адрес, Логин, Пароль)
	
	мHTTPСоединение = Новый HTTPСоединение(ЗакодироватьАдресСайта(Адрес), , Логин, Пароль,, 900, Новый ЗащищенноеСоединениеOpenSSL(Неопределено, Неопределено));
	
	Возврат мHTTPСоединение;
	
КонецФункции

// Авторизуется на сервисе и возвращает идентификатор сессии (Cookie).
// Параметры:
//  мHTTPСоединение - объект, с помощью которого осуществляется соединение с сайтом.
//  ТаблицаСообщений - Таблица значений - таблица ошибок.
//
// Возвращаемое значение:
//  Строка, Неопределено.
//
Функция АвторизоватьсяНаСервисе(мHTTPСоединение, ТаблицаСообщений = Неопределено)
	
	ИдентификаторСессии = "";
	
	// Выполняем авторизацию и получаем идентификатор сессии.
	Попытка
		ЗаголовкиHTTP = Новый Соответствие;
		ЗаголовкиHTTP.Вставить("Host", мHTTPСоединение.Сервер);
		
		СтрокаЗапроса = СтрШаблон("auth/login?login=%1&password=%2", мHTTPСоединение.Пользователь, мHTTPСоединение.Пароль);
		
		ЗапросHTTP = Новый HTTPЗапрос(СтрокаЗапроса, ЗаголовкиHTTP);
		ОтветHTTP  = мHTTPСоединение.Получить(ЗапросHTTP);
		Ответ      = СокрЛ(ОтветHTTP.ПолучитьТелоКакСтроку());
	Исключение
		
		Если НЕ ТаблицаСообщений = Неопределено Тогда
			УПЖКХ_РаботаССообщениямиСервер.ДобавитьСообщение(ТаблицаСообщений, "Неудачная авторизация: пожалуйста, убедитесь в наличии соединения с сетью Интернет и в том, что параметры доступа указаны правильно.");
		КонецЕсли;
		
		Возврат ИдентификаторСессии;
	КонецПопытки;
	
	// Получаем структуру из ответа сервиса (JSON).
	ОбъектОтвета = ПолучитьСтруктуруОбъектаJSON(Ответ);
	
	// Проверяем успешность авторизации. Если успешно, то возвращаем идентификатор сессии.
	Если ТипЗнч(ОбъектОтвета) = Тип("Структура")
	   И ОбъектОтвета.Свойство("success") Тогда
		
		Если ОбъектОтвета.success Тогда
			ИдентификаторСессии = ОтветHTTP.Заголовки["set-cookie"];
		Иначе
			// Если не удалось получить ответ об успешной авторизации, то выводим сообщение.
			Если НЕ ТаблицаСообщений = Неопределено И ОбъектОтвета.Свойство("msg") Тогда
				УПЖКХ_РаботаССообщениямиСервер.ДобавитьСообщение(ТаблицаСообщений, СтрШаблон("Неудачная авторизация: %1.", ОбъектОтвета.msg));
			Иначе
				УПЖКХ_РаботаССообщениямиСервер.ДобавитьСообщение(ТаблицаСообщений, "Неудачная авторизация.");
			КонецЕсли;
		КонецЕсли;
		
	Иначе
		// Если не удалось получить ответ об успешной авторизации, то выводим сообщение.
		Если НЕ ТаблицаСообщений = Неопределено Тогда
			УПЖКХ_РаботаССообщениямиСервер.ДобавитьСообщение(ТаблицаСообщений, "Неудачная авторизация.");
		КонецЕсли;
	КонецЕсли;
	
	Возврат ИдентификаторСессии;
	
КонецФункции // АвторизоватьсяНаСервисе()

// Завершает сессию.
// Параметры:
//  мHTTPСоединение - объект, с помощью которого осуществляется соединение с сайтом.
//  ИдентификаторСессии - Строка - Идентификатор сессии.
//  ТаблицаСообщений - Таблица значений - таблица ошибок.
//
// Возвращаемое значение:
//  Строка, Неопределено.
//
Функция ЗавершитьСессию(мHTTPСоединение, ИдентификаторСессии, ТаблицаСообщений = Неопределено)
	
	// Если идентификатор сессии пустой, считаем это ошибкой.
	Если ПустаяСтрока(ИдентификаторСессии) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	// Отправляем запрос на завершение сессии.
	Попытка
		ЗаголовкиHTTP = Новый Соответствие;
		ЗаголовкиHTTP.Вставить("Host",   мHTTPСоединение.Сервер);
		ЗаголовкиHTTP.Вставить("Cookie", ИдентификаторСессии);
		ЗапросHTTP = Новый HTTPЗапрос("auth/logout", ЗаголовкиHTTP);
		
		ОтветHTTP = мHTTPСоединение.Получить(ЗапросHTTP);
		Ответ     = СокрЛ(ОтветHTTP.ПолучитьТелоКакСтроку());
	Исключение
		Если НЕ ТаблицаСообщений = Неопределено Тогда
			УПЖКХ_РаботаССообщениямиСервер.ДобавитьСообщение(ТаблицаСообщений, "Не удалось завершить сеанс подключения к сервису: пожалуйста, убедитесь в наличии соединения с сетью Интернет.");
		КонецЕсли;
		
		Возврат Ложь;
	КонецПопытки;
	
	// Получаем структуру из ответа сервиса (JSON).
	ОбъектОтвета = ПолучитьСтруктуруОбъектаJSON(Ответ);
	
	// Проверяем успешность завершения сессии. Если успешно, то уведомляем об этом.
	Если ТипЗнч(ОбъектОтвета) = Тип("Структура")
	   И ОбъектОтвета.Свойство("success") Тогда
		
		Если ОбъектОтвета.success Тогда
			Возврат Истина;
		Иначе
			// Если завершение сессии не удалось, то выводим сообщение.
			Если НЕ ТаблицаСообщений = Неопределено И ОбъектОтвета.Свойство("msg") Тогда
				УПЖКХ_РаботаССообщениямиСервер.ДобавитьСообщение(ТаблицаСообщений, СтрШаблон("Неудачное завершение сессии: %1.", ОбъектОтвета.msg));
			Иначе
				УПЖКХ_РаботаССообщениямиСервер.ДобавитьСообщение(ТаблицаСообщений, "Неудачное завершение сессии.");
			КонецЕсли;
		КонецЕсли;
		
	Иначе
		// Если не удалось получить корректный ответ об успешном завершении сессии, то выводим сообщение.
		Если НЕ ТаблицаСообщений = Неопределено Тогда
			УПЖКХ_РаботаССообщениямиСервер.ДобавитьСообщение(ТаблицаСообщений, "Неудачное завершение сессии.");
		КонецЕсли;
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции

// Проверяет корректность настроек доступа.
//
Функция ВыполнитьПробноеПодключение(Адрес, Логин, Пароль, ТаблицаСообщений = Неопределено, ПолучитьСведенияОбУчетнойЗаписи = Ложь) Экспорт
	
	мHTTPСоединение     = ПолучитьHTTPСоединение(Адрес, Логин, Пароль);
	ИдентификаторСессии = АвторизоватьсяНаСервисе(мHTTPСоединение, ТаблицаСообщений);
	
	Если ПустаяСтрока(ИдентификаторСессии) Тогда
		
		Возврат Новый Структура("ВыполненоУспешно", Ложь);
		
	Иначе
		
		Если ПолучитьСведенияОбУчетнойЗаписи Тогда
			СтруктураСведенийОбУчетнойЗаписиПользователя = ПолучитьСведенияОбУчетнойЗаписиПользователя(мHTTPСоединение, ИдентификаторСессии);
			
			ЗавершитьСессию(мHTTPСоединение, ИдентификаторСессии);
		Иначе
			СтруктураСведенийОбУчетнойЗаписиПользователя = Новый Структура("ВыполненоУспешно", ЗавершитьСессию(мHTTPСоединение, ИдентификаторСессии));
		КонецЕсли;
		
		Возврат СтруктураСведенийОбУчетнойЗаписиПользователя;
		
	КонецЕсли;
	
КонецФункции

// Проверяет корректность настроек доступа.
//
Процедура ПроверитьКорректностьПараметровДоступаВФоновомЗадании(Адрес, Логин, Пароль, ТаблицаСообщений, АдресВременногоХранилища) Экспорт
	
	ПоместитьВоВременноеХранилище(ВыполнитьПробноеПодключение(Адрес, Логин, Пароль, ТаблицаСообщений), АдресВременногоХранилища);
	
КонецПроцедуры

// Получает сведения о подписке.
//
Функция ПолучитьСведенияОбУчетнойЗаписи(Адрес, Логин, Пароль) Экспорт
	
	мHTTPСоединение = ПолучитьHTTPСоединение(Адрес, Логин, Пароль);
	
	ИдентификаторСессии = АвторизоватьсяНаСервисе(мHTTPСоединение);
	
	Если ПустаяСтрока(ИдентификаторСессии) Тогда
		
		Возврат Новый Структура("ВыполненоУспешно", Ложь);
		
	Иначе
		
		СтруктураСведенийОбУчетнойЗаписиПользователя = ПолучитьСведенияОбУчетнойЗаписиПользователя(мHTTPСоединение, ИдентификаторСессии);
		
		ЗавершитьСессию(мHTTPСоединение, ИдентификаторСессии);
		
		Возврат СтруктураСведенийОбУчетнойЗаписиПользователя;
		
	КонецЕсли;
	
КонецФункции

// Получает сведения об учетной записи пользователя.
//
Функция ПолучитьСведенияОбУчетнойЗаписиПользователя(мHTTPСоединение, ИдентификаторСессии)
	
	// Инициализация локальных переменных.
	СтруктураОтвета = Новый Структура("ВыполненоУспешно, Подписка_Оплачена, Подписка_ВидПодписки, ОсталосьСекундДляАвтообзвона, ОсталосьСекундДляПриемаПоказаний, ПорогПредупрежденияОМаломКоличествеОставшегосяВремени", Ложь, Ложь, Ложь, 0, 0, ПолучитьПорогПредупрежденияОМаломКоличествеОставшегосяВремени());
	
	Попытка
		ЗаголовкиHTTP = Новый Соответствие;
		ЗаголовкиHTTP.Вставить("Host",         мHTTPСоединение.Сервер);
		ЗаголовкиHTTP.Вставить("Content-Type", "multipart/form-data");
		ЗаголовкиHTTP.Вставить("Cookie",       ИдентификаторСессии);
		
		ЗапросHTTP = Новый HTTPЗапрос("users/get_profile", ЗаголовкиHTTP);
		ОтветHTTP  = мHTTPСоединение.Получить(ЗапросHTTP);
		Ответ      = СокрЛ(ОтветHTTP.ПолучитьТелоКакСтроку());
		
		// Получаем структуру из ответа сервиса (JSON).
		ОбъектОтвета = ПолучитьСтруктуруОбъектаJSON(Ответ);
	Исключение
		Возврат СтруктураОтвета;
	КонецПопытки;
	
	// Если объект представляет собой структуру и содержит нужные нам поля, то передаем его далее.
	Если ТипЗнч(ОбъектОтвета) = Тип("Структура") И ОбъектОтвета.Свойство("payment") И ОбъектОтвета.Свойство("payment_type") Тогда
		
		СтруктураОтвета.ВыполненоУспешно = Истина;
		СтруктураОтвета.Подписка_Оплачена = ОбъектОтвета.payment;
		
		ВидПодписки = ОбъектОтвета.payment_type;
		
		// Ключи клиента для получения количества оставшегося времени для обзвона и приема звонков.
		КлючДляАвтообзвона     = ?(ОбъектОтвета.Свойство("calls_key"), ОбъектОтвета.calls_key, "");
		КлючДляПриемаПоказаний = ?(ОбъектОтвета.Свойство("recognize_key"), ОбъектОтвета.recognize_key, "");
		
		// Заполняем результаты сбора данных о лицензии.
		Если ВидПодписки = "calls" Тогда
			СтруктураОтвета.Подписка_ВидПодписки         = Перечисления.УПЖКХ_ВидыПодпискиНаГолосовыеСервисы.АвтообзвонДолжников;
			СтруктураОтвета.ОсталосьСекундДляАвтообзвона = ПолучитьКоличествоОставшихсяСекундНаСервисе(КлючДляАвтообзвона);
		ИначеЕсли ВидПодписки = "answers" Тогда
			СтруктураОтвета.Подписка_ВидПодписки             = Перечисления.УПЖКХ_ВидыПодпискиНаГолосовыеСервисы.ПриемПоказаний;
			СтруктураОтвета.ОсталосьСекундДляПриемаПоказаний = ПолучитьКоличествоОставшихсяСекундНаСервисе(КлючДляПриемаПоказаний);
		ИначеЕсли ВидПодписки = "calls_answers" Тогда
			СтруктураОтвета.Подписка_ВидПодписки             = Перечисления.УПЖКХ_ВидыПодпискиНаГолосовыеСервисы.АвтообзвонДолжниковИПриемПоказаний;
			СтруктураОтвета.ОсталосьСекундДляАвтообзвона     = ПолучитьКоличествоОставшихсяСекундНаСервисе(КлючДляАвтообзвона);
			СтруктураОтвета.ОсталосьСекундДляПриемаПоказаний = ПолучитьКоличествоОставшихсяСекундНаСервисе(КлючДляПриемаПоказаний);
		Иначе
			СтруктураОтвета.Подписка_ВидПодписки = Перечисления.УПЖКХ_ВидыПодпискиНаГолосовыеСервисы.Отсутствует;
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат СтруктураОтвета;
	
КонецФункции

// Получает количество оставшегося времени на сервисе по ключу клиента.
//
Функция ПолучитьКоличествоОставшихсяСекундНаСервисе(КлючКлиента)
	
	КоличествоОставшихсяСекунд = 0;
	
	Если ЗначениеЗаполнено(КлючКлиента) Тогда
		
		мHTTPСоединение = УПЖКХ_ВебИнтеграцияВзаимодействиеССайтом.ПолучитьHTTPСоединение("speech.kloud.one",,, Истина);
		
		ЗаголовкиHTTP = Новый Соответствие;
		ЗаголовкиHTTP.Вставить("Host",         мHTTPСоединение.Сервер);
		ЗаголовкиHTTP.Вставить("Content-Type", "multipart/form-data");
		
		Попытка
			
			Ответ        = УПЖКХ_ВебИнтеграцияВзаимодействиеССайтом.ОтправитьGETЗапрос(мHTTPСоединение, ЗаголовкиHTTP, СтрШаблон("api/get-stat?key=%1", КлючКлиента));
			ОбъектОтвета = ПолучитьСтруктуруОбъектаJSON(Ответ);
			
			Если ТипЗнч(ОбъектОтвета) = Тип("Структура") И ОбъектОтвета.Свойство("success") И ОбъектОтвета.Свойство("timeLeft") И ОбъектОтвета.success = Истина Тогда
				КоличествоОставшихсяСекунд = ОбъектОтвета.timeLeft;
			КонецЕсли;
			
		Исключение
		КонецПопытки;
		
	КонецЕсли;
	
	Возврат КоличествоОставшихсяСекунд;
	
КонецФункции

// Возвращает размер нижнего порога остатка времени в секундах, при котором нужно предупреждать
// пользователя о дозакупке времени.
//
Функция ПолучитьПорогПредупрежденияОМаломКоличествеОставшегосяВремени()
	
	// Пока значение предопределено.
	Возврат 30000;
	
КонецФункции

// Формирует сведения о подписке при автономной работе с сервисом. Является заглушкой, разрешающей все виды обмена.
//
Функция ПолучитьСведенияОПодпискеДляАвтономнойРаботы()
	
	Возврат Новый Структура("ВыполненоУспешно, Подписка_Оплачена, Подписка_ВидПодписки", Истина, Истина, Перечисления.УПЖКХ_ВидыПодпискиНаГолосовыеСервисы.АвтообзвонДолжниковИПриемПоказаний);
	
КонецФункции

// Формирует токен basic-авторизации на основании имеющегося http-соединения.
//
Функция ПолучитьТокенДляBasicАвторизацииНаОснованииHTTPСоединения(мHTTPСоединение)
	
	Возврат УПЖКХ_ВебИнтеграцияОбщегоНазначения.ПреобразоватьСтрокуВBase64(мHTTPСоединение.Пользователь + ":" + мHTTPСоединение.Пароль, КодировкаТекста.ANSI);
	
КонецФункции

#КонецОбласти

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ УПРАВЛЕНИЯ ОБМЕНАМИ С СЕРВИСОМ

#Область ПроцедурыУправленияОбменамиССервисом

// Формирует файл обмена без его отправки на сервисы. Используется для автономного режима работы.
//
Функция СформироватьФайлВыгрузкиБезОтправкиНаСервис(СтруктураНастроекОбмена, ТаблицаСообщений) Экспорт
	
	СведенияОПодписке = ПолучитьСведенияОПодпискеДляАвтономнойРаботы();
	
	ВыгрузкаДанныхПоЛС                      = ?(СтруктураНастроекОбмена.Свойство("ВыгрузкаДанныхПоЛС"), СтруктураНастроекОбмена.ВыгрузкаДанныхПоЛС, Ложь);
	ВыгружатьТолькоПоВыбраннымЛицевымСчетам = ?(СтруктураНастроекОбмена.Свойство("ВыгружатьТолькоПоВыбраннымЛицевымСчетам"), СтруктураНастроекОбмена.ВыгружатьТолькоПоВыбраннымЛицевымСчетам, Ложь);
	ВыбранныеЛицевыеСчета                   = ?(СтруктураНастроекОбмена.Свойство("ВыбранныеЛицевыеСчета") И ТипЗнч(СтруктураНастроекОбмена.ВыбранныеЛицевыеСчета) = Тип("ТаблицаЗначений"), СтруктураНастроекОбмена.ВыбранныеЛицевыеСчета, Неопределено);
	
	НастройкиИнтеграцииСГолосовымиСервисами = УПЖКХ_ИнтеграцияСГолосовымиСервисамиВзаимодействиеСБазойДанных.ПолучитьНастройкиИнтеграцииСГолосовымиСервисами();
	
	ВыгружатьПоВсемЛС      = ВыгрузкаДанныхПоЛС И НЕ ВыгружатьТолькоПоВыбраннымЛицевымСчетам;
	ВыгружатьПоВыбраннымЛС = ВыгрузкаДанныхПоЛС И ВыгружатьТолькоПоВыбраннымЛицевымСчетам И НЕ ВыбранныеЛицевыеСчета.Количество() = 0;
	
	Если ВыгружатьПоВсемЛС Тогда
		
		Возврат СформироватьФайлыОбменаИОтправитьНаСервис(ТаблицаСообщений, СведенияОПодписке,,, Ложь, Ложь);
		
	ИначеЕсли ВыгружатьПоВыбраннымЛС Тогда
		
		Возврат СформироватьФайлыОбменаИОтправитьНаСервис(ТаблицаСообщений, СведенияОПодписке, ПолучитьМассивЛСДляВыгрузки(ВыбранныеЛицевыеСчета),, Ложь, Ложь);
		
	КонецЕсли;
	
КонецФункции

// Управляет формированием файла обмена и его отправкой на сервис.
//
Функция СформироватьФайлыОбменаИОтправитьНаСервис(ТаблицаСообщений, СведенияОПодписке, МассивЛС = Неопределено, Дата = Неопределено, ВыполняетсяВАвтоматическомРежиме = Ложь, ОтправлятьНаСервис = Истина, мHTTPСоединение = Неопределено, ИдентификаторСессии = Неопределено)
	
	// Выгружаем данные по л/с порциями по 100 л/с.
	КоличествоОтбираемыхЗаИтерациюЛС = 100;
	
	МассивФайловОбмена = Новый Массив;
	ВыгрузкаЗавершена  = Ложь;
	
	// Текст JSON для хранения истории ответов сервера.
	МассивОтветовСервера = Новый Массив;
	
	СтруктураДанныхДляВыгрузкиОбщая = УПЖКХ_ИнтеграцияСГолосовымиСервисамиВзаимодействиеСБазойДанных.ПодготовитьОбщуюСтруктуруДанныхДляВыгрузки(СведенияОПодписке, МассивЛС);
	
	Пока НЕ ВыгрузкаЗавершена Цикл
		
		// 1. Структура данных для выгрузки.
		СтруктураДанныхДляВыгрузки = УПЖКХ_ИнтеграцияСГолосовымиСервисамиВзаимодействиеСБазойДанных.ПодготовитьТекущуюСтруктуруДанныхДляВыгрузки(СведенияОПодписке, СтруктураДанныхДляВыгрузкиОбщая, КоличествоОтбираемыхЗаИтерациюЛС, ВыгрузкаЗавершена);
		
		// 2. Подготовка текста с объектом JSON для передачи.
		ТекстОбъектаJSON = СформироватьОбъектJSONИзСтруктуры(СтруктураДанныхДляВыгрузки);
		
		Если ТекстОбъектаJSON = "" Тогда
			УПЖКХ_РаботаССообщениямиСервер.ДобавитьСообщение(ТаблицаСообщений, "Не удалось сформировать данные для выгрузки.");
			
			Возврат Неопределено;
		КонецЕсли;
		
		// 3. Подготовка информации для сохранения в журнале обмена.
		ВременныйФайлДляСохраненияВЖурнале = УПЖКХ_ИнтеграцияСГолосовымиСервисамиВзаимодействиеСБазойДанных.СформироватьТекстовыйФайл(ТекстОбъектаJSON);
		ИмяВременногоФайла                 = ПолучитьИмяФайлаИзПолногоПути(ВременныйФайлДляСохраненияВЖурнале);
		МассивФайловОбмена.Добавить(ВременныйФайлДляСохраненияВЖурнале);
		
		Если ОтправлятьНаСервис Тогда
			// 4. Выгрузка объекта JSON на сервис.
			ПередатьДанныеНаСервисИПолучитьОтветы(мHTTPСоединение, ИдентификаторСессии, ТекстОбъектаJSON, ТаблицаСообщений, ИмяВременногоФайла, МассивОтветовСервера);
			ВидОбмена = Перечисления.УПЖКХ_ВидыОбменаСГолосовымиСервисами.ВыгрузкаДанных;
		Иначе
			ВидОбмена = Перечисления.УПЖКХ_ВидыОбменаСГолосовымиСервисами.ВыгрузкаДанныхВФайл;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат ОбработатьРезультатыВыгрузкиДанныхНаСервис(МассивФайловОбмена, МассивОтветовСервера, ТаблицаСообщений, ВидОбмена, ВыполняетсяВАвтоматическомРежиме);
	
КонецФункции

// Выполняет обмены с сервисом в соответствии с переданными настройками.
//
Процедура ВыполнитьОбменДанными(СтруктураНастроекОбмена, ТаблицаСообщений) Экспорт
	
	ВыгрузкаДанныхПоЛС                      = ?(СтруктураНастроекОбмена.Свойство("ВыгрузкаДанныхПоЛС"), СтруктураНастроекОбмена.ВыгрузкаДанныхПоЛС, Ложь);
	ВыгружатьТолькоПоВыбраннымЛицевымСчетам = ?(СтруктураНастроекОбмена.Свойство("ВыгружатьТолькоПоВыбраннымЛицевымСчетам"), СтруктураНастроекОбмена.ВыгружатьТолькоПоВыбраннымЛицевымСчетам, Ложь);
	ВыбранныеЛицевыеСчета                   = ?(СтруктураНастроекОбмена.Свойство("ВыбранныеЛицевыеСчета") И ТипЗнч(СтруктураНастроекОбмена.ВыбранныеЛицевыеСчета) = Тип("ТаблицаЗначений"), СтруктураНастроекОбмена.ВыбранныеЛицевыеСчета, Неопределено);
	ЗагрузкаПоказанийПУ                     = ?(СтруктураНастроекОбмена.Свойство("ЗагрузкаПоказанийПУ"), СтруктураНастроекОбмена.ЗагрузкаПоказанийПУ, Ложь);
	
	НастройкиИнтеграцииСГолосовымиСервисами = УПЖКХ_ИнтеграцияСГолосовымиСервисамиВзаимодействиеСБазойДанных.ПолучитьНастройкиИнтеграцииСГолосовымиСервисами();
	
	// Если не оплачено, то ничего не делаем.
	СведенияОПодписке = ПолучитьСведенияОбУчетнойЗаписи(НастройкиИнтеграцииСГолосовымиСервисами.ПерсональныйURL, НастройкиИнтеграцииСГолосовымиСервисами.Логин, НастройкиИнтеграцииСГолосовымиСервисами.Пароль);
	
	Если СведенияОПодписке.ВыполненоУспешно Тогда
		
		ВыгружатьПоВсемЛС      = ВыгрузкаДанныхПоЛС И НЕ ВыгружатьТолькоПоВыбраннымЛицевымСчетам;
		ВыгружатьПоВыбраннымЛС = ВыгрузкаДанныхПоЛС И ВыгружатьТолькоПоВыбраннымЛицевымСчетам И НЕ ВыбранныеЛицевыеСчета.Количество() = 0;
		
		Если ВыгружатьПоВсемЛС ИЛИ ВыгружатьПоВыбраннымЛС ИЛИ ЗагрузкаПоказанийПУ Тогда
			
			мHTTPСоединение = ПолучитьHTTPСоединение(НастройкиИнтеграцииСГолосовымиСервисами.ПерсональныйURL, НастройкиИнтеграцииСГолосовымиСервисами.Логин, НастройкиИнтеграцииСГолосовымиСервисами.Пароль);
			
			// Получаем идентификатор сессии.
			ИдентификаторСессии = АвторизоватьсяНаСервисе(мHTTPСоединение, ТаблицаСообщений);
			
			Если ПустаяСтрока(ИдентификаторСессии) Тогда
				Возврат;
			КонецЕсли;
			
			Если ВыгружатьПоВсемЛС Тогда
				
				УдалитьССервисаЗакрытыеЛС(мHTTPСоединение, ТаблицаСообщений);
				ВыгрузитьСведенияПоЛСНаСервис(мHTTPСоединение, ИдентификаторСессии, ТаблицаСообщений, СведенияОПодписке);
				
			ИначеЕсли ВыгружатьПоВыбраннымЛС Тогда
				
				УдалитьССервисаЗакрытыеЛС(мHTTPСоединение, ТаблицаСообщений, ВыбранныеЛицевыеСчета);
				ВыгрузитьСведенияПоЛСНаСервис(мHTTPСоединение, ИдентификаторСессии, ТаблицаСообщений, СведенияОПодписке,, ПолучитьМассивЛСДляВыгрузки(ВыбранныеЛицевыеСчета));
				
			КонецЕсли;
			
			Если ЗагрузкаПоказанийПУ Тогда
				
				ЗагрузитьПоказанияСчетчиковССервиса(мHTTPСоединение, ИдентификаторСессии, ТаблицаСообщений, СведенияОПодписке);
				
			КонецЕсли;
			
			ЗавершитьСессию(мHTTPСоединение, ИдентификаторСессии, ТаблицаСообщений);
			
		Иначе
			
			УПЖКХ_РаботаССообщениямиСервер.ДобавитьСообщение(ТаблицаСообщений, "Не указано, какими данными необходимо произвести обмен.");
			
		КонецЕсли;
		
	Иначе
		
		УПЖКХ_РаботаССообщениямиСервер.ДобавитьСообщение(ТаблицаСообщений, "Неудачная авторизация.");
		
	КонецЕсли;
	
КонецПроцедуры

// Управляет выгрузкой сведений по л/с на сервис.
//
Процедура ВыгрузитьСведенияПоЛСНаСервис(мHTTPСоединение, ИдентификаторСессии, ТаблицаСообщений, СведенияОПодписке, Дата = Неопределено, МассивЛС = Неопределено, ВыполняетсяВАвтоматическомРежиме = Ложь)
	
	Если СведенияОПодписке.Подписка_ВидПодписки = Перечисления.УПЖКХ_ВидыПодпискиНаГолосовыеСервисы.Отсутствует Тогда
		
		УПЖКХ_РаботаССообщениямиСервер.ДобавитьСообщение(ТаблицаСообщений, "Услуга не подключена.");
		
	ИначеЕсли НЕ СведенияОПодписке.Подписка_Оплачена Тогда
		
		УПЖКХ_РаботаССообщениямиСервер.ДобавитьСообщение(ТаблицаСообщений, "Услуга не оплачена.");
		
	Иначе
		
		СформироватьФайлыОбменаИОтправитьНаСервис(ТаблицаСообщений, СведенияОПодписке, МассивЛС, Дата, ВыполняетсяВАвтоматическомРежиме, Истина, мHTTPСоединение, ИдентификаторСессии);
		
	КонецЕсли;
	
КонецПроцедуры

// Управляет загрузкой показаний счетчиков с сервиса.
//
Процедура ЗагрузитьПоказанияСчетчиковССервиса(мHTTPСоединение, ИдентификаторСессии, ТаблицаСообщений, СведенияОПодписке, ВыполняетсяВАвтоматическомРежиме = Ложь)
	
	Если СведенияОПодписке.Подписка_ВидПодписки = Перечисления.УПЖКХ_ВидыПодпискиНаГолосовыеСервисы.Отсутствует ИЛИ
	 (НЕ СведенияОПодписке.Подписка_ВидПодписки = Перечисления.УПЖКХ_ВидыПодпискиНаГолосовыеСервисы.АвтообзвонДолжниковИПриемПоказаний
	 И НЕ СведенияОПодписке.Подписка_ВидПодписки = Перечисления.УПЖКХ_ВидыПодпискиНаГолосовыеСервисы.ПриемПоказаний) Тогда
		
		УПЖКХ_РаботаССообщениямиСервер.ДобавитьСообщение(ТаблицаСообщений, "Услуга не подключена.");
		
	ИначеЕсли НЕ СведенияОПодписке.Подписка_Оплачена Тогда
		
		УПЖКХ_РаботаССообщениямиСервер.ДобавитьСообщение(ТаблицаСообщений, "Услуга не оплачена.");
		
	Иначе
		
		ДатаПоследнегоЗагруженногоПоказания = УПЖКХ_ИнтеграцияСГолосовымиСервисамиВзаимодействиеСБазойДанных.ПолучитьДатуПоследнегоЗагруженногоПоказания();
		
		// 1. Получение сведений с сервиса.
		МассивДанныхОПоказанияхСчетчиков = ПолучитьПоказанияСчетчиковССервиса(мHTTPСоединение, ИдентификаторСессии, ДатаПоследнегоЗагруженногоПоказания, ТаблицаСообщений, ВыполняетсяВАвтоматическомРежиме);
		
		Если МассивДанныхОПоказанияхСчетчиков = Неопределено Тогда
			Возврат;
		КонецЕсли;
		
		// 2. Обработка полученных данных.
		ОбработанныеПоказанияССервиса = УПЖКХ_ИнтеграцияСГолосовымиСервисамиВзаимодействиеСБазойДанных.ОбработатьСведенияОПоказанияхСчетчиков(МассивДанныхОПоказанияхСчетчиков);
		
		// 3. Формирование документов "Ввод показаний счетчика".
		УПЖКХ_ИнтеграцияСГолосовымиСервисамиВзаимодействиеСБазойДанных.СформироватьДокументыВводаПоказанийСчетчиков(ОбработанныеПоказанияССервиса, ДатаПоследнегоЗагруженногоПоказания);
		
		// 4. Установим новую дату последних загруженных показаний.
		УПЖКХ_ИнтеграцияСГолосовымиСервисамиВзаимодействиеСБазойДанных.УстановитьДатуПоследнегоЗагруженногоПоказания(ДатаПоследнегоЗагруженногоПоказания);
		
	КонецЕсли;
	
КонецПроцедуры

// Выполняет удаление с сервиса закрытых л/с.
//
Процедура УдалитьССервисаЗакрытыеЛС(мHTTPСоединение, ТаблицаСообщений, ВыбранныеЛицевыеСчета = Неопределено, ВыполняетсяВАвтоматическомРежиме = Ложь)
	
	МассивЛСНаСервисе = ПолучитьЛСИмеющиесяНаСервисе(мHTTPСоединение, ТаблицаСообщений, ВыполняетсяВАвтоматическомРежиме);
	МассивЗакрытыхЛС  = УПЖКХ_ИнтеграцияСГолосовымиСервисамиВзаимодействиеСБазойДанных.ПолучитьЗакрытыеЛС(МассивЛСНаСервисе, ВыбранныеЛицевыеСчета);
	
	Если Не МассивЗакрытыхЛС.Количество() = 0 Тогда
		ОтправитьЗапросНаУдалениеЗакрытыхЛС(мHTTPСоединение, ТаблицаСообщений, МассивЗакрытыхЛС, ВыполняетсяВАвтоматическомРежиме);
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ОБМЕНА С СЕРВИСОМ

#Область ПроцедурыИФункцииОбменаССервисом

// Запускает передачу данных на сервис и формирует ответ на передачу данных.
//
Процедура ПередатьДанныеНаСервисИПолучитьОтветы(мHTTPСоединение, ИдентификаторСессии, ТекстОбъектаJSON, ТаблицаСообщений, ИмяВременногоФайла, МассивОтветовСервера)
	
	ОтветСервера = "";
	
	ПередатьДанныеПоЛСНаСервис(мHTTPСоединение, ИдентификаторСессии, ТекстОбъектаJSON, ТаблицаСообщений, ОтветСервера, ИмяВременногоФайла);
	
	МассивОтветовСервера.Добавить(СтрШаблон("
	|	%1:%2", ИмяВременногоФайла, ОтветСервера));
	
КонецПроцедуры

// Выполняет передачу данных по л/с на сервис.
//
Процедура ПередатьДанныеПоЛСНаСервис(мHTTPСоединение, ИдентификаторСессии, ТекстТелаЗапроса, ТаблицаСообщений, ОтветСервера, ИмяВременногоФайла = "")
	
	Попытка
		ЗапросHTTP = Новый HTTPЗапрос("rarus");
		ЗапросHTTP.Заголовки["Host"]         = мHTTPСоединение.Сервер;
		ЗапросHTTP.Заголовки["Content-Type"] = "application/x-www-form-urlencoded";
		ЗапросHTTP.Заголовки["Cookie"]       = ИдентификаторСессии;
		ЗапросHTTP.УстановитьТелоИзСтроки(СтрШаблон("data=%1", ТекстТелаЗапроса), КодировкаТекста.UTF8, ИспользованиеByteOrderMark.НеИспользовать);
		
		ОтветHTTP = мHTTPСоединение.ОтправитьДляОбработки(ЗапросHTTP);
		Ответ     = СокрЛ(ОтветHTTP.ПолучитьТелоКакСтроку());
	Исключение
		
		УПЖКХ_РаботаССообщениямиСервер.ДобавитьСообщение(ТаблицаСообщений, "Не удалось передать на сервис сведения по лицевым счетам.", Перечисления.УПЖКХ_ВидыСообщений.СообщениеОбОшибке, ИмяВременногоФайла);
		
		Возврат;
	КонецПопытки;
	
	// Получаем структуру из ответа сервиса (JSON).
	ОбъектОтвета = ПолучитьСтруктуруОбъектаJSON(Ответ);
	
	// Проверяем успешность передачи данных.
	Если ТипЗнч(ОбъектОтвета) = Тип("Структура")
	   И ОбъектОтвета.Свойство("success") Тогда
		
		Если НЕ ОбъектОтвета.success Тогда
			
			// Если не удалось передать сведения по л/с на сервис, то выводим сообщение.
			Если ОбъектОтвета.Свойство("msg") Тогда
				СообщениеОРезультате = СтрШаблон("Не удалось передать на сервис сведения по лицевым счетам: %1.", ОбъектОтвета.msg);
			Иначе
				СообщениеОРезультате = "Не удалось передать на сервис сведения по лицевым счетам.";
			КонецЕсли;
			
			УПЖКХ_РаботаССообщениямиСервер.ДобавитьСообщение(ТаблицаСообщений, "Не удалось передать на сервис сведения по лицевым счетам.", Перечисления.УПЖКХ_ВидыСообщений.СообщениеОбОшибке, ИмяВременногоФайла);
			
		КонецЕсли;
		
	Иначе
		// Если не удалось передать сведения по л/с на сервис, то выводим сообщение.
		СообщениеОРезультате = "Не удалось передать на сервис сведения по лицевым счетам.";
		
		УПЖКХ_РаботаССообщениямиСервер.ДобавитьСообщение(ТаблицаСообщений, "Не удалось передать на сервис сведения по лицевым счетам.", Перечисления.УПЖКХ_ВидыСообщений.СообщениеОбОшибке, ИмяВременногоФайла);
	КонецЕсли;
	
	// Записываем ответ сервера в текст JSON.
	ОтветСервера = Ответ;
	
КонецПроцедуры

// Обрабатывает сведения о результатах выгрузки данных на сервис.
//
Функция ОбработатьРезультатыВыгрузкиДанныхНаСервис(МассивФайловОбмена, МассивОтветовСервера, ТаблицаСообщений, ВидОбмена, ВыполняетсяВАвтоматическомРежиме)
	
	// Дополняем необходимый текст в JSON с ответами сервера.
	ОтветыСервера = СтрШаблон("{%1}", СтрСоединить(МассивОтветовСервера, ",
	|"));
	
	КоличествоФайловОбмена = МассивФайловОбмена.Количество();
	
	Если КоличествоФайловОбмена = 0 Тогда
		
		ФайлДляСохраненияВЖурналеОбмена = Неопределено;
		
		// Дополняем таблицу сообщений сведениями о завершении выгрузки.
		УПЖКХ_РаботаССообщениямиСервер.ДобавитьСообщение(ТаблицаСообщений, "Выгрузка данных по л/с не выполнена.", Перечисления.УПЖКХ_ВидыСообщений.СообщениеОбОшибке);
		
		// Подготавливаем сообщение о результате.
		СообщениеОРезультате = "Выгрузка данных по л/с не выполнена.";
		
		// Не выполнено.
		ВыполненоУспешно = Ложь;
		
	Иначе
		
		// Подготавливаем файл для сохранения в журнале обмена.
		Если КоличествоФайловОбмена > 1 Тогда
			ФайлДляСохраненияВЖурналеОбмена = УПЖКХ_ВебИнтеграцияВзаимодействиеСБазойДанных.ПоместитьФайлыВZIP(МассивФайловОбмена);
		Иначе
			ФайлДляСохраненияВЖурналеОбмена = МассивФайловОбмена[0];
		КонецЕсли;
		
		// Дополняем таблицу сообщений сведениями о завершении выгрузки.
		УПЖКХ_РаботаССообщениямиСервер.ДобавитьСообщение(ТаблицаСообщений, "Выгрузка данных по л/с завершена.", Перечисления.УПЖКХ_ВидыСообщений.ОбычноеСообщение);
		
		// Подготавливаем сообщение о результате.
		КоличествоВыгрузокСОшибками = УПЖКХ_РаботаССообщениямиСервер.ПолучитьКоличествоСообщенийОбОшибках(ТаблицаСообщений);
		
		СообщениеОРезультате = СтрШаблон("Успешно загружено файлов: %1 из %2", Строка(КоличествоФайловОбмена - КоличествоВыгрузокСОшибками), Строка(КоличествоФайловОбмена));
		
		// Проверяем успешность выполнения обмена.
		ВыполненоУспешно = КоличествоВыгрузокСОшибками = 0;
		
	КонецЕсли;
	
	Возврат УПЖКХ_ИнтеграцияСГолосовымиСервисамиВзаимодействиеСБазойДанных.СоздатьЗаписьЖурналаРегистрации(ФайлДляСохраненияВЖурналеОбмена, СообщениеОРезультате, ВидОбмена, ВыполненоУспешно, ОтветыСервера,, ВыполняетсяВАвтоматическомРежиме);
	
КонецФункции

// Выполняет загрузку с сервиса показаний счетчиков.
//
Функция ПолучитьПоказанияСчетчиковССервиса(мHTTPСоединение, ИдентификаторСессии, ДатаПоследнихЗагруженныхПоказания, ТаблицаСообщений, ВыполняетсяВАвтоматическомРежиме = Ложь)
	
	// Инициализация локальных переменных.
	СообщениеОРезультате = "Загрузка показаний счетчиков выполнена успешно.";
	ВыполненоУспешно     = Истина;
	
	// Переменные для загрузки показаний итеративно.
	КоличествоЗагруженных           = 0;
	КоличествоЗагружаемыхЗаИтерацию = 1000;
	МассивПоказаний                 = Новый Массив;
	
	// Флаг завершения загрузки.
	ЗагрузкаЗавершена = Ложь;
	
	// Массив JSON с ответами каждой итерации.
	МассивОтветовСервера = Новый Массив;
	
	// Выполняем загрузку.
	Пока НЕ ЗагрузкаЗавершена Цикл
		
		Попытка
			ЗаголовкиHTTP = Новый Соответствие;
			ЗаголовкиHTTP.Вставить("Host",         мHTTPСоединение.Сервер);
			ЗаголовкиHTTP.Вставить("Content-Type", "multipart/form-data");
			ЗаголовкиHTTP.Вставить("Cookie",       ИдентификаторСессии);
			
			ТекстЗапроса = СтрШаблон("rarus?where={""from_phone"":""true"",""date"":{"">"":""%1""}}&skip=%2&limit=%3&sort=createdAt DESC", XMLСтрока(ДатаПоследнихЗагруженныхПоказания), XMLСтрока(КоличествоЗагруженных), XMLСтрока(КоличествоЗагружаемыхЗаИтерацию));
			
			ЗапросHTTP = Новый HTTPЗапрос(ТекстЗапроса, ЗаголовкиHTTP);
			
			ОтветHTTP  = мHTTPСоединение.Получить(ЗапросHTTP);
			Ответ      = СокрЛ(ОтветHTTP.ПолучитьТелоКакСтроку());
		Исключение
			УПЖКХ_РаботаССообщениямиСервер.ДобавитьСообщение(ТаблицаСообщений, "Не удалось загрузкить сведения о показаниях счетчиков с сервиса.");
			
			Возврат Неопределено;
		КонецПопытки;
		
		// Дополняем массив JSON с ответами.
		МассивОтветовСервера.Добавить(Ответ);
		
		// Получаем структуру из ответа сервиса (JSON).
		ОбъектОтвета = ПолучитьСтруктуруОбъектаJSON(Ответ);
		
		// Если вместо массива объектов с показаниями счетчиков пришло что-то другое, то уведомляем об этом.
		Если НЕ ТипЗнч(ОбъектОтвета) = Тип("Массив") Тогда
			
			ВыполненоУспешно = Ложь;
			
			Если ТипЗнч(ОбъектОтвета) = Тип("Структура") И ОбъектОтвета.Свойство("msg") Тогда
				СообщениеОРезультате = СтрШаблон("Не удалось загрузить показания счетчиков с сервиса: %1.", ОбъектОтвета.msg);
			Иначе
				СообщениеОРезультате = "Не удалось загрузить показания счетчиков с сервиса.";
			КонецЕсли;
			
			ОбъектОтвета = Неопределено;
			
			// Так как есть ошибки - завершаем загрузку.
			ЗагрузкаЗавершена = Истина;
		Иначе
			
			// Если выполнено успешно, то дополняем массив показаний загруженными.
			Для каждого ТекПоказание из ОбъектОтвета Цикл
				МассивПоказаний.Добавить(ТекПоказание);
			КонецЦикла;
			
			// Смещаем итерируемые переменные.
			КоличествоЗагруженныхЗаТекущуюИтерацию = ОбъектОтвета.Количество();
			КоличествоЗагруженных                  = КоличествоЗагруженных + КоличествоЗагруженныхЗаТекущуюИтерацию;
			
			// Проверяем, завершать ли загрузку.
			Если КоличествоЗагруженныхЗаТекущуюИтерацию < КоличествоЗагружаемыхЗаИтерацию Тогда
				ЗагрузкаЗавершена = Истина;
			КонецЕсли;
		КонецЕсли;
		
	КонецЦикла;
	
	// Закрываем массив JSON.
	СтрокаОтветов = СтрШаблон("[%1]", СтрСоединить(МассивОтветовСервера, ",
	|"));
	
	// Отправляем на вывод сообщение о результате обмена.
	УПЖКХ_РаботаССообщениямиСервер.ДобавитьСообщение(ТаблицаСообщений, СообщениеОРезультате);
	
	// Формируем файл для сохранения в журнале регистрации.
	ИмяФайла = УПЖКХ_ИнтеграцияСГолосовымиСервисамиВзаимодействиеСБазойДанных.СформироватьТекстовыйФайл(СтрокаОтветов);
	
	// Создаем запись в журнале регистрации.
	УПЖКХ_ИнтеграцияСГолосовымиСервисамиВзаимодействиеСБазойДанных.СоздатьЗаписьЖурналаРегистрации(ИмяФайла, СообщениеОРезультате, Перечисления.УПЖКХ_ВидыОбменаСГолосовымиСервисами.ЗагрузкаДанных, ВыполненоУспешно, ?(ВыполненоУспешно, "", СтрокаОтветов),, ВыполняетсяВАвтоматическомРежиме);
	
	Возврат МассивПоказаний;
	
КонецФункции

// Получает с сервиса информацию о имеющихся на нем лицевых счетах.
//
Функция ПолучитьЛСИмеющиесяНаСервисе(мHTTPСоединение, ТаблицаСообщений, ВыполняетсяВАвтоматическомРежиме = Ложь)
	
	СообщениеОРезультате = "Получение с сервиса сведений о наличии лицевых счетов выполнено успешно.";
	ВыполненоУспешно     = Истина;
	МассивЛС             = Новый Массив;
	
	Попытка
		ЗапросHTTP = Новый HTTPЗапрос("m_0001/get_ids?token=" + ПолучитьТокенДляBasicАвторизацииНаОснованииHTTPСоединения(мHTTPСоединение));
		ЗапросHTTP.Заголовки["Host"]         = мHTTPСоединение.Сервер;
		ЗапросHTTP.Заголовки["Content-Type"] = "application/x-www-form-urlencoded";
		
		ОтветHTTP = мHTTPСоединение.ОтправитьДляОбработки(ЗапросHTTP);
		Ответ     = СокрЛ(ОтветHTTP.ПолучитьТелоКакСтроку());
	Исключение
		
		УПЖКХ_РаботаССообщениямиСервер.ДобавитьСообщение(ТаблицаСообщений, "Не удалось получить с сервиса сведения о наличии лицевых счетов.", Перечисления.УПЖКХ_ВидыСообщений.СообщениеОбОшибке);
		
		Возврат МассивЛС;
	КонецПопытки;
	
	// Получаем структуру из ответа сервиса (JSON).
	ОбъектОтвета = ПолучитьСтруктуруОбъектаJSON(Ответ);
	
	// Проверяем успешность запроса.
	Если ТипЗнч(ОбъектОтвета) = Тип("Массив") Тогда
		
		МассивЛС = ОбъектОтвета;
		
	Иначе
		// Если не удалось получить сведения по л/с, то выводим сообщение.
		ВыполненоУспешно = Ложь;
		
		Если ТипЗнч(ОбъектОтвета) = Тип("Структура") И ОбъектОтвета.Свойство("msg") Тогда
			СообщениеОРезультате = СтрШаблон("Не удалось получить с сервиса сведения о наличии лицевых счетов: %1.", ОбъектОтвета.msg);
		Иначе
			СообщениеОРезультате = "Не удалось получить с сервиса сведения о наличии лицевых счетов.";
		КонецЕсли;
		
		УПЖКХ_РаботаССообщениямиСервер.ДобавитьСообщение(ТаблицаСообщений, СообщениеОРезультате, Перечисления.УПЖКХ_ВидыСообщений.СообщениеОбОшибке);
	КонецЕсли;
	
	// Записываем ответ сервера в текст JSON.
	ИмяФайла = УПЖКХ_ИнтеграцияСГолосовымиСервисамиВзаимодействиеСБазойДанных.СформироватьТекстовыйФайл(Ответ);
	
	// Создаем запись в журнале регистрации.
	УПЖКХ_ИнтеграцияСГолосовымиСервисамиВзаимодействиеСБазойДанных.СоздатьЗаписьЖурналаРегистрации(ИмяФайла, СообщениеОРезультате, Перечисления.УПЖКХ_ВидыОбменаСГолосовымиСервисами.ПолучениеСведенийОНаличииЛСНаСервисе, ВыполненоУспешно, ?(ВыполненоУспешно, "", Ответ),, ВыполняетсяВАвтоматическомРежиме);
	
	Возврат МассивЛС;
	
КонецФункции

// Отправляет запрос на удаление закрытых лицевых счетов на сервисе.
//
Процедура ОтправитьЗапросНаУдалениеЗакрытыхЛС(мHTTPСоединение, ТаблицаСообщений, МассивЗакрытыхЛС, ВыполняетсяВАвтоматическомРежиме = Ложь)
	
	ВыполненоУспешно     = Истина;
	СообщениеОРезультате = "Удаление закрытых лицевых счетов выполнено успешно.";
	ТекстОбъектаJSON     = СформироватьОбъектJSONИзСтруктуры(Новый Структура("accs", МассивЗакрытыхЛС));
	
	Попытка
		ЗапросHTTP = Новый HTTPЗапрос("m_0001/remove?token=" + ПолучитьТокенДляBasicАвторизацииНаОснованииHTTPСоединения(мHTTPСоединение));
		ЗапросHTTP.Заголовки["Host"]         = мHTTPСоединение.Сервер;
		ЗапросHTTP.Заголовки["Content-Type"] = "application/x-www-form-urlencoded";
		ЗапросHTTP.УстановитьТелоИзСтроки(СтрШаблон("data=%1", ТекстОбъектаJSON), КодировкаТекста.UTF8, ИспользованиеByteOrderMark.НеИспользовать);
		
		ОтветHTTP = мHTTPСоединение.ОтправитьДляОбработки(ЗапросHTTP);
		Ответ     = СокрЛ(ОтветHTTP.ПолучитьТелоКакСтроку());
	Исключение
		
		УПЖКХ_РаботаССообщениямиСервер.ДобавитьСообщение(ТаблицаСообщений, "Не удалось выполнить удаление закрытых лицевых счетов на сервисе.", Перечисления.УПЖКХ_ВидыСообщений.СообщениеОбОшибке);
		Ответ = "";
		
	КонецПопытки;
	
	// Получаем структуру из ответа сервиса (JSON).
	ОбъектОтвета = ПолучитьСтруктуруОбъектаJSON(Ответ);
	
	// Проверяем успешность запроса.
	Если ТипЗнч(ОбъектОтвета) = Тип("Структура")
	   И ОбъектОтвета.Свойство("success") Тогда
		
		Если НЕ ОбъектОтвета.success Тогда
			
			// Если не удалось удалить л/с, то выводим сообщение.
			Если ОбъектОтвета.Свойство("msg") Тогда
				СообщениеОРезультате = СтрШаблон("Не удалось выполнить удаление закрытых лицевых счетов на сервисе: %1.", ОбъектОтвета.msg);
			Иначе
				СообщениеОРезультате = "Не удалось выполнить удаление закрытых лицевых счетов на сервисе.";
			КонецЕсли;
			
			УПЖКХ_РаботаССообщениямиСервер.ДобавитьСообщение(ТаблицаСообщений, "Не удалось выполнить удаление закрытых лицевых счетов на сервисе.", Перечисления.УПЖКХ_ВидыСообщений.СообщениеОбОшибке);
			
		КонецЕсли;
		
	Иначе
		// Если не удалось удалить л/с, то выводим сообщение.
		СообщениеОРезультате = "Не удалось выполнить удаление закрытых лицевых счетов на сервисе.";
		
		УПЖКХ_РаботаССообщениямиСервер.ДобавитьСообщение(ТаблицаСообщений, "Не удалось выполнить удаление закрытых лицевых счетов на сервисе.", Перечисления.УПЖКХ_ВидыСообщений.СообщениеОбОшибке);
	КонецЕсли;
	
	// Формируем файл для сохранения в журнале регистрации.
	ИмяФайла = УПЖКХ_ИнтеграцияСГолосовымиСервисамиВзаимодействиеСБазойДанных.СформироватьТекстовыйФайл(ТекстОбъектаJSON);
	
	// Создаем запись в журнале регистрации.
	УПЖКХ_ИнтеграцияСГолосовымиСервисамиВзаимодействиеСБазойДанных.СоздатьЗаписьЖурналаРегистрации(ИмяФайла, СообщениеОРезультате, Перечисления.УПЖКХ_ВидыОбменаСГолосовымиСервисами.УдалениеЗакрытыхЛицевыхСчетов, ВыполненоУспешно, Ответ,, ВыполняетсяВАвтоматическомРежиме);
	
КонецПроцедуры

#КонецОбласти

////////////////////////////////////////////////////////////////////////////////
// ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ ОБМЕНА С СЕРВИСОМ

#Область ВспомогательныеФункцииОбменаССервисом

// Формирует пустую таблицу сообщений.
//
Функция ПолучитьНовуюТаблицуСообщений()
	
	ТаблицаСообщений = Новый ТаблицаЗначений;
	ТаблицаСообщений.Колонки.Добавить("ТекстСообщения");
	ТаблицаСообщений.Колонки.Добавить("ВидСообщения");
	
	Возврат ТаблицаСообщений;
	
КонецФункции

// Формирует массив различных лицевых счетов переданной таблицы.
//
Функция ПолучитьМассивЛСДляВыгрузки(ТаблицаЛС)
	
	ЛицевыеСчета = ТаблицаЛС.Скопировать(, "ЛицевойСчет");
	ЛицевыеСчета.Свернуть("ЛицевойСчет");
	
	Возврат ЛицевыеСчета.ВыгрузитьКолонку("ЛицевойСчет");
	
КонецФункции

// Формирует структуру с данными на основании объекта JSON.
//
Функция ПолучитьСтруктуруОбъектаJSON(ТекстОбъекта) Экспорт
	
	Попытка
		
		ЧтениеJSON = Новый ЧтениеJSON;
		ЧтениеJSON.УстановитьСтроку(ТекстОбъекта);
		
		СтруктураОбъектаJSON = ПрочитатьJSON(ЧтениеJSON);
		
		ЧтениеJSON.Закрыть();
		
	Исключение
		
		Возврат ТекстОбъекта;
		
	КонецПопытки;
	
	Возврат СтруктураОбъектаJSON;
	
КонецФункции

// Формирует объект JSON на основании структуры с данными.
//
Функция СформироватьОбъектJSONИзСтруктуры(СтруктураОбъекта)
	
	Попытка
		
		ИмяФайла = ПолучитьИмяВременногоФайла();
		
		ЗаписьJSON = Новый ЗаписьJSON;
		ЗаписьJSON.ОткрытьФайл(ИмяФайла, "UTF-8",,Новый ПараметрыЗаписиJSON(, Символы.Таб));
		ЗаписатьJSON(ЗаписьJSON, СтруктураОбъекта);
		ЗаписьJSON.Закрыть();
		
		ТекстФайла     = Новый ЧтениеТекста(ИмяФайла, "UTF-8");
		СтрокаПередачи = ТекстФайла.Прочитать();
		
		Возврат СтрокаПередачи;
		
	Исключение
	КонецПопытки;
	
	Возврат "";
	
КонецФункции

// Проверяет необходимость кодирования адреса сайта в punycode.
//
Функция ПроверитьНеобходимостьКодированияАдресаСайта(АдресСайта)
	
	Для ТекСимвол = 1 по СтрДлина(АдресСайта) Цикл
		Код = КодСимвола(АдресСайта, ТекСимвол);
		
		// Если код символа не входит в ASCII, то необходимо кодировать адрес.
		Если Код > 127 Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	
	// Не требует кодирования.
	Возврат Ложь;
	
КонецФункции

// Возвращает домен в виде punycode по стандарту RFC 3492.
//
Функция ЗакодироватьДомен(Домен)
	
	// Массив кодов символов домена.
	МассивКодовСимволовДомена = Новый Массив;
	
	// Переменные.
	КоличествоЗакодированныхСимволов = 0;
	ДлинаДомена         = СтрДлина(Домен);
	ЭтоПервый           = Истина;
	ПрефиксASCII        = "xn--";
	ЧастьДоменаASCII    = "";
	ЧастьДоменаНеASCII  = "";
	ЗакодированныйДомен = "";
	Домен               = НРег(Домен);
	
	// Стандартный переменные и константы алгоритма RFC 3492.
	cur_code = 128;
	delta    = 0;
	base     = 36;
	tmin     = 1;
	tmax     = 26;
	skew     = 38;
	damp     = 700;
	bias     = 72;
	qDelta   = 0;
	kBase    = 0;
	diff     = 0;
	
	// Формирование ASCII части домена.
	Для ТекСимвол = 1 по СтрДлина(Домен) Цикл
		Код = КодСимвола(Домен, ТекСимвол);
		МассивКодовСимволовДомена.Добавить(Код);
		
		Если Код < cur_code Тогда
			КоличествоЗакодированныхСимволов = КоличествоЗакодированныхСимволов + 1;
			ЧастьДоменаASCII                 = ЧастьДоменаASCII + Символ(Код);
		КонецЕсли;
	КонецЦикла;
	
	// Проверка необходимости кодирования.
	ДлинаЧастиASCII = СтрДлина(ЧастьДоменаASCII);
	
	Если ДлинаЧастиASCII = ДлинаДомена Тогда
		// Не требует кодирования.
		Возврат ЧастьДоменаASCII;
	Иначе
		// Требуется кодирование.
		
		// Формируем часть ASCII.
		ЧастьДоменаASCII = ПрефиксASCII + ЧастьДоменаASCII + ?(ДлинаЧастиASCII = 0, "", "-");
		
		// Получаем UTF часть (кодируем UTF часть в ASCII).
		Пока КоличествоЗакодированныхСимволов < ДлинаДомена Цикл
			
			Для НомерСимвола = 0 по ДлинаДомена - 1 Цикл
				
				Если МассивКодовСимволовДомена[НомерСимвола] < cur_code Тогда
					
					delta = delta + 1;
					
				ИначеЕсли МассивКодовСимволовДомена[НомерСимвола] = cur_code Тогда
					
					// Стандартные переменные алгоритма.
					qDelta = delta;
					kBase  = base;
					diff   = 0;
					
					Пока Истина Цикл
						Если kBase <= bias Тогда
							diff = tmin;
						ИначеЕсли kBase >= bias + tmax Тогда
							diff = tmax;
						Иначе
							diff = kBase - bias;
						КонецЕсли;
						
						Если qDelta < diff Тогда
							ЧастьДоменаНеASCII = ЧастьДоменаНеASCII + Символ(qDelta + 22 + 75 * (?(qDelta < tmax, 1, 0)));
							Прервать;
						Иначе
							Модификатор = Цел(diff + ((qDelta - diff) % (base - diff)));
							ЧастьДоменаНеASCII = ЧастьДоменаНеASCII + Символ(Модификатор + 22 + 75 * (?(Модификатор < tmax, 1, 0)));
							qDelta = Цел((qDelta - diff) / (base - diff));
						КонецЕсли;
						
						kBase = kBase + base;
					КонецЦикла;
					
					КоличествоЗакодированныхСимволов = КоличествоЗакодированныхСимволов + 1;
					
					Если ЭтоПервый Тогда
						delta = Цел(delta / damp);
					Иначе
						delta = Цел(delta / 2);
					КонецЕсли;
					
					delta     = delta + Цел(delta / КоличествоЗакодированныхСимволов);
					bias      = Цел(base * delta / (delta + skew));
					delta     = 0;
					ЭтоПервый = Ложь;
					
				КонецЕсли;
			КонецЦикла;
			
			delta    = delta + 1;
			cur_code = cur_code + 1;
			
		КонецЦикла;
		
		// Формирование итоговой строки домена.
		ЗакодированныйДомен = ЧастьДоменаASCII + ЧастьДоменаНеASCII;
		
		Возврат ЗакодированныйДомен;
		
	КонецЕсли;
	
КонецФункции

// Проверяет коррекность указанного адрса сайта. При необходимости кодирует его в punycode.
//
Функция ЗакодироватьАдресСайта(Знач АдресСайта)
	
	Если ПроверитьНеобходимостьКодированияАдресаСайта(АдресСайта) Тогда
		
		АдресСайта = АдресСайта + ".";
		ЗакодированныйАдресСайта = "";
		
		// Массив доменов URL сайта.
		МассивДоменов = Новый Массив;
		
		// Разбиваем адрес на субдомены.
		ПозицияРазделителя = Найти(АдресСайта, ".");
		
		Пока НЕ ПозицияРазделителя = 0 Цикл
			МассивДоменов.Добавить(Лев(АдресСайта, ПозицияРазделителя - 1));
			
			АдресСайта         = Прав(АдресСайта, СтрДлина(АдресСайта) - ПозицияРазделителя);
			ПозицияРазделителя = Найти(АдресСайта, ".");
		КонецЦикла;
		
		// Кодируем каждый субдомен по отдельности и добавляем к итоговой строке адреса.
		Если НЕ МассивДоменов.Количество() = 0 Тогда
			
			// Формируем итоговую строку адреса.
			Для каждого ТекДомен из МассивДоменов Цикл
				ЗакодированныйАдресСайта = ЗакодированныйАдресСайта + ЗакодироватьДомен(ТекДомен) + ".";
			КонецЦикла;
			
			// Удаляем точку из строки.
			ДлинаИтоговойСтроки = СтрДлина(ЗакодированныйАдресСайта);
			
			Если НЕ ДлинаИтоговойСтроки = 0 Тогда
				ЗакодированныйАдресСайта = Лев(ЗакодированныйАдресСайта, ДлинаИтоговойСтроки - 1);
			КонецЕсли;
			
		КонецЕсли;
		
		Возврат ЗакодированныйАдресСайта;
		
	Иначе
		Возврат АдресСайта;
	КонецЕсли;
	
КонецФункции

// Возвращает сокращенное имя файла из полного пути.
//
Функция ПолучитьИмяФайлаИзПолногоПути(ПолныйПуть)
	
	ИмяФайла = ПолныйПуть;
	
	ПозицияРазделителя = СтрНайти(ПолныйПуть, "\", НаправлениеПоиска.СКонца);
	
	Если ПозицияРазделителя = 0 Тогда
		ПозицияРазделителя = СтрНайти(ПолныйПуть, "/", НаправлениеПоиска.СКонца);
	КонецЕсли;
	
	Если НЕ ПозицияРазделителя = 0 Тогда
		ИмяФайла = Прав(ИмяФайла, СтрДлина(ИмяФайла) - ПозицияРазделителя);
	КонецЕсли;
	
	Возврат ИмяФайла;
	
КонецФункции // ПолучитьИмяФайлаИзПолногоПути()

#КонецОбласти

////////////////////////////////////////////////////////////////////////////////
// РЕГЛАМЕНТНОЕ ЗАДАНИЕ

#Область РегламентноеЗадание

// Выполняет обмен с сервисом мобильного приложения по регламентному заданию.
//
Процедура ОбменСГолосовымиСервисами(ВидОбмена, СтруктураОтбораФайлаИзЖурналаОбмена = Неопределено) Экспорт
	
	Если ВидОбмена = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	ТаблицаСообщений = ПолучитьНовуюТаблицуСообщений();
	
	// Если пытаемся повторно загрузить показания из файла, то нам не нужно подключаться к сервисам.
	Если ВидОбмена = Перечисления.УПЖКХ_ВидыОбменаСГолосовымиСервисами.ПовторнаяЗагрузкаПоказанийИзФайла Тогда
		
		ВыполнитьПовторнуюЗагрузкуПоказанийИзФайла(ТаблицаСообщений, СтруктураОтбораФайлаИзЖурналаОбмена);
		
	Иначе
		
		НастройкиИнтеграцииСГолосовымиСервисами = УПЖКХ_ИнтеграцияСГолосовымиСервисамиВзаимодействиеСБазойДанных.ПолучитьНастройкиИнтеграцииСГолосовымиСервисами();
		
		// Если не оплачено, то ничего не делаем.
		СведенияОПодписке = ПолучитьСведенияОбУчетнойЗаписи(НастройкиИнтеграцииСГолосовымиСервисами.ПерсональныйURL, НастройкиИнтеграцииСГолосовымиСервисами.Логин, НастройкиИнтеграцииСГолосовымиСервисами.Пароль);
		
		Если СведенияОПодписке.ВыполненоУспешно Тогда
			
			мHTTPСоединение = ПолучитьHTTPСоединение(НастройкиИнтеграцииСГолосовымиСервисами.ПерсональныйURL, НастройкиИнтеграцииСГолосовымиСервисами.Логин, НастройкиИнтеграцииСГолосовымиСервисами.Пароль);
			
			// Авторизация.
			ИдентификаторСессии = АвторизоватьсяНаСервисе(мHTTPСоединение, ТаблицаСообщений);
			
			Если ПустаяСтрока(ИдентификаторСессии) Тогда
				Возврат;
			КонецЕсли;
			
			// Выполнение обмена.
			Если ВидОбмена = Перечисления.УПЖКХ_ВидыОбменаСГолосовымиСервисами.ВыгрузкаДанных Тогда
				УдалитьССервисаЗакрытыеЛС(мHTTPСоединение, ТаблицаСообщений,, Истина);
				ВыгрузитьСведенияПоЛСНаСервис(мHTTPСоединение, ИдентификаторСессии, ТаблицаСообщений, СведенияОПодписке,,, Истина);
			ИначеЕсли ВидОбмена = Перечисления.УПЖКХ_ВидыОбменаСГолосовымиСервисами.ЗагрузкаДанных Тогда
				ЗагрузитьПоказанияСчетчиковССервиса(мHTTPСоединение, ИдентификаторСессии, ТаблицаСообщений, СведенияОПодписке, Истина);
			ИначеЕсли ВидОбмена = Перечисления.УПЖКХ_ВидыОбменаСГолосовымиСервисами.ПовторнаяВыгрузкаДанных Тогда
				ВыполнитьПовторнуюВыгрузкуФайла(мHTTPСоединение, ИдентификаторСессии, ТаблицаСообщений, СтруктураОтбораФайлаИзЖурналаОбмена);
			КонецЕсли;
			
			// Завершение сессии.
			ЗавершитьСессию(мHTTPСоединение, ИдентификаторСессии, ТаблицаСообщений);
			
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти

/////////////////////////////////////////////////////////////////////////
// ФУНКЦИОНАЛ ОТЛАДКИ

#Область ФункционалОтладки

// Выполняет повторную выгрузку отправленного ранее файла.
//
Процедура ВыполнитьПовторнуюВыгрузкуФайла(мHTTPСоединение, ИдентификаторСессии, ТаблицаСообщений, СтруктураОтбора) Экспорт
	
	СведенияОбОшибке = "";
	
	// Создадим массивы для выгрузки файлов.
	МассивФайловОбмена   = Новый Массив;
	МассивОтветовСервера = Новый Массив;
	
	// Определение сведений о файле обмена.
	СтруктураСведенийОФайле = РегистрыСведений.УПЖКХ_ЖурналОбменаСГолосовымиСервисами.ПолучитьСведенияОФайлеОбмена(СтруктураОтбора);
	
	Если НЕ СтруктураСведенийОФайле.СохраненныйФайл = Неопределено Тогда
		
		// Сохраняем файл.
		ИмяФайла = ПолучитьИмяВременногоФайла(СтруктураСведенийОФайле.РасширениеФайла);
		СтруктураСведенийОФайле.СохраненныйФайл.Записать(ИмяФайла);
		
		Если СтруктураСведенийОФайле.РасширениеФайла = "zip" Тогда
			
			Попытка
				
				КаталогВременныхФайлов = КаталогВременныхФайлов();
				
				ФайлАрхива = Новый ЧтениеZIPФайла(ИмяФайла);
				
				Для каждого ТекЗапакованныйФайлАрхива из ФайлАрхива Цикл
					МассивФайловОбмена.Добавить(КаталогВременныхФайлов + ТекЗапакованныйФайлАрхива.Имя);
				КонецЦикла;
				
				ФайлАрхива.ИзвлечьВсе(КаталогВременныхФайлов);
				
				Если МассивФайловОбмена.Количество() = 0 Тогда
					ВызватьИсключение "архив не содержит файлов обмена.";
				КонецЕсли;
				
			Исключение
				УПЖКХ_ТиповыеМетодыКлиентСервер.СообщитьОбОшибке("Не удалось открыть файл: " + ОписаниеОшибки());
			КонецПопытки;
			
		// Если файл не является архивом, добавляем его в массив файлов.
		Иначе
			
			МассивФайловОбмена.Добавить(ИмяФайла);
			
		КонецЕсли;
		
		// Передаем файлы на сайт.
		Для каждого ТекФайл из МассивФайловОбмена Цикл
			
			// Извлекаем содержимое текущего файла обмена.
			ЧтениеФайла      = Новый ЧтениеТекста(ТекФайл);
			ТекстОбъектаJSON = ЧтениеФайла.Прочитать();
			ЧтениеФайла.Закрыть();
			
			ПередатьДанныеНаСервисИПолучитьОтветы(мHTTPСоединение, ИдентификаторСессии, ТекстОбъектаJSON, ТаблицаСообщений, ТекФайл, МассивОтветовСервера);
			
		КонецЦикла;
		
		ОбработатьРезультатыВыгрузкиДанныхНаСервис(МассивФайловОбмена, МассивОтветовСервера, ТаблицаСообщений, Перечисления.УПЖКХ_ВидыОбменаСГолосовымиСервисами.ПовторнаяВыгрузкаДанных, Ложь);
		
	КонецЕсли;
	
КонецПроцедуры

// Выполняет повторную загрузку показаний из полученного ранее файла.
//
Процедура ВыполнитьПовторнуюЗагрузкуПоказанийИзФайла(ТаблицаСообщений, СтруктураОтбора)
	
	// Определение сведений о файле обмена.
	СтруктураСведенийОФайле = РегистрыСведений.УПЖКХ_ЖурналОбменаСГолосовымиСервисами.ПолучитьСведенияОФайлеОбмена(СтруктураОтбора);
	
	УПЖКХ_ИнтеграцияСГолосовымиСервисамиВзаимодействиеСБазойДанных.ЗагрузитьПоказанияСчетчиковИзФайлаОбмена(СтруктураСведенийОФайле.СохраненныйФайл, СтруктураСведенийОФайле.РасширениеФайла, ТаблицаСообщений, Перечисления.УПЖКХ_ВидыОбменаСГолосовымиСервисами.ПовторнаяЗагрузкаПоказанийИзФайла, Ложь);
	
КонецПроцедуры

#КонецОбласти

