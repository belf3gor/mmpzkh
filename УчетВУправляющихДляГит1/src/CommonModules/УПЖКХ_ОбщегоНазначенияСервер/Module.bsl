// Общие процедуры и функции; неглобальный модуль.
// Изменения в модуле запрещены, текст включается.


///////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ОПРЕДЕЛЕНИЯ ПАРАМЕТРОВ ПО РЕГИОНАМ

#Область ПроцедурыИФункцииОпределенияПараметровПоРегионам

// Возвращает признак доступности доп.настроек в справочнике "Услуги".
Функция ДоступнаНастройкаВыбораНормОграниченияДляСоставныхУслуг() Экспорт
	
	Возврат Константы.УПЖКХ_НастройкаНижегородскаяОбласть.Получить();
	
КонецФункции // ДоступнаНастройкаВыбораНормОграниченияДляСоставныхУслуг()

#КонецОбласти

////////////////////////////////////////////////////////////////////////////////
// ВСПОМОГАТЕЛЬНЫЕ ПРОЦЕДУРЫ И ФУНКЦИИ

#Область ВспомогательныеПроцедурыИФункции

// Создает структуру из свойств объекта.
Функция ПолучитьСтруктуруСвойствСвойства(Свойство) Экспорт 
	
	Структура = Новый Структура;
	Структура.Вставить("НазначениеСвойства", Свойство.НазначениеСвойства);
	Структура.Вставить("Наименование", Свойство.Наименование);
	Структура.Вставить("ТипЗначения", Свойство.ТипЗначения);
	
	Возврат Структура;
	
КонецФункции // ПолучитьСтруктуруСвойствСвойства()

// Определяет тип значения Элемента.
Функция ПолучитьТипЗначения(Элемент) Экспорт 
	
	Возврат Элемент.ТипЗначения;
	
КонецФункции // ПолучитьТипЗначения()

// Функция возвращает значение основной ставки НДС по умолчанию.
Функция ПолучитьЗначениеОсновнойСтавкиНДСПоУмолчанию(Дата, Пользователь = Неопределено) Экспорт
	
	// Для ЖКХ 2.0 и 3.0
	ОсновнаяСтавкаНДС = ОбщегоНазначенияБПВызовСервера.ПолучитьЗначениеПоУмолчанию("ОсновнаяСтавкаНДС", Пользователь);
	
	// Для УПЖКХ
	// ОсновнаяСтавкаНДС = УправлениеПользователями.ПолучитьЗначениеПоУмолчанию("ОсновнаяСтавкаНДС", Пользователь);
	
	// Если в настройке "ОсновнаяСтавкаНДС" хранится перечисление "СтавкиНДС",
	// то сначала определим вид этой ставки.
	Если ТипЗнч(ОсновнаяСтавкаНДС) = Тип("ПеречислениеСсылка.СтавкиНДС") Тогда
		ОсновнаяСтавкаНДС = Перечисления.ВидыСтавокНДС.ВидСтавки(ОсновнаяСтавкаНДС);
	КонецЕсли;
	
	Возврат Перечисления.СтавкиНДС.СтавкаНДС(ОсновнаяСтавкаНДС, Дата);
	
КонецФункции

///////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ПРОЧИЕ

// Функция заменяет в строке Источник символы из набора ШаблонИсключений
// на символ Нормализатор;
// если в наборе НормальныйШаблон присутствует символ Нормализатора,
// то нормализация происходит на пустой символ.
//  
Функция НормализоватьСтроку(Знач Источник, Знач ШаблонИсключений="\/:*?""<>|", Знач Нормализатор="") Экспорт
    
    Если Не ПустаяСтрока(Нормализатор) И Не Найти(ШаблонИсключений, Нормализатор) = 0 Тогда
 		Нормализатор = "";
    КонецЕсли;
    
    Источник = СокрЛП(Источник);
    ДлинаШаблона = СтрДлина(ШаблонИсключений);
	Для НомерСимвола = 1 По ДлинаШаблона Цикл
		ЗаменяемыйСимвол = Сред(ШаблонИсключений, НомерСимвола, 1);
		Если Найти(Источник, ЗаменяемыйСимвол) > 0 Тогда
    		Источник = СтрЗаменить(Источник, ЗаменяемыйСимвол, Нормализатор);
		КонецЕсли;
    КонецЦикла;
    
    Возврат Источник;
	
КонецФункции //НормализоватьСтроку()

// Возвращает список сокращений из справочника "Адресные сокращения".
// Если справочник пустой или нет сокращений определенного уровня, то
// возвращается стандартный набор сокращений.
//
Функция ПолучитьСписокСокращений(Уровень = 7) Экспорт 
	
	СписокСокращений = Новый Массив;
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ РАЗЛИЧНЫЕ
	|	АдресныеОбъекты.Сокращение
	|ИЗ
	|	РегистрСведений.АдресныеОбъекты КАК АдресныеОбъекты
	|ГДЕ
	|	АдресныеОбъекты.Уровень = &Уровень";
	
	Запрос.УстановитьПараметр("Уровень", Уровень);
	
	РезультатЗапроса = Запрос.Выполнить().Выгрузить();
	
	Для Каждого Сокращение Из РезультатЗапроса Цикл
		СписокСокращений.Добавить(СокрЛП(Сокращение.Сокращение));
	КонецЦикла;
	
	Если СписокСокращений.Количество() = 0 Тогда
		
		СписокСокращений.Добавить("г");
		СписокСокращений.Добавить("пгт");
		СписокСокращений.Добавить("д");
		СписокСокращений.Добавить("п");
		СписокСокращений.Добавить("ст");
		СписокСокращений.Добавить("ул");
		СписокСокращений.Добавить("пер");
		СписокСокращений.Добавить("пр-кт");
		СписокСокращений.Добавить("проезд");
		СписокСокращений.Добавить("б-р");
		СписокСокращений.Добавить("пл");
		СписокСокращений.Добавить("парк");
		СписокСокращений.Добавить("сквер");
		
	КонецЕсли;
	
	Возврат СписокСокращений;
	
КонецФункции // ПолучитьСписокСокращений()

// Удаляет сокращения из строки.
//
Функция УдалитьСокращение(СтрокаОбработки, СписокСокращений) Экспорт
	
	РезультатСтрока = "";
	
	СтрокаДляОбработки = СокрЛП(СтрокаОбработки);
	КоличествоПробелов = СтрЧислоВхождений(СтрокаДляОбработки, " ");
	Если НЕ КоличествоПробелов = 0 Тогда 
		
		Для Счет = 0 По КоличествоПробелов Цикл
			
			СтрокаПоиска   = Сред(СтрокаДляОбработки, 0, Найти(СтрокаДляОбработки, " ") - 1);
			СтрокаПоиска_1 = НРег(СтрокаПоиска);
			СтрокаПоиска_2 = НРег(Сред(СтрокаПоиска_1, 0, СтрДлина(СтрокаПоиска_1) - 1));
			
			Если СтрДлина(СтрокаПоиска_2) < 2 Тогда
				СтрокаПоиска_2 = СтрокаПоиска_1;
			КонецЕсли;
			
			Если Счет = 0 ИЛИ Счет = КоличествоПробелов Тогда 
				
				Если СписокСокращений.Найти(СтрокаПоиска_1) = Неопределено
					И СписокСокращений.Найти(СтрокаПоиска_2) = Неопределено Тогда
					РезультатСтрока = РезультатСтрока + СтрокаПоиска + " ";
				КонецЕсли;
				
			Иначе
				РезультатСтрока = РезультатСтрока + СтрокаПоиска + " ";
			КонецЕсли;
			
			СтрокаДляОбработки = Сред(СтрокаДляОбработки, Найти(СтрокаДляОбработки, " ") + 1, СтрДлина(СтрокаДляОбработки));
			
		КонецЦикла;
		
	Иначе
		РезультатСтрока = СтрокаОбработки;
	КонецЕсли;
	
	Возврат РезультатСтрока;
	
КонецФункции // УдалитьСокращение()

// Возвращает значение константы "ТочностьОбъемаНачислений".
//
Функция ПолучитьТочностьОбъемовНачислений() Экспорт
	
	Возврат Константы.УПЖКХ_ТочностьОбъемаНачислений.Получить();
	
КонецФункции // ПолучитьТочностьОбъемовНачислений()

// Определяет уровень расположения элемента в иерархии справочника.
//
Функция СправочникПолучитьУровеньЭлемента(СправочникСсылка) Экспорт
	
	Возврат СправочникСсылка.Уровень();
	
КонецФункции // СправочникПолучитьУровеньЭлемента()

// Определяет, является ли элемент группой.
//
Функция СправочникГруппа(СправочникСсылка) Экспорт 
	
	Возврат СправочникСсылка.ЭтоГруппа;
	
КонецФункции // СправочникГруппа()

// Определяет родителя элемента справочника.
//
Функция СправочникРодитель(СправочникСсылка) Экспорт 
	
	Возврат СправочникСсылка.Родитель;
	
КонецФункции

// Определяет владельца элемента справочника.
//
Функция СправочникВладелец(СправочникСсылка) Экспорт 
	
	Возврат СправочникСсылка.Владелец;
	
КонецФункции // СправочникВладелец()

// Функция получает ссылку на элемент справочника по строке УИД
//
// Параметры:
//  ИмяСправочника	 - Строка 	 - Имя справочника, для которого надо получить ссылку
//  СтрокаУИД		 - Строка 	 - Уникальный идентификатор в виде строки
// 
// Возвращаемое значение:
//  Ссылка - Ссылка на элемент справочника.
//
Функция ПолучитьСсылкуНаЭлементСправочникаПоСтрокеУИД(ИмяСправочника, СтрокаУИД) Экспорт
	
	УИД = Новый УникальныйИдентификатор(СтрокаУИД);
	
	Возврат Справочники[ИмяСправочника].ПолучитьСсылку(УИД);
	
КонецФункции

// Определяет банк, обслуживающий организацию.
//
Функция ПолучитьБанкОрганизации(ОрганизацияСсылка) Экспорт
	
	Возврат ОрганизацияСсылка.ОсновнойБанковскийСчет.Банк;
	
КонецФункции // ПолучитьБанкОрганизации()

// Формирует список элементов, не содержащихся в массиве исключений.
//
Функция ПолучитьЗначенияПеречисления(ПеречислениеСсылка, МассивИсключений) Экспорт 
	
	СписокВидов = Новый СписокЗначений();
	
	Для каждого ЭлементЗаполнения из ПеречислениеСсылка.Метаданные().ЗначенияПеречисления Цикл
		Если МассивИсключений.Найти(ЭлементЗаполнения.Имя) = Неопределено Тогда
			СписокВидов.Добавить(ЭлементЗаполнения.Имя, ЭлементЗаполнения.Синоним);
		КонецЕсли;
	КонецЦикла;

	Возврат СписокВидов;
	
КонецФункции // ПолучитьЗначенияПеречисления()

// Определяет значение перечисления.
//
Функция ПолучитьЗначениеПеречисления(ПеречислениеСсылка, Значение) Экспорт 
	
	Возврат Перечисления[ПеречислениеСсылка.Метаданные().Имя][Значение];
	
КонецФункции // ПолучитьЗначениеПеречисления()

// Функция возвращает значения реквизита объекта.
Функция ПолучитьЗначениеРеквизита(Ссылка, ИмяРеквизита) Экспорт
	
	Попытка
		Возврат Ссылка[ИмяРеквизита];
	Исключение
		Возврат Неопределено;
	КонецПопытки;
	
КонецФункции

// Функция выполняет сравнение двух таблиц значений.
Функция СравнитьТаблицыНаборовЗаписей(ТаблицаЗначений1, ТаблицаЗначений2) Экспорт

	Если ТипЗнч(ТаблицаЗначений1) <> Тип("ТаблицаЗначений") ИЛИ ТипЗнч(ТаблицаЗначений2) <> Тип("ТаблицаЗначений") Тогда
		Возврат Ложь;
	КонецЕсли; 
	
	Если ТаблицаЗначений1.Количество() <> ТаблицаЗначений2.Количество() Тогда
		Возврат Ложь;
	КонецЕсли; 

	Если ТаблицаЗначений1.Колонки.Количество() <> ТаблицаЗначений2.Колонки.Количество() Тогда
		Возврат Ложь;
	КонецЕсли;
	
	// Проверим поля
	Для каждого Колонка Из ТаблицаЗначений1.Колонки Цикл
		Если ТаблицаЗначений2.Колонки.Найти(Колонка.Имя) = Неопределено Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла; 
	Для каждого Колонка Из ТаблицаЗначений2.Колонки Цикл
		Если ТаблицаЗначений1.Колонки.Найти(Колонка.Имя) = Неопределено Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла; 
	
	// сформируем строку индекса для оптимизации поиска по таблице значений
	СтрокаИндекса = "";
	Для каждого Колонка Из ТаблицаЗначений1.Колонки Цикл
		Если СтрокаИндекса = "" Тогда
			СтрокаИндекса = Колонка.Имя;
		Иначе
			СтрокаИндекса = СтрокаИндекса+","+Колонка.Имя;
		КонецЕсли;
	КонецЦикла;
	// добавим индекс
	ТаблицаЗначений2.Индексы.Добавить(СтрокаИндекса);
	
	// Проверим записи
	Для каждого СтрокаТаблицы Из ТаблицаЗначений1 Цикл
		СтруктураПоиска = Новый Структура;
		Для каждого Колонка Из ТаблицаЗначений1.Колонки Цикл
			СтруктураПоиска.Вставить(Колонка.Имя, СтрокаТаблицы[Колонка.Имя]);
		КонецЦикла;
		СтрокиТаблицы2 = ТаблицаЗначений2.НайтиСтроки(СтруктураПоиска);
		Если СтрокиТаблицы2.Количество() <> 1 Тогда
			Возврат Ложь;
		КонецЕсли; 
	КонецЦикла;
	
	// сформируем строку индекса для оптимизации поиска по таблице значений
	СтрокаИндекса = "";
	Для каждого Колонка Из ТаблицаЗначений2.Колонки Цикл
		Если СтрокаИндекса = "" Тогда
			СтрокаИндекса = Колонка.Имя;
		Иначе
			СтрокаИндекса = СтрокаИндекса+","+Колонка.Имя;
		КонецЕсли;
	КонецЦикла;
	// добавим индекс
	ТаблицаЗначений1.Индексы.Добавить(СтрокаИндекса);
	
	Для каждого СтрокаТаблицы Из ТаблицаЗначений2 Цикл
		СтруктураПоиска = Новый Структура;
		Для каждого Колонка Из ТаблицаЗначений2.Колонки Цикл
			СтруктураПоиска.Вставить(Колонка.Имя, СтрокаТаблицы[Колонка.Имя]);
		КонецЦикла;
		СтрокиТаблицы1 = ТаблицаЗначений1.НайтиСтроки(СтруктураПоиска);
		Если СтрокиТаблицы1.Количество() <> 1 Тогда
			Возврат Ложь;
		КонецЕсли; 
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции // СравнитьТаблицыЗначений()

// Процедура проверяет переданный параметр, если он не соответствует значению, 
// то присваивает ему указанное значение.
//
// Параметры:
//  Параметр - параметр, значение которого проверяется и заполняется.
//  Значение - значение для заполнения пустого параметра.
//
Процедура УстановитьНовоеЗначение(Параметр, Значение) Экспорт

	Если Параметр <> Значение Тогда
		Параметр = Значение;
	КонецЕсли;

КонецПроцедуры

// Заполняет массив-приемник уникальными значениями из массива-источника.
// Если элемент в массиве-приемнике уже существует, то добавления нового элемента не происходит.
//
// Параметры:
//  МассивПриемник – Массив – массив, который заполняется уникальными значениями
//  МассивИсточник – Массив – массив, из которого подбираются элементы в массив-приемник.
// 
Процедура ЗаполнитьМассивУникальнымиЗначениями(МассивПриемник, МассивИсточник) Экспорт
	
	ОбщегоНазначения.ЗаполнитьМассивУникальнымиЗначениями(МассивПриемник, МассивИсточник);
	
КонецПроцедуры // ЗаполнитьМассивУникальнымиЗначениями()

// Процедура убирает лишние пробелы в начале и конце строк одной из колонок таблицы значений.
// 
// Параметры:
//  ТаблицаДанных - ТаблицаЗначений, исходная таблица.
//  ИмяКолонки    - Строка, наименование колонки Таблицы данных, в которой необходимо убрать пробелы.
//
Процедура СокрЛПСтрокиВКолонкеТаблицыЗначений(ТаблицаДанных, ИмяКолонки) Экспорт
	
	Для Каждого СтрокаДанных Из ТаблицаДанных Цикл
		СтрокаДанных[ИмяКолонки] = СокрЛП(СтрокаДанных[ИмяКолонки]);
	КонецЦикла;
	
КонецПроцедуры // СокрЛПСтрокиВКолонкеТаблицыЗначений()

// Процедура обновляет представления ответственного собственника в элементах справочника "Лицевые счета" при необходимости.
//
Процедура УПЖКХ_ОбновитьПредставленияОтветственныхСобственниковЛСПриЗаписи(Источник, Отказ, Замещение = Ложь) Экспорт
	
	// Если производится загрузка данных в рамках обмена РИБ, то обновление представления
	// производить не нужно, так как представление уже определено в данных справочника.
	// Кроме того обновление представления при загрузке в РИБ приводит к ошибке.
	Если Источник.ОбменДанными.Загрузка Тогда
		Возврат;
	КонецЕсли;
	
	Если ТипЗнч(Источник) = Тип("РегистрСведенийНаборЗаписей.УПЖКХ_ОтветственныйСобственникНанимательЛицевогоСчета") Тогда
		
		// Получим регистратор из отбора и количество записей.
		КоличествоЗаписей = Источник.Количество();
		Регистратор = Источник.Отбор.Регистратор.Значение;
		
		// При проведении документа событие вызывается 2 раза: для удаления старого набора и для записи нового.
		// При отмене проведения документа в дополнительные свойства набора записей передается свойство "ЭтоОтменаПроведенияДокумента".
		// Если данного свойства нет в наборе записей, при этом количество записей пустое, то никаких действий не выполняем.
		// Данное свойство добавлено принудительно, так как по-другому отследить факт - выполняется проведение или отмена
		// проведения документа - не представляется возможным.
		Если КоличествоЗаписей = 0 И Не Источник.ДополнительныеСвойства.Свойство("ЭтоОтменаПроведенияДокумента") Тогда
			Возврат;
		КонецЕсли;
		
		// При записи документа "Операция Бух" записи в наборе будут всегда.
		ЭтоОперацияБух = (ТипЗнч(Регистратор) = Тип("ДокументСсылка.ОперацияБух"));
		
		// Формируем исходный массив лицевых счетов.
		МассивЛицевыхСчетовИсходный = Новый Массив;
		Если ЭтоОперацияБух Тогда
			// В Операции Бух лицевых счетов может быть целая таблица.
			МассивЛицевыхСчетовИсходный = Источник.ВыгрузитьКолонку("ЛицевойСчет");
		ИначеЕсли Не Источник.ДополнительныеСвойства.Свойство("ЭтоОтменаПроведенияДокумента") И КоличествоЗаписей > 0 Тогда
			// В документах открытия и изменения л/с - в наборе может быть только 1 строка.
			МассивЛицевыхСчетовИсходный.Добавить(Источник[0].ЛицевойСчет);
		Иначе
			// Если производится отмена проведения, то лицевой счет приходится брать из регистратора.
			МассивЛицевыхСчетовИсходный.Добавить(Регистратор.ЛицевойСчет);
		КонецЕсли;
		
		// Вызов процедуры непосредственного заполнения представлений.
		ЗаполнитьПредставленияОтветственныхСобственниковЛС(МассивЛицевыхСчетовИсходный);
		
	ИначеЕсли ТипЗнч(Источник) = Тип("СправочникОбъект.Контрагенты") Или ТипЗнч(Источник) = Тип("СправочникОбъект.УПЖКХ_Жильцы") Тогда
		
		Если Не Источник.ДополнительныеСвойства.Свойство("НеобходимоОбновитьПредставлениеОтветственногоСобственника") Тогда
			Возврат;
		КонецЕсли;
		
		ЗаполнитьПредставленияОтветственныхСобственниковЛС(, Источник.Ссылка);
		
	КонецЕсли;
	
КонецПроцедуры // УПЖКХ_ОбновитьПредставленияОтветственныхСобственниковЛСПередЗаписью()

// Функция приводит переданную строку к числу. 
// В случае, если корректно произвести преобразование не получается, функция возвращает исходную строку.
//
Функция ПреобразоватьСтрокуВЧисло(Строка) Экспорт
	
	Попытка
		РезультатПреобразования = Число(Строка);
	Исключение
		РезультатПреобразования = Строка;
	КонецПопытки;
	
	Возврат РезультатПреобразования;
	
КонецФункции //Функция ПреобразоватьСтрокуВЧисло()

///////////////////////////////////////////////////////////////////////////////
// РАБОТА С ИДЕНТИФИКАТОРАМИ

// Генерирует уникальный идентификатор.
//
// Параметры
//  ДлинаИдентификатора    – Число – длина идентификатора.
//
// Возвращаемое значение:
//  Строка – сформированный уникальный идентификатор.
//
Функция СгенерироватьИдентификатор(ДлинаИдентификатора, Знач СоставУникЧастиИдентификатора, ДопЧисло = 0)
	
	Если ДлинаИдентификатора < 1 ИЛИ СтрДлина(СоставУникЧастиИдентификатора) = 0 Тогда
		Возврат "";
	КонецЕсли;
	
	// В качестве стартового значения для генерации случайного числа
	// используем текущую дату в милисекундах с прибавлением доп. числа.
	ТекСлЧ = ТекущаяУниверсальнаяДатаВМиллисекундах() + ДопЧисло;
	
	ТекстИд = "";
	ГСЧ = Новый ГенераторСлучайныхЧисел(ТекСлЧ);
	
	МассивНаборов = Новый Массив;
	
	СоставУникЧастиИдентификатора = СоставУникЧастиИдентификатора + ",";
	
	СтрокаСимволов = "";
	Если Найти(СоставУникЧастиИдентификатора, "ВР,") > 0 Тогда
		МассивНаборов.Добавить("ABCDEFGHIJKLMNOPQRSTUVWXYZ");
		СоставУникЧастиИдентификатора = СтрЗаменить(СоставУникЧастиИдентификатора, "ВР,", "");
	КонецЕсли;
	Если Найти(СоставУникЧастиИдентификатора, "НР,") > 0 Тогда
		МассивНаборов.Добавить("abcdefghijklmnopqrstuvwxyz");
		СоставУникЧастиИдентификатора = СтрЗаменить(СоставУникЧастиИдентификатора, "НР,", "");
	КонецЕсли;
	Если Найти(СоставУникЧастиИдентификатора, "Цифры,") > 0 Тогда
		МассивНаборов.Добавить("0123456789");
		СоставУникЧастиИдентификатора = СтрЗаменить(СоставУникЧастиИдентификатора, "Цифры,", "");
	КонецЕсли;
	Если Найти(СоставУникЧастиИдентификатора, "ЗП,") > 0 Тогда
		МассивНаборов.Добавить(",.<>/?;:'[]""{}\|`~!@#$%^&*()-_+=");
		СоставУникЧастиИдентификатора = СтрЗаменить(СоставУникЧастиИдентификатора, "ЗП,", "");
	КонецЕсли;
	
	СоставУникЧастиИдентификатора = СтрЗаменить(СоставУникЧастиИдентификатора, ",", "");
	Если НЕ СоставУникЧастиИдентификатора = "" Тогда
		МассивНаборов.Добавить(СоставУникЧастиИдентификатора);
	КонецЕсли;
	
	КолМассивНаборов = МассивНаборов.Количество();
	Если КолМассивНаборов = 0 Тогда
		Возврат "";
	КонецЕсли;
	
	УпМассивНаборов = Новый Массив(КолМассивНаборов);
	
	тмМаксИндекс = КолМассивНаборов - 1;
	Для Индекс = 0 По КолМассивНаборов - 1 Цикл
		ТекСлЧ = ГСЧ.СлучайноеЧисло(0, тмМаксИндекс);
		УпМассивНаборов[Индекс] = МассивНаборов[ТекСлЧ];
		МассивНаборов.Удалить(ТекСлЧ);
		тмМаксИндекс = тмМаксИндекс - 1;
	КонецЦикла;
	
	ТекИндекс = 0;
	Для Сч = 1 По ДлинаИдентификатора Цикл
		ТекНабор = УпМассивНаборов[ТекИндекс];
		ТекСлЧ = ГСЧ.СлучайноеЧисло(1, СтрДлина(ТекНабор));
		ТекстИд = ТекстИд + Сред(ТекНабор, ТекСлЧ, 1);
		Если ТекИндекс < КолМассивНаборов - 1 Тогда
			ТекИндекс = ТекИндекс + 1;
		Иначе
			ТекИндекс = 0;
		КонецЕсли;
	КонецЦикла;
	
	Возврат ТекстИд;
	
КонецФункции  //СгенерироватьИдентификатор()

// Формирует идентификатор лицевого счета по переданным данным согласно настройкам учетной политики.
//
// Параметры
//  СтрокаНастроек  - Строка - строка, содержащая настройки идентификатора;
//  ПараметрЛС      – Строка - Наименование лицевого счета;
//  ДопЧисло        – Число  – дополнительное число для генерации идентификатора;
//  ПолучитьУникальный - Булево - признак того, что необходимо выполнить несколько попыток генерации;
//                                идентификатора, если уникальный получить не получается сразу.
//
// Возвращаемое значение:
//  Строка – сформированный идентификатор лицевого счета.
//
Функция ПолучитьИдентификаторЛС(СтрокаНастроек = "", ПараметрЛС = "", ДопЧисло = 0, ПолучитьУникальный = Ложь) Экспорт
	
	Если НЕ ЗначениеЗаполнено(СтрокаНастроек) Тогда
		НастройкиИД = Константы.УПЖКХ_НастройкиИдентификатораЛицевогоСчета.Получить();
	Иначе
		НастройкиИД = СтрокаНастроек;
	КонецЕсли;
	ПрефиксИдЛС = Лев(НастройкиИД, Найти(НастройкиИД, ";") - 1);
	
	мСтрока = Сред(НастройкиИД, Найти(НастройкиИД, ";") + 1);
	Попытка
		ИспользоватьРучнойФорматИдентификатораЛС = Булево(Лев(мСтрока, Найти(мСтрока, ";") - 1));
	Исключение
		ИспользоватьРучнойФорматИдентификатораЛС = Ложь;
	КонецПопытки;
	
	мСтрока = Сред(мСтрока, Найти(мСтрока, ";") + 1);
	Попытка
		ДлинаУникЧастиИдЛС = Число(Лев(мСтрока, Найти(мСтрока, ";") - 1));
	Исключение
		ДлинаУникЧастиИдЛС = 0;
	КонецПопытки;
	
	СоставУникЧастиИдЛС = Сред(мСтрока, Найти(мСтрока, ";") + 1);
	
	ИдентификаторЛС = "";
	Если ИспользоватьРучнойФорматИдентификатораЛС Тогда
		
		ПрефиксИдЛС = СокрЛП(ПрефиксИдЛС);
		
		// Если необходимо получать уникальный идентификатор, то будем выполнять
		// несколько попыток до тех пор, пока уникальный идентификатор не будет получен.
		Если ПолучитьУникальный Тогда
			
			// Определим количество попыток получения ИД.
			КоличествоПопытокПолученияИдентификатора = 10;
			
			ИдентификаторПолучен = Ложь;
			
			Для ТекПопытка = 1 По КоличествоПопытокПолученияИдентификатора Цикл
				
				// Генерируем новый идентификатор.
				УникИдентификатор = СгенерироватьИдентификатор(ДлинаУникЧастиИдЛС,
													   СоставУникЧастиИдЛС,
													   ДопЧисло + ТекПопытка);
				ИдентификаторЛС = ПрефиксИдЛС + УникИдентификатор;
				
				// Проверяем уникальность идентификатора.
				ИдУникален = Справочники.КВП_ЛицевыеСчета.ПроверитьУникальностьИдентификатора(ИдентификаторЛС);
				Если ИдУникален Тогда
					ИдентификаторПолучен = Истина;
					Прервать;
				КонецЕсли;
				
			КонецЦикла;
			
			// Если идентификатор так и не получен, сообщим пользователю, что нужно проверить
			// настройки генерации идентификаторов.
			Если Не ИдентификаторПолучен Тогда
				ИдентификаторЛС = "";
				УПЖКХ_ТиповыеМетодыКлиентСервер.СообщитьОбОшибке("Не удалось получить уникальный идентификатор лицевого счета, проверьте настройки генерации!");
			КонецЕсли;
			
		Иначе
			
			// Генерируем новый идентификатор.
			УникИдентификатор = СгенерироватьИдентификатор(ДлинаУникЧастиИдЛС,
												   СоставУникЧастиИдЛС,
												   ДопЧисло);
			ИдентификаторЛС = ПрефиксИдЛС + УникИдентификатор;
			
		КонецЕсли;
		
	Иначе
		СтрокаИд = СокрЛП(ПараметрЛС);
		Для Индекс = 1 По СтрДлина(СтрокаИд) Цикл
			СтрокаСимвол = Сред(СтрокаИд, Индекс, 1);
			Если КодСимвола(СтрокаСимвол) > 47 И КодСимвола(СтрокаСимвол) < 58 Тогда
				ИдентификаторЛС = ИдентификаторЛС + СтрокаСимвол;
			КонецЕсли;
		КонецЦикла;
		ПрефиксИдЛС = СокрЛП(ПрефиксИдЛС);
		ДлинаПрефиксаИдЛС = СтрДлина(ПрефиксИдЛС);
		Пока ДлинаПрефиксаИдЛС + СтрДлина(ИдентификаторЛС) < 3 Цикл
			ИдентификаторЛС = "0" + ИдентификаторЛС;
		КонецЦикла;
		ИдентификаторЛС = ПрефиксИдЛС + ИдентификаторЛС;
	КонецЕсли;
	
	Возврат ИдентификаторЛС;
	
КонецФункции // ПолучитьИдентификаторЛС()

// Формирует идентификатор счетчика по переданным данным согласно настройкам учетной политики.
//
// Параметры
//  СтрокаНастроек  - Строка - строка, содержащая настройки идентификатора;
//  ПараметрСч      – Строка - Наименование прибора учета;
//  ДопЧисло        – Число  – дополнительное число для генерации идентификатора;
//  ПолучитьУникальный - Булево - признак того, что необходимо выполнить несколько попыток генерации
//                                идентификатора, если уникальный получить не получается сразу.
//
// Возвращаемое значение:
//  Строка – сформированный идентификатор счетчика.
//
Функция ПолучитьИдентификаторСчетчика(СтрокаНастроек = "", ПараметрСч = "", ДопЧисло = 0, ПолучитьУникальный = Ложь) Экспорт
	
	Если НЕ ЗначениеЗаполнено(СтрокаНастроек) Тогда
		НастройкиИД = Константы.УПЖКХ_НастройкиИдентификатораПриборовУчета.Получить();
	Иначе
		НастройкиИД = СтрокаНастроек;
	КонецЕсли;
	ПрефиксИдСч = Лев(НастройкиИД, Найти(НастройкиИД, ";") - 1);
	
	мСтрока = Сред(НастройкиИД, Найти(НастройкиИД, ";") + 1);
	Попытка
		ИспользоватьРучнойФорматИдентификатораСч = Булево(Лев(мСтрока, Найти(мСтрока, ";") - 1));
	Исключение
		ИспользоватьРучнойФорматИдентификатораСч = Ложь;
	КонецПопытки;
	
	мСтрока = Сред(мСтрока, Найти(мСтрока, ";") + 1);
	Попытка
		ДлинаУникЧастиИдСч = Число(Лев(мСтрока, Найти(мСтрока, ";") - 1));
	Исключение
		ДлинаУникЧастиИдСч = 0;
	КонецПопытки;
	
	СоставУникЧастиИдСч = Сред(мСтрока, Найти(мСтрока, ";") + 1);
	
	ИдентификаторСч = "";
	Если ИспользоватьРучнойФорматИдентификатораСч Тогда
		
		ПрефиксИдСч = СокрЛП(ПрефиксИдСч);
		
		// Если необходимо получать уникальный идентификатор, то будем выполнять
		// несколько попыток до тех пор, пока уникальный идентификатор не будет получен.
		Если ПолучитьУникальный Тогда
			
			// Определим количество попыток получения ИД.
			КоличествоПопытокПолученияИдентификатора = 10;
			
			ИдентификаторПолучен = Ложь;
			
			Для ТекПопытка = 1 По КоличествоПопытокПолученияИдентификатора Цикл
				
				// Генерируем новый идентификатор.
				УникИдентификатор = СгенерироватьИдентификатор(ДлинаУникЧастиИдСч,
													   СоставУникЧастиИдСч, 
													   ДопЧисло + ТекПопытка);
				ИдентификаторСч = ПрефиксИдСч + УникИдентификатор;
				
				// Проверяем уникальность идентификатора.
				ИдУникален = Справочники.КВП_Счетчики.ПроверитьУникальностьИдентификатора(ИдентификаторСч);
				Если ИдУникален Тогда
					ИдентификаторПолучен = Истина;
					Прервать;
				КонецЕсли;
				
			КонецЦикла;
			
			// Если идентификатор так и не получен, сообщим пользователю, что нужно проверить
			// настройки генерации идентификаторов.
			Если Не ИдентификаторПолучен Тогда
				ИдентификаторСч = "";
				УПЖКХ_ТиповыеМетодыКлиентСервер.СообщитьОбОшибке("Не удалось получить уникальный идентификатор счетчика, проверьте настройки генерации!");
			КонецЕсли;
			
		Иначе
			
			// Генерируем новый идентификатор.
			УникИдентификатор = СгенерироватьИдентификатор(ДлинаУникЧастиИдСч,
													   СоставУникЧастиИдСч, 
													   ДопЧисло);
			ИдентификаторСч = ПрефиксИдСч + УникИдентификатор;
			
		КонецЕсли;
		
	Иначе
		СтрокаИд = СокрЛП(ПараметрСч);
		Для Индекс = 1 По СтрДлина(СтрокаИд) Цикл
			СтрокаСимвол = Сред(СтрокаИд, Индекс, 1);
			Если КодСимвола(СтрокаСимвол) > 47 И КодСимвола(СтрокаСимвол) < 58 Тогда
				ИдентификаторСч = ИдентификаторСч + СтрокаСимвол;
			КонецЕсли;
		КонецЦикла;
		ИдентификаторСч = СокрЛП(ПрефиксИдСч) + ИдентификаторСч;
	КонецЕсли;
	
	Возврат ИдентификаторСч;
	
КонецФункции // ПолучитьИдентификаторСчетчика()

// Формирует идентификатор логина по переданным данным согласно настройкам учетной политики.
//
// Параметры
//  СтрокаНастроек  - Строка - строка, содержащая настройки идентификатора;
//  ПараметрСч      – Строка - Наименование л/с;
//  ДопЧисло        – Число  – дополнительное число для генерации идентификатора;
//
// Возвращаемое значение:
//  Строка – сформированный идентификатор счетчика.
//
Функция ПолучитьИдентификаторЛогина(СтрокаНастроек = "", ПараметрЛогин = "", ДопЧисло = 0) Экспорт
	
	Если НЕ ЗначениеЗаполнено(СтрокаНастроек) Тогда
		НастройкиИД = Константы.УПЖКХ_НастройкиИдентификатораЛогина.Получить();
	Иначе
		НастройкиИД = СтрокаНастроек;
	КонецЕсли;
	ПрефиксИдЛогин = Лев(НастройкиИД, Найти(НастройкиИД, ";") - 1);
	
	мСтрока = Сред(НастройкиИД, Найти(НастройкиИД, ";") + 1);
	Попытка
		ИспользоватьРучнойФорматИдентификатораЛогин = Булево(Лев(мСтрока, Найти(мСтрока, ";") - 1));
	Исключение
		ИспользоватьРучнойФорматИдентификатораЛогин = Ложь;
	КонецПопытки;
	
	мСтрока = Сред(мСтрока, Найти(мСтрока, ";") + 1);
	Попытка
		ДлинаУникЧастиИдЛогин = Число(Лев(мСтрока, Найти(мСтрока, ";") - 1));
	Исключение
		ДлинаУникЧастиИдЛогин = 0;
	КонецПопытки;
	
	СоставУникЧастиИдЛогин = Сред(мСтрока, Найти(мСтрока, ";") + 1);
	
	ИдентификаторЛогин = "";
	Если ИспользоватьРучнойФорматИдентификатораЛогин Тогда
		ПрефиксИдЛогин = СокрЛП(ПрефиксИдЛогин);
		УникИдентификатор = СгенерироватьИдентификатор(ДлинаУникЧастиИдЛогин,
													   СоставУникЧастиИдЛогин, 
													   ДопЧисло);
		ИдентификаторЛогин = ПрефиксИдЛогин + УникИдентификатор;
	Иначе
		СтрокаИд = СокрЛП(ПараметрЛогин);
		Для Индекс = 1 По СтрДлина(СтрокаИд) Цикл
			СтрокаСимвол = Сред(СтрокаИд, Индекс, 1);
			Если КодСимвола(СтрокаСимвол) > 47 И КодСимвола(СтрокаСимвол) < 58 Тогда
				ИдентификаторЛогин = ИдентификаторЛогин + СтрокаСимвол;
			КонецЕсли;
		КонецЦикла;
		ИдентификаторЛогин = СокрЛП(ПрефиксИдЛогин) + ИдентификаторЛогин;
	КонецЕсли;
	
	Возврат ИдентификаторЛогин;
	
КонецФункции // ПолучитьИдентификаторЛогина()

// Формирует пароль доступа лицевого счета для WEB-приложения по переданным данным 
// согласно настройкам учетной политики.
//
// Параметры
//  ЛицевойСчет          – лицевой счет;
//  ПарамУчетнойПолитики – Структура – параметры учетной политики.
//
// Возвращаемое значение:
//  Строка – сформированный пароль доступа.
//
Функция ПолучитьПарольДоступаВеб(СтрокаНастроек = "", ДопЧисло = 0) Экспорт
	
	Если СтрокаНастроек = "" Тогда
		СтрокаНастроек = Константы.УПЖКХ_НастройкиПароляДоступаВеб.Получить();
	КонецЕсли;
	
	ДлинаПароля  = 0;
	СоставПароля = "";
	
	Если Не СтрокаНастроек = "" Тогда
		ПозицияРазделителя = Найти(СтрокаНастроек, ";");
		
		Если Не ПозицияРазделителя = 0 Тогда
			ДлинаПароля  = ЧИСЛО(Лев(СтрокаНастроек, ПозицияРазделителя - 1));
			СоставПароля = Сред(СтрокаНастроек, ПозицияРазделителя + 1);
		КонецЕсли;
	КонецЕсли;
	
	ПарольДоступаВеб = СгенерироватьИдентификатор(ДлинаПароля, СоставПароля, ДопЧисло);
	
	Возврат ПарольДоступаВеб;
	
КонецФункции // ПолучитьПарольДоступаВеб()

///////////////////////////////////////////////////////////////////////////////
// РАБОТА С ОБЪЕКТАМИ УЧЕТА

// Получает значение площади указанного типа для указанной квартиры.
//
// Параметры
//  Квартира         – Справочники.УПЖКХ_Помещения;
//  ВидПлощади       – Справочники.УПЖКХ_ВидыПлощадей;
//  ЛицевойСчет      – Справочники.КВП_ЛицевыеСчета;
//  Период           – Дата;
//  УчитыватьДолю    - Булево;
//  ОкруглятьПлощадь - Булево;
//
// Возвращаемое значение:
//  Число – размер площади.
//
Функция ПолучитьПлощадьКвартиры(Квартира,
								ВидПлощади, 
								ЛицевойСчет = Неопределено,
								Период = Неопределено,
								УчитыватьДолю = Истина,
								ОкруглятьПлощадь = Истина) Экспорт
	
	Если Не СЗК_МодульЗащиты.ЛицензионныйКлючКорректен() Тогда
		Возврат 0;
	КонецЕсли;
	
	Если Период = Неопределено Тогда
		Период = УПЖКХ_ТиповыеМетодыКлиентСервер.ПолучитьРабочуюДату();
	КонецЕсли;
	
	Запрос = Новый Запрос();
	Запрос.УстановитьПараметр("Дата",        Период);
	Запрос.УстановитьПараметр("Объект",      Квартира);
	Запрос.УстановитьПараметр("ВидПлощади",  ВидПлощади);
	Запрос.УстановитьПараметр("ЛицевойСчет", ЛицевойСчет);
	
	Если УчитыватьДолю 
	   И НЕ ЛицевойСчет = Неопределено Тогда
		Запрос.Текст =
		"ВЫБРАТЬ РАЗРЕШЕННЫЕ
		|	ЕСТЬNULL(ВЫБОР
		|			КОГДА КВП_РазмерыДолейСрезПоследних.ДоляЗнаменатель = 0
		|				ТОГДА 0
		|			ИНАЧЕ КВП_ПлощадьПомещенияСрезПоследних.Площадь * КВП_РазмерыДолейСрезПоследних.ДоляЧислитель / КВП_РазмерыДолейСрезПоследних.ДоляЗнаменатель
		|		КОНЕЦ, 0) КАК Площадь
		|ИЗ
		|	РегистрСведений.КВП_ПлощадьПомещения.СрезПоследних(
		|			&Дата,
		|			Объект = &Объект
		|				И ВидПлощади = &ВидПлощади) КАК КВП_ПлощадьПомещенияСрезПоследних
		|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.КВП_РазмерыДолейЛицевыхСчетов.СрезПоследних(
		|				&Дата,
		|				Объект = &Объект
		|					И ЛицевойСчет = &ЛицевойСчет) КАК КВП_РазмерыДолейСрезПоследних
		|		ПО КВП_ПлощадьПомещенияСрезПоследних.Объект = КВП_РазмерыДолейСрезПоследних.Объект";
		
	Иначе
		Запрос.Текст =
		"ВЫБРАТЬ РАЗРЕШЕННЫЕ
		|	ЕСТЬNULL(КВП_ПлощадьПомещенияСрезПоследних.Площадь, 0) КАК Площадь
		|ИЗ
		|	РегистрСведений.КВП_ПлощадьПомещения.СрезПоследних(
		|			&Дата,
		|			Объект = &Объект
		|				И ВидПлощади = &ВидПлощади) КАК КВП_ПлощадьПомещенияСрезПоследних";
	КонецЕсли;
	
	Выборка = Запрос.Выполнить().Выбрать();
	Если Выборка.Следующий() Тогда
		РазмерПлощади = ?(ОкруглятьПлощадь, Окр(Выборка.Площадь, 2), Выборка.Площадь);
	Иначе
		РазмерПлощади = 0;
	КонецЕсли;
	
	Возврат РазмерПлощади;
	
КонецФункции // ПолучитьПлощадьКвартиры()

// Функция проверяет жильца на предмет наличия собственности перед установкой флага
// "Владелец единственного жилья" или "Собственник" в документах открытия и изменения лицевого счета.
//
// Параметры:
//  Жилец - ссылка, жилец, по которому ищем данные.
//  Дата - дата, на которую ищем данные.
//  ПроверкаВЕЖ - булево, признак поиска ВЕЖ.
//
// Возвращаемое значение:
//  Структура - строка пояснения и признак отказа.
//
Функция ПроверитьСобственникаЖилья(Жилец, Дата, ПроверкаВЕЖ = Истина, ЛицевойСчет = Неопределено) Экспорт
	
	Структура = Новый Структура;
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	ВЫБОР
	|		КОГДА КВП_СведенияОЖильцахСрезПоследних.ВладелецЕдинственногоЖилья
	|			ТОГДА КВП_СведенияОЖильцахСрезПоследних.ЛицевойСчет
	|	КОНЕЦ КАК ЛицевойСчет,
	|	""1КВП_СведенияОЖильцах"" КАК Ресурс
	|ИЗ
	|	РегистрСведений.КВП_СведенияОЖильцах.СрезПоследних(
	|			&Дата,
	|			Объект.ФизЛицо = &Жилец
	|				И &УсловиеЗапроса1) КАК КВП_СведенияОЖильцахСрезПоследних
	|
	|ОБЪЕДИНИТЬ
	|
	|ВЫБРАТЬ
	|	ВЫБОР
	|		КОГДА УПЖКХ_СобственникиПомещенийСрезПоследних.Действует
	|			ТОГДА УПЖКХ_СобственникиПомещенийСрезПоследних.Помещение.Владелец.Наименование + "", "" 
	|				+ УПЖКХ_СобственникиПомещенийСрезПоследних.Помещение.Наименование
	|	КОНЕЦ,
	|	""2УПЖКХ_СобственникиПомещений""
	|ИЗ
	|	РегистрСведений.УПЖКХ_СобственникиПомещений.СрезПоследних(
	|			&Дата,
	|			Собственник = &Жилец
	|				И &УсловиеЗапроса2) КАК УПЖКХ_СобственникиПомещенийСрезПоследних";
	
	Запрос.УстановитьПараметр("Дата",  Новый Граница(Дата, ВидГраницы.Исключая));
	Запрос.УстановитьПараметр("Жилец", Жилец);
	Если НЕ ЛицевойСчет = Неопределено Тогда
		Запрос.Текст = СтрЗаменить(Запрос.Текст, "&УсловиеЗапроса1", "ЛицевойСчет <> &ЛицевойСчет");
		Запрос.Текст = СтрЗаменить(Запрос.Текст, "&УсловиеЗапроса2", "Помещение <> &Помещение");
		Запрос.УстановитьПараметр("ЛицевойСчет", ЛицевойСчет);
		Запрос.УстановитьПараметр("Помещение",   ЛицевойСчет.Адрес);
	Иначе
		Запрос.Текст = СтрЗаменить(Запрос.Текст, "&УсловиеЗапроса1", "Истина");
		Запрос.Текст = СтрЗаменить(Запрос.Текст, "&УсловиеЗапроса2", "Истина");
	КонецЕсли;
	
	Результат = Запрос.Выполнить().Выгрузить();
	
	Результат.Сортировать("Ресурс");
	
	Если ПроверкаВЕЖ Тогда
		
		// проверка владельца единственного жилья
		Для Каждого Строка Из Результат Цикл
			
			Если НЕ ЗначениеЗаполнено(Строка.ЛицевойСчет) Тогда
				Продолжить;
			КонецЕсли;
			
			Если Строка.Ресурс = "1КВП_СведенияОЖильцах" Тогда
				
				СтрокаРезультата = Строка(Жилец) + " уже является владельцем единственного жилья на лицевом счете "
				                 + Строка(Строка.ЛицевойСчет);
				Структура.Вставить("СтрокаОписания", СтрокаРезультата);
				Структура.Вставить("НеобходимОтказ", Истина);
				Возврат Структура;
				
			ИначеЕсли Строка.Ресурс = "2УПЖКХ_СобственникиПомещений" Тогда
				
				СтрокаРезультата = Строка(Жилец) + " уже является собственником помещения "
				                 + Строка(Строка.ЛицевойСчет);
				Структура.Вставить("СтрокаОписания", СтрокаРезультата);
				Структура.Вставить("НеобходимОтказ", Истина);
				Возврат Структура;
				
			КонецЕсли;
			
		КонецЦикла;
		
	Иначе
		
		// проверка собственника
		НайденныеСтроки = Результат.НайтиСтроки(Новый Структура("Ресурс", "1КВП_СведенияОЖильцах"));
		Если НайденныеСтроки.Количество() > 0 Тогда
			
			Для Каждого Строка Из НайденныеСтроки Цикл
				
				Если ЗначениеЗаполнено(Строка.ЛицевойСчет) Тогда
					СтрокаРезультата = Строка(Жилец) + " уже является владельцем единственного жилья на лицевом счете "
					                 + Строка(Строка.ЛицевойСчет);
					Структура.Вставить("СтрокаОписания", СтрокаРезультата);
					Структура.Вставить("НеобходимОтказ", Ложь);
					Возврат Структура;
				КонецЕсли;
				
			КонецЦикла;
			
		КонецЕсли;
		
	КонецЕсли;
	
	Структура.Вставить("СтрокаОписания", "");
	Структура.Вставить("НеобходимОтказ", Истина);
	Возврат Структура;
	
КонецФункции // ПроверитьСобственникаЖилья()

// Формирует запрос по табличной части документа и сортирует по переданной структуре.
//
// Параметры: 
//  ДокументОбъект        - объект документа, 
//  ИмяТабличнойЧасти     - строка, имя табличной части,
//  МассивПолейСортировки - массив, элементы которого содержат имена полей сортировки результата запроса.
//
// Возвращаемое значение:
//  Результат запроса.
//
Функция СформироватьЗапросПоТабличнойЧасти(ДокументОбъект, ИмяТабличнойЧасти, МассивПолейСортировки) Экспорт

	ТекстЗапроса = "";
	ПервыйОбход = Истина;
	
	Для Каждого Реквизит Из МассивПолейСортировки Цикл
		
		ТекстЗапроса  = ТекстЗапроса + ?(ПервыйОбход, "", ",") + "
		|	Док." + Реквизит;
		
		ПервыйОбход = Ложь;
		
	КонецЦикла;

	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("ТЧ", ДокументОбъект[ИмяТабличнойЧасти].Выгрузить());
	Запрос.Текст = "
	|ВЫБРАТЬ *
	|
	|ПОМЕСТИТЬ ТЧ
	|ИЗ
	|	&ТЧ КАК Док
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	*
	|ИЗ
	|	ТЧ КАК Док
	|
	|УПОРЯДОЧИТЬ ПО
	|" + ТекстЗапроса + "
	|
	|АВТОУПОРЯДОЧИВАНИЕ";
	
	Возврат Запрос.Выполнить().Выгрузить();

КонецФункции // СформироватьЗапросПоТабличнойЧасти()

// Функция возвращает признак, является ли единица измерения услуги/нормы единицей измерения площади.
//
// Параметры:
//  Объект    - СправочникСсылка, ссылка на услугу или на норму потребления услуги.
//  ТолькоКвМ - Булево, проверять будем только на квадратные метры.
//
// Возвращаемое значение:
//  Булево - признак, является ли единица измерения единицей площади.
//
Функция ЕдиницаИзмеренияЯвляетсяЕдиницейПлощади(Объект, ТолькоКвМ = Ложь) Экспорт
	
	ЯвляетсяЕдиницейПлощади = Ложь;
	
	Если ЗначениеЗаполнено(Объект) Тогда
		
		ТипОбъекта = ТипЗнч(Объект);
		
		ПроверяемКод = Ложь;
		
		Если ТипОбъекта = Тип("СправочникСсылка.КВП_Услуги") Тогда
			
			Если ЗначениеЗаполнено(Объект.ВидУслуги) И ЗначениеЗаполнено(Объект.ВидУслуги.ЕдиницаИзмерения) Тогда
				Код = СокрЛП(Объект.ВидУслуги.ЕдиницаИзмерения.Код);
				ПроверяемКод = Истина;
			КонецЕсли;
			
		ИначеЕсли ТипОбъекта = Тип("СправочникСсылка.КВП_НормыПотребленияУслуг") Тогда
			
			Если ЗначениеЗаполнено(Объект.ЕдиницаИзмерения) Тогда
				Код = СокрЛП(Объект.ЕдиницаИзмерения.Код);
				ПроверяемКод = Истина;
			КонецЕсли;
			
		КонецЕсли;
		
		Если ПроверяемКод Тогда
			
			Если (ТолькоКвМ И Код = "055")
			 ИЛИ (НЕ ТолькоКвМ И (Код = "050" ИЛИ Код = "051" ИЛИ Код = "053" ИЛИ Код = "055" ИЛИ Код = "058"
			      ИЛИ Код = "059" ИЛИ Код = "061" ИЛИ Код = "071" ИЛИ Код = "073" ИЛИ Код = "075" ИЛИ Код = "109")) Тогда
				ЯвляетсяЕдиницейПлощади = Истина;
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат ЯвляетсяЕдиницейПлощади;
	
КонецФункции

///////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ЗАПОЛНЕНИЯ ПАРАМЕТРОВ СЕАНСА

// Функция применяется при необходимости получить сведения об учетной политике ЖКХ.
//
// Возвращаемое значение:
//  таблица значений - таблица, каждая строка которой соответствует записи регистра.
//
Функция ЗаполнениеУчетнойПолитикиЖКХ() Экспорт
	
	Запрос = Новый Запрос();
	
	Запрос.Текст =
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	*
	|ИЗ
	|	РегистрСведений.КВП_УчетнаяПолитикаТСЖ КАК УчетнаяПолитика";
	
	УчетнаяПолитикаЖКХ = Запрос.Выполнить().Выгрузить();
	УчетнаяПолитикаЖКХ.Индексы.Добавить("Организация");
	УчетнаяПолитикаЖКХ.Сортировать("Период");
	
	Возврат УчетнаяПолитикаЖКХ;
	
КонецФункции //ЗаполнениеУчетнойПолитикиЖКХ

///////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С РЕГЛАМЕНТНЫМИ ЗАДАНИЯМИ

// Процедура пределяет свойства регламентных заданий ЖКХ, необходимых к блокировке при копировании информационной базы.
//
// Параметры:
//  Зависимости - ТаблицаЗначений - таблица значений настроек регламентных заданий.
//
Процедура ПриОпределенииНастроекРегламентныхЗаданий(Зависимости) Экспорт
	
	Зависимость = Зависимости.Добавить();
	Зависимость.РегламентноеЗадание = Метаданные.РегламентныеЗадания.УПЖКХ_ВыгрузкаДанныхДляМобильногоУстройства;
	Зависимость.РаботаетСВнешнимиРесурсами = Истина;
	
	Зависимость = Зависимости.Добавить();
	Зависимость.РегламентноеЗадание = Метаданные.РегламентныеЗадания.УПЖКХ_ОбменДаннымиССайтом;
	Зависимость.РаботаетСВнешнимиРесурсами = Истина;
	
КонецПроцедуры // ПриОпределенииНастроекРегламентныхЗаданий()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ПОЛУЧЕНИЯ ДАННЫХ

// Функция возвращает структуру с параметрами учетной политики на заданную дату.
//
// Параметры:
//  ТекущаяДата  - дата, на которую нужно получить настройки;
//  Организация  - организация, настройки которой нужно получить;
//  Отказ        - Булево - показывает, возникали ли ошибки;
//  СообщатьОбОшибке - Булево - показывает, выводить ли сообщения об ошибках.
//
// Возвращаемое значение:
//  Структура - структура с параметрами учетной политики.
//
Функция ПолучитьПараметрыУчетнойПолитикиЖКХ(ТекущаяДата, Организация, Отказ = Ложь, СообщатьОбОшибке = Истина) Экспорт
	
	Возврат СЗК_МодульЗащитыПереопределяемый.ПолучитьПараметрыУчетнойПолитикиЖКХ(ТекущаяДата, Организация, Отказ, СообщатьОбОшибке);
	
КонецФункции //ПолучитьПараметрыУчетнойПолитикиЖКХ()

// Процедура вычисления даты окончания действия учетной политики
// Параметры.
//  ТекПериод - дата начала действия учетной политики;
//  ТекОрганизация - организация, учетная политика которой рассматривается.
//
Функция НайтиДатуОкончанияДействияЖКХ(ТекПериод, ТекОрганизация) Экспорт
	
	УчетнаяПолитикаЖКХ = УПЖКХ_ТиповыеМетодыВызовСервера.ХранилищеОбщихНастроекЗагрузить("УчетнойПолитикиЖКХ");
	Если УчетнаяПолитикаЖКХ = Неопределено Тогда
		УчетнаяПолитикаЖКХ = ЗаполнениеУчетнойПолитикиЖКХ();
		УПЖКХ_ТиповыеМетодыВызовСервера.ХранилищеОбщихНастроекСохранить("УчетнойПолитикиЖКХ", , УчетнаяПолитикаЖКХ);
	КонецЕсли;
	
	ДатаОкончания = ТекПериод;
	
	УчетнаяПолитикаОрганизации = УчетнаяПолитикаЖКХ.НайтиСтроки(Новый Структура("Организация", ТекОрганизация));
	Для Каждого Строка Из УчетнаяПолитикаОрганизации Цикл
		
		Если Строка.Период > ДатаОкончания Тогда
			ДатаОкончания = Строка.Период - 1;
			Возврат ДатаОкончания;
		КонецЕсли;
		
	КонецЦикла;
	
	РабДата = УПЖКХ_ТиповыеМетодыКлиентСервер.ПолучитьРабочуюДату();
	
	ДатаОкончания = ?(ДатаОкончания = ТекПериод, КонецГода(РабДата), КонецГода(ДатаОкончания));
	ДатаОкончания = ?(ТекПериод > РабДата, КонецГода(ТекПериод), КонецГода(ДатаОкончания));
	
	Возврат ДатаОкончания;

КонецФункции //НайтиДатуОкончанияДействияЖКХ

// Осуществляет проверку заполненности проверяемых реквизитов.
//
// Параметры:
//  Объект                      - ДокументОбъект, СправочникОбъект - Проверяемый объект.
//  МассивПроверяемыхРеквизитов - Массив - массив проверяемых реквизитов.
//
// Возвращаемое значение:
//  Булево - Истина, если значение хотя бы одного реквизита не заполнено, иначе Ложь.
//
Функция ПроверитьЗаполнениеРеквизитовОбъекта(Объект, МассивПроверяемыхРеквизитов) Экспорт
	
	Перем ПроверяемыеРеквизитыТЧ;
	Отказ = Ложь;
	
	// Получение метаданных объекта
	МетаданныеОбъекта = Объект.Ссылка.Метаданные();
	
	// Создание структуры стандартных реквизитов
	СтандартныеРеквизиты = Новый Структура;
	Для Каждого Реквизит Из МетаданныеОбъекта.СтандартныеРеквизиты Цикл
		СтандартныеРеквизиты.Вставить(Реквизит.Имя, ?(ЗначениеЗаполнено(Реквизит.Синоним), Реквизит.Синоним, Реквизит.Имя));
	КонецЦикла;
	
	// Создание структуры для хранения имен табличных частей и проверяемых реквизитов в них.
	//  Ключ -  Имя табличной части;
	//  Значение - Массив - Массив строк, реквизитов этой табличной части для проверки.
	ТабличныеЧасти = Новый Структура;
	
	// Создание шаблонов сообщений об ошибках не заполненных реквизитов и реквизитов табличных частей.
	ШаблонОшибкиРеквизита = НСтр("ru='Поле ""%ИмяРеквизита%"" не заполнено'");
	ШаблонОшибкиТЧ = НСтр("ru='Не введено ни одной строки в список ""%ИмяРеквизита%""'");
	ШаблонОшибкиРеквизитаТЧ = НСтр("ru='Не заполнена колонка ""%ИмяРеквизита%"" в строке %НомерСтроки% списка ""%ИмяТабличнойЧасти%""'");
	
	// Проверка реквизитов объекта и заполнение структуры по реквизитам табличных частей.
	Для Каждого Реквизит Из МассивПроверяемыхРеквизитов Цикл
		
		ПозицияТочки = Найти(Реквизит,".");
		
		Если ПозицияТочки > 0 Тогда // В случае если указан реквизит табличной части.
			
			ДлинаСтроки       = СтрДлина(Реквизит);
			ИмяТабличнойЧасти = Лев(Реквизит, ПозицияТочки-1);
			ИмяРеквизита      = Прав(Реквизит, ДлинаСтроки - ПозицияТочки);
			
			// Сохранение проверяемого реквизита табличной части в структуру.
			Если НЕ ТабличныеЧасти.Свойство(ИмяТабличнойЧасти, ПроверяемыеРеквизитыТЧ) Тогда
				ПроверяемыеРеквизитыТЧ = Новый Массив;
				ТабличныеЧасти.Вставить(ИмяТабличнойЧасти, ПроверяемыеРеквизитыТЧ);
			КонецЕсли;
			ПроверяемыеРеквизитыТЧ.Добавить(ИмяРеквизита);
			
		Иначе // В случае если указан реквизит объекта.
			
			Если Не ЗначениеЗаполнено(Объект[Реквизит]) Тогда
				
				Если МетаданныеОбъекта.Реквизиты.Найти(Реквизит) <> Неопределено Тогда // Если указано имя реквизита.
					ТекстОшибки = СтрЗаменить(ШаблонОшибкиРеквизита, "%ИмяРеквизита%",
						МетаданныеОбъекта.Реквизиты[Реквизит].Синоним);
				ИначеЕсли СтандартныеРеквизиты.Свойство(Реквизит) Тогда // Если указано имя стандартного реквизита.
					ТекстОшибки = СтрЗаменить(ШаблонОшибкиРеквизита, "%ИмяРеквизита%",
						СтандартныеРеквизиты[Реквизит]);
				Иначе // Если указано имя табличной части.
					ТекстОшибки = СтрЗаменить(ШаблонОшибкиТЧ, "%ИмяРеквизита%",
						МетаданныеОбъекта.ТабличныеЧасти[Реквизит].Синоним);
				КонецЕсли;
				
				ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
					ТекстОшибки,
					Объект,
					Реквизит,
					,
					Отказ);
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
	// Проверка реквизитов в табличных частях
	Для Каждого ТабличнаяЧасть Из ТабличныеЧасти Цикл
		
		ИмяТабличнойЧасти = ТабличнаяЧасть.Ключ;
		ТабличнаяЧастьОбъекта = Объект[ТабличнаяЧасть.Ключ];
		МассивРеквизитов = ТабличнаяЧасть.Значение;
		
		// Цикл по всем строкам табличной части.
		Для НомерСтроки=0 По ТабличнаяЧастьОбъекта.Количество()-1 Цикл
			
			// Цикл по всем проверяемым реквизитам для текущей табличной части.
			Для НомерРеквизита=0 По МассивРеквизитов.Количество()-1 Цикл
				
				ИмяРеквизита = МассивРеквизитов[НомерРеквизита];
				
				Если Не ЗначениеЗаполнено(ТабличнаяЧастьОбъекта[НомерСтроки][ИмяРеквизита]) Тогда
					
					ТекстОшибки = СтрЗаменить(ШаблонОшибкиРеквизитаТЧ, "%ИмяРеквизита%",
												МетаданныеОбъекта.ТабличныеЧасти[ИмяТабличнойЧасти].Реквизиты[ИмяРеквизита].Синоним);
					ТекстОшибки = СтрЗаменить(ТекстОшибки, "%НомерСтроки%", Формат(НомерСтроки+1, "ЧГ=0"));
					ТекстОшибки = СтрЗаменить(ТекстОшибки, "%ИмяТабличнойЧасти%",
												МетаданныеОбъекта.ТабличныеЧасти[ИмяТабличнойЧасти].Синоним);
					
					ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
						ТекстОшибки,
						Объект,
						ОбщегоНазначенияКлиентСервер.ПутьКТабличнойЧасти(ИмяТабличнойЧасти, НомерСтроки+1, ИмяРеквизита),
						,
						Отказ);
					
				КонецЕсли;
				
			КонецЦикла;
			
		КонецЦикла;
		
	КонецЦикла;
	
	МассивПроверяемыхРеквизитов.Очистить();
	
	Возврат Отказ;
	
КонецФункции // ПроверитьЗаполнениеРеквизитовОбъекта()

// Открывает документ установки тарифов на указанную услугу.
//
//  Если такой документ существует, то он выбирается; иначе создается новый.
// После получения документа, нового или уже сохраненного, он открывается.
//
// Параметры:
//  Услуга       - СправочникСсылка.КВП_Услуги - услуга, по которой происходит
//                 поиск документа.
//
Функция ПолучитьДокументыУстановкиТарифовПоУслуге(Услуга) Экспорт
	
	МассивДокументов = Новый Массив;
	
	Если Не СЗК_МодульЗащиты.ЛицензионныйКлючКорректен() Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если Услуга.ЭтоГруппа Тогда
		УПЖКХ_ТиповыеМетодыКлиентСервер.СообщитьОбОшибке(
			"Тарифы не могут быть установлены на группу.");
		Возврат Неопределено;
	КонецЕсли;
	
	// проверка, есть ли документ для данной услуги
	Запрос = Новый Запрос();
	Запрос.Текст =
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ 1
	|	КВП_УстановкаТарифов.Ссылка
	|ИЗ
	|	Документ.КВП_УстановкаТарифов КАК КВП_УстановкаТарифов
	|ГДЕ
	|	КВП_УстановкаТарифов.Услуга = &Услуга
	|	И КВП_УстановкаТарифов.Проведен
	|
	|УПОРЯДОЧИТЬ ПО
	|	КВП_УстановкаТарифов.Дата УБЫВ";
	
	Запрос.УстановитьПараметр("Услуга", Услуга);
	
	Результат = Запрос.Выполнить();
	
	Возврат Результат.Выгрузить().ВыгрузитьКолонку("Ссылка");
	
КонецФункции

// Получает ответственного собственника, нанимателя для указанного лицевого счета.
//
// Параметры:
//  ЛицевойСчет – лицевой счет , для которого
//                необходимо найти ответственного собственника, нанимателя лицевого счета.
//
// Возвращаемое значение:
//  Ссылка на справочники "Контрагенты" или "Жильцы".
//
Функция ПолучитьОтветственногоСобственникаЛицевогоСчета(ЛицевойСчет, Дата = Неопределено) Экспорт
	
	Если Дата = Неопределено Тогда
		Дата = УПЖКХ_ТиповыеМетодыКлиентСервер.ПолучитьРабочуюДату();
	КонецЕсли;
	
	Запрос = Новый Запрос();
	Запрос.Текст =
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	УПЖКХ_ОтветственныйСобственникНанимательЛицевогоСчетаСрезПоследних.ОтветственныйВладелец
	|ИЗ
	|	РегистрСведений.УПЖКХ_ОтветственныйСобственникНанимательЛицевогоСчета.СрезПоследних(&Дата,
	|					ЛицевойСчет = &ЛицевойСчет) 
	|		КАК УПЖКХ_ОтветственныйСобственникНанимательЛицевогоСчетаСрезПоследних";
	
	Запрос.УстановитьПараметр("Дата",        Дата);
	Запрос.УстановитьПараметр("ЛицевойСчет", ЛицевойСчет);
	Выборка = Запрос.Выполнить().Выбрать();
	
	Если Выборка.Следующий() Тогда
		Возврат Выборка.ОтветственныйВладелец;
	КонецЕсли;
	
	Возврат Неопределено;
	
КонецФункции // ПолучитьОтветственногоСобственникаЛицевогоСчета()

// Функция получает представление ответственного собственника лицевого счета.
//
Функция ПолучитьПредставлениеОтветственногоСобственника(ВидСобственности = Неопределено) Экспорт
	
	СтруктураПредставленияСобственника = ПолучитьСтруктуруПредставленияОтветственногоСобственника();
	
	Если Не ВидСобственности = Неопределено Тогда
		Если ВидСобственности = Перечисления.УПЖКХ_ВидыСобственности.Частная Тогда
			Возврат СтруктураПредставленияСобственника.ЧастныйСобственник;
		Иначе
			Возврат СтруктураПредставленияСобственника.МуниципальныйСобственник;
		КонецЕсли;
	Иначе
		Возврат СтруктураПредставленияСобственника.ПрочийСобственник;
	КонецЕсли;
	
КонецФункции

// Получает сведения для взаиморасчетов для указанного лицевого счета.
//
// Параметры:
//  Объект          – лицевой счет или парковочное место, для которых
//                    необходимо найти договор или контрагента;
//  Дата            - дата поиска контрагента или договора контрагента;
//  ИскомыйРесурс  - Строка - задается, если необходимо получить конкретный параметр: контрагента или договор контрагента.
//
// Возвращаемое значение:
//  Структура - если не указан параметр "ИскомыйРесурс" или Ссылка на справочник "Контрагенты" или "Договоры контрагентов".
//
Функция ПолучитьСведенияДляВзаиморасчетовПоЛицевомуСчету(ЛицевойСчет, Организация, Дата = Неопределено,
																	ИскомыйРесурс = Неопределено) Экспорт
	
	Структура = Новый Структура;
	Структура.Вставить("Контрагент", Справочники.Контрагенты.ПустаяСсылка());
	Структура.Вставить("Договор",    Справочники.ДоговорыКонтрагентов.ПустаяСсылка());
	
	Если Не СЗК_МодульЗащиты.ЛицензионныйКлючКорректен() Тогда
		Возврат Структура;
	КонецЕсли;
	
	Если Дата = Неопределено Тогда
		Дата = УПЖКХ_ТиповыеМетодыКлиентСервер.ПолучитьРабочуюДату();
	КонецЕсли;
	
	ТипЗначОбъекта = ТипЗнч(ЛицевойСчет);
	Если Не ТипЗначОбъекта = Тип("СправочникСсылка.КВП_ЛицевыеСчета")
		И НЕ ТипЗначОбъекта = Тип("СправочникОбъект.КВП_ЛицевыеСчета") Тогда
		Возврат Структура;
	Конецесли;
	
	ЗапросОсновнойДоговор = Новый Запрос();
	ЗапросОсновнойДоговор.Текст =
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	КВП_ОсновнойДоговорЛицевогоСчетаСрезПоследних.Договор,
	|	КВП_ОсновнойДоговорЛицевогоСчетаСрезПоследних.Контрагент
	|ИЗ
	|	РегистрСведений.УПЖКХ_СведенияДляВзаиморасчетовПоЛС.СрезПоследних(
	|			&Дата,
	|			ЛицевойСчет = &ЛицевойСчет
	|				И Организация = &Организация) КАК КВП_ОсновнойДоговорЛицевогоСчетаСрезПоследних";
	
	ЗапросОсновнойДоговор.УстановитьПараметр("Дата",        Дата);
	ЗапросОсновнойДоговор.УстановитьПараметр("ЛицевойСчет", ЛицевойСчет);
	ЗапросОсновнойДоговор.УстановитьПараметр("Организация", Организация);
	
	Выборка = ЗапросОсновнойДоговор.Выполнить().Выбрать();
	Если Выборка.Следующий() Тогда
		Структура.Вставить("Контрагент", Выборка.Контрагент);
		Структура.Вставить("Договор",    Выборка.Договор);
	КонецЕсли;
	
	Если ИскомыйРесурс = "Контрагент" ИЛИ ИскомыйРесурс = "Договор" Тогда
		Возврат Структура[ИскомыйРесурс];
	КонецЕсли;
	
	Возврат Структура;

КонецФункции // ПолучитьСведенияДляВзаиморасчетовПоЛицевомуСчету()

// Процедура заполняет поле "Источник оплаты".
//
Функция ЗаполнениеИсточникаОплаты(Организация, ИмяОбъекта, ВидОперации) Экспорт
	
	Запрос = Новый Запрос();
	Запрос.УстановитьПараметр("Организация", Организация);
	Запрос.УстановитьПараметр("Документ",    ИмяОбъекта);
	Запрос.УстановитьПараметр("ВидОперации", ВидОперации);
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	УПЖКХ_НастройкаИсточникаОплаты.Документ,
	|	УПЖКХ_НастройкаИсточникаОплаты.ВидОперации,
	|	УПЖКХ_НастройкаИсточникаОплаты.ИсточникОплаты,
	|	УПЖКХ_НастройкаИсточникаОплаты.Организация КАК Организация
	|ИЗ
	|	РегистрСведений.УПЖКХ_НастройкаИсточниковОплаты КАК УПЖКХ_НастройкаИсточникаОплаты
	|ГДЕ
	|	УПЖКХ_НастройкаИсточникаОплаты.Организация = &Организация
	|	И УПЖКХ_НастройкаИсточникаОплаты.ВидОперации = &ВидОперации
	|	И УПЖКХ_НастройкаИсточникаОплаты.Документ = &Документ";
	
	ВыборкаИсточниковОплаты = Запрос.Выполнить().Выбрать();
	Если ВыборкаИсточниковОплаты.Следующий() Тогда
		Возврат ВыборкаИсточниковОплаты.ИсточникОплаты;
	Иначе
		Возврат Справочники.КВП_ИсточникиОплат.ПустаяСсылка();
	КонецЕсли;

КонецФункции

// Сортирует табличную часть объекта.
//
// Параметры:
//  Объект            – объект базы данных, табличную часть которого
//                      необходимо отсортировать
//  ИмяТабличнойЧасти – Строка - имя табличной части объекта
//  ДанныеФормы       – Таблица значений или Дерево значений, содержащие данные табличной части.
//  ИмяКолонки        – Строка - наименование колонки, по которой производится сортировка.
//  ПоВозрастанию     – Булево - если Истина, то сортировка по возрастанию,
//                      если Ложь - по убыванию
//  ЭтоДерево         - Булево - Признак того, что в процедуру передано дерево значений. Если Истина - дерево значений,
//                      если Ложь - таблица значений.
//  РеквизитОбъекта   - Строка - имя реквизита.
//
Процедура СортироватьТабличнуюЧасть(Объект,
									ИмяТабличнойЧасти,
									ДанныеФормы,
									ИмяКолонки,
									ПоВозрастанию = Истина,
									ЭтоДерево,
									РеквизитОбъекта = Неопределено) Экспорт
	
	МетаданныеОбъекта = Объект.Метаданные();
	ПорядокСортировки = ?(ПоВозрастанию, " Возр", " Убыв");
	
	Если ЭтоДерево Тогда
		
		// Примечание:
		// При сортировке строк дерева сортируются только сроки верхнего уровня.
		// Подчиненные строки не сортируем, так как необходимость их сортировки скорее-всего отсутствует.
		// Например, непонятно, зачем нужно сортировать строки по периодам начисления одного лицевого счета.
		
		ИмяКолонкиЗдание      = "";
		ИмяКолонкиПомещение   = "";
		ИмяКолонкиВладелец    = "";
		ИмяКолонкиЛицевойСчет = "";
		
		Если МетаданныеОбъекта.Имя = "КВП_НачислениеУслуг" Тогда
			
			Если ИмяТабличнойЧасти = "ДеревоУслуг" Тогда
				ИмяКолонкиЛицевойСчет = "ЛицевойСчет";
				ИмяКолонкиЗдание      = "Здание";
				ИмяКолонкиПомещение   = "Квартира";
				ИмяКолонкиВладелец    = "Владелец";
				
			ИначеЕсли ИмяТабличнойЧасти = "ДеревоПоПоказаниямПУ" Тогда
				ИмяКолонкиЛицевойСчет = "ЛицевойСчет";
				ИмяКолонкиЗдание      = "Здание";
				ИмяКолонкиПомещение   = "Помещение";
				ИмяКолонкиВладелец    = "Владелец";
				
			КонецЕсли;
			
		ИначеЕсли МетаданныеОбъекта.Имя = "КВП_КорректировкаНачислений" Тогда
			
			Если ИмяТабличнойЧасти = "ДеревоУслуг" Тогда
				ИмяКолонкиЛицевойСчет = "ЛицевойСчет";
				ИмяКолонкиПомещение   = "Квартира";
				ИмяКолонкиВладелец    = "Владелец";
			КонецЕсли;
			
		ИначеЕсли МетаданныеОбъекта.Имя = "УПЖКХ_ВводПоказанийСчетчика" Тогда
			
			Если ИмяТабличнойЧасти = "ДеревоПоказаний" Тогда
				Если Объект.ВидОперации = Перечисления.КВП_ВидыОперацийВводаПоказанийСчетчика.ВводПоказанииСчетчикаНаЛицевойСчет Тогда
					ИмяКолонкиЛицевойСчет = "Объект";
					ИмяКолонкиПомещение   = "Помещение";
				ИначеЕсли Объект.ВидОперации = Перечисления.КВП_ВидыОперацийВводаПоказанийСчетчика.ВводПоказанииСчетчикаНаПомещение Тогда
					ИмяКолонкиПомещение   = "Объект";
				КонецЕсли;
			КонецЕсли;
			
		КонецЕсли;
			
		Если ИмяКолонки = ИмяКолонкиЗдание Или ИмяКолонки = ИмяКолонкиПомещение Или ИмяКолонки = ИмяКолонкиВладелец Тогда
			
			Если ИмяКолонки = ИмяКолонкиПомещение Тогда
				Если ДанныеФормы.Колонки.Найти(ИмяКолонки + "_Здание") = Неопределено Тогда
					ДанныеФормы.Колонки.Добавить(ИмяКолонки + "_Здание");
				КонецЕсли;
				Если ДанныеФормы.Колонки.Найти(ИмяКолонки + "_ВидПомещения") = Неопределено Тогда
					ДанныеФормы.Колонки.Добавить(ИмяКолонки + "_ВидПомещения");
				КонецЕсли;
				
				Если ДанныеФормы.Колонки.Найти(ИмяКолонки + "_Код") = Неопределено Тогда
					ДанныеФормы.Колонки.Добавить(ИмяКолонки + "_Код");
				КонецЕсли;
				Если ДанныеФормы.Колонки.Найти(ИмяКолонки + "_Суффикс") = Неопределено Тогда
					ДанныеФормы.Колонки.Добавить(ИмяКолонки + "_Суффикс");
				КонецЕсли;
			КонецЕсли;
			
			Для Каждого ТекСтрока Из ДанныеФормы.Строки Цикл
				
				Если ЗначениеЗаполнено(ИмяКолонкиЛицевойСчет) 
				   И ЗначениеЗаполнено(ТекСтрока[ИмяКолонкиЛицевойСчет]) Тогда
					Если ИмяКолонки = ИмяКолонкиЗдание Тогда
						ТекСтрока[ИмяКолонкиЗдание] = ТекСтрока[ИмяКолонкиЛицевойСчет].Адрес.Владелец;
						
					ИначеЕсли ИмяКолонки = ИмяКолонкиПомещение Тогда
						ТекСтрока[ИмяКолонки + "_Здание"]       = ТекСтрока[ИмяКолонкиЛицевойСчет].Адрес.Владелец;
						ТекСтрока[ИмяКолонки + "_ВидПомещения"] = ТекСтрока[ИмяКолонкиЛицевойСчет].Адрес.ВидПомещения;
						ТекСтрока[ИмяКолонки + "_Код"]          = ТекСтрока[ИмяКолонкиЛицевойСчет].Адрес.Код;
						ТекСтрока[ИмяКолонки + "_Суффикс"]      = ТекСтрока[ИмяКолонкиЛицевойСчет].Адрес.Суффикс;
						
					ИначеЕсли ИмяКолонки = ИмяКолонкиВладелец Тогда
						ТекСтрока[ИмяКолонкиВладелец]  = ПолучитьОтветственногоСобственникаЛицевогоСчета(ТекСтрока[ИмяКолонкиЛицевойСчет], Объект.Дата);
						
					КонецЕсли;
				ИначеЕсли ЗначениеЗаполнено(ТекСтрока[ИмяКолонкиПомещение]) Тогда
					Если ИмяКолонки = ИмяКолонкиПомещение Тогда
						ТекСтрока[ИмяКолонки + "_Здание"]       = ТекСтрока[ИмяКолонкиПомещение].Владелец;
						ТекСтрока[ИмяКолонки + "_ВидПомещения"] = ТекСтрока[ИмяКолонкиПомещение].ВидПомещения;
						ТекСтрока[ИмяКолонки + "_Код"]          = ТекСтрока[ИмяКолонкиПомещение].Код;
						ТекСтрока[ИмяКолонки + "_Суффикс"]      = ТекСтрока[ИмяКолонкиПомещение].Суффикс;
					КонецЕсли;
				КонецЕсли;
			КонецЦикла;
			
			Если ИмяКолонки = ИмяКолонкиПомещение Тогда
				ДанныеФормы.Строки.Сортировать(ИмяКолонки + "_Здание"       + ПорядокСортировки + ", " +
											   ИмяКолонки + "_ВидПомещения" + ПорядокСортировки + ", " +
											   ИмяКолонки + "_Код"          + ПорядокСортировки + ", " +
											   ИмяКолонки + "_Суффикс"      + ПорядокСортировки);
			ИначеЕсли ИмяКолонки = ИмяКолонкиЗдание Тогда
				ДанныеФормы.Строки.Сортировать(ИмяКолонки + ПорядокСортировки + ?(ЗначениеЗаполнено(ИмяКолонкиЛицевойСчет), ", " + ИмяКолонкиЛицевойСчет + " Возр", ""));
			ИначеЕсли ИмяКолонки = ИмяКолонкиВладелец Тогда
				ДанныеФормы.Строки.Сортировать(ИмяКолонки + ПорядокСортировки);
			КонецЕсли;
			
		Иначе
			ДанныеФормы.Строки.Сортировать(ИмяКолонки + ПорядокСортировки);
		КонецЕсли;
		
		Возврат;
		
	КонецЕсли;
	
	// Подберем наименование реквизита в зависимости от документа.
	Если РеквизитОбъекта = Неопределено Тогда
		Если МетаданныеОбъекта.Имя = "КВП_НачислениеУслуг"
		 ИЛИ МетаданныеОбъекта.Имя = "КВП_РасчетЛьгот" Тогда
			РеквизитОбъекта = "ЛицевыеСчета";
		ИначеЕсли МетаданныеОбъекта.Имя = "КВП_КорректировкаНачислений"
		      ИЛИ МетаданныеОбъекта.Имя = "КВП_НачислениеПени" Тогда
			РеквизитОбъекта = "ЛицевойСчет";
		ИначеЕсли МетаданныеОбъекта.Имя = "КВП_РегистрацияОплаты"
		      ИЛИ МетаданныеОбъекта.Имя = "УПЖКХ_РегистрацияОплатыАренды"
		      ИЛИ МетаданныеОбъекта.Имя = "КВП_УправлениеУслугами"
		      ИЛИ МетаданныеОбъекта.Имя = "УПЖКХ_ЗакрытиеПериодаПоНачислениямЖКХ" Тогда
			РеквизитОбъекта = "Объект";
		ИначеЕсли МетаданныеОбъекта.Имя = "УПЖКХ_НачислениеПоАренде" Тогда
			РеквизитОбъекта = "ДоговорКонтрагента";
		Иначе
			Возврат;
		КонецЕсли;
	КонецЕсли;
	
	Если ИмяКолонки = "Здание" Тогда
		
		Для Каждого СтрокаТаблицы Из ДанныеФормы Цикл
			Если ТипЗнч(СтрокаТаблицы[РеквизитОбъекта]) = Тип("СправочникСсылка.КВП_ЛицевыеСчета") Тогда
				СтрокаТаблицы["Здание"] = СтрокаТаблицы[РеквизитОбъекта].Адрес.Владелец;
			КонецЕсли;
		КонецЦикла;
		ДанныеФормы.Сортировать("Здание" + ПорядокСортировки);
		
	ИначеЕсли ИмяКолонки = "Квартира" ИЛИ ИмяКолонки = "Помещение" Тогда
		
		ДанныеФормы.Колонки.Добавить(ИмяКолонки + "_Здание",       Новый ОписаниеТипов("СправочникСсылка.КВП_Здания"));
		ДанныеФормы.Колонки.Добавить(ИмяКолонки + "_ВидПомещения", Новый ОписаниеТипов("СправочникСсылка.УПЖКХ_ВидыПомещений"));
		ДанныеФормы.Колонки.Добавить(ИмяКолонки + "_Код",          УПЖКХ_ТиповыеМетодыКлиентСервер.ПолучитьОписаниеТиповЧисла(9));
		ДанныеФормы.Колонки.Добавить(ИмяКолонки + "_Суффикс",      УПЖКХ_ТиповыеМетодыКлиентСервер.ПолучитьОписаниеТиповСтроки(10));
		
		Для Каждого СтрокаТаблицы Из ДанныеФормы Цикл
			Если ТипЗнч(СтрокаТаблицы[РеквизитОбъекта]) = Тип("СправочникСсылка.КВП_ЛицевыеСчета") Тогда
				СтрокаТаблицы[ИмяКолонки + "_Здание"]       = СтрокаТаблицы[РеквизитОбъекта].Адрес.Владелец;
				СтрокаТаблицы[ИмяКолонки + "_ВидПомещения"] = СтрокаТаблицы[РеквизитОбъекта].Адрес.ВидПомещения;
				СтрокаТаблицы[ИмяКолонки + "_Код"]          = СтрокаТаблицы[РеквизитОбъекта].Адрес.Код;
				СтрокаТаблицы[ИмяКолонки + "_Суффикс"]      = СтрокаТаблицы[РеквизитОбъекта].Адрес.Суффикс;
			Иначе
				СтрокаТаблицы[ИмяКолонки + "_Здание"]       = Справочники.КВП_Здания.ПустаяСсылка();
				СтрокаТаблицы[ИмяКолонки + "_ВидПомещения"] = Справочники.УПЖКХ_ВидыПомещений.ПустаяСсылка();
				СтрокаТаблицы[ИмяКолонки + "_Код"]          = "";
				СтрокаТаблицы[ИмяКолонки + "_Суффикс"]      = "";
			КонецЕсли;
		КонецЦикла;
		ДанныеФормы.Сортировать(ИмяКолонки + "_Здание"       + ПорядокСортировки + ", " +
							  ИмяКолонки + "_ВидПомещения" + ПорядокСортировки + ", " +
							  ИмяКолонки + "_Код"          + ПорядокСортировки + ", " +
							  ИмяКолонки + "_Суффикс"      + ПорядокСортировки);
		
	ИначеЕсли ИмяКолонки = "Владелец" Тогда
		// Если это таблица по парковочным местам, то владельца нужно брать из регистра.
		// Подготовим таблицу парковочных мест.
		Если МетаданныеОбъекта.Имя = "КВП_НачислениеУслуг"
		   И Объект.ВидОперации = Перечисления.КВП_ВидыОперацийНачисленияУслуг.УдалитьНачисленияНаПарковочныеМеста Тогда
			
			Запрос = Новый Запрос;
			Запрос.УстановитьПараметр("Дата",           Объект.Дата);
			Запрос.УстановитьПараметр("СписокОбъектов", ДанныеФормы.ВыгрузитьКолонку(РеквизитОбъекта));
			
			Запрос.Текст =
			"ВЫБРАТЬ
			|	СведенияОПарковочныхМестахСрезПоследних.ПарковочноеМесто,
			|	СведенияОПарковочныхМестахСрезПоследних.ВладелецМеста.Наименование КАК Владелец
			|ИЗ
			|	РегистрСведений.Удалить_КВП_СведенияОПарковочныхМестах.СрезПоследних(&Дата, ПарковочноеМесто В (&СписокОбъектов)) КАК СведенияОПарковочныхМестахСрезПоследних";
			
			ТаблицаПарковочныхМест = Запрос.Выполнить().Выгрузить();
			
		КонецЕсли;
		
		Для Каждого СтрокаТаблицы Из ДанныеФормы Цикл
			
			// Если объект - парковочное место, то владельца берем из таблицы парковочных мест.
			Если ТипЗнч(СтрокаТаблицы[РеквизитОбъекта]) = Тип("СправочникСсылка.УПЖКХ_Помещения") Тогда
				ТекущаяСтрокаВладельца = ТаблицаПарковочныхМест.Найти(СтрокаТаблицы[РеквизитОбъекта], "ПарковочноеМесто");
				Если Не ТекущаяСтрокаВладельца = Неопределено Тогда
					СтрокаТаблицы.Владелец = ТекущаяСтрокаВладельца.Владелец;
				КонецЕсли;
				
			Иначе
				СтрокаТаблицы.Владелец = ПолучитьОтветственногоСобственникаЛицевогоСчета(СтрокаТаблицы[РеквизитОбъекта], Объект.Дата);
			КонецЕсли;
			
		КонецЦикла;
		ДанныеФормы.Сортировать("Владелец" + ПорядокСортировки);
		
	ИначеЕсли ИмяКолонки = "Контрагент" Тогда
		
		Для Каждого СтрокаТаблицы Из ДанныеФормы Цикл
			Если ТипЗнч(СтрокаТаблицы[РеквизитОбъекта]) = Тип("СправочникСсылка.КВП_ЛицевыеСчета") Тогда
				СтрокаТаблицы.Контрагент = СтрокаТаблицы[РеквизитОбъекта].Контрагент;
			ИначеЕсли ТипЗнч(СтрокаТаблицы[РеквизитОбъекта]) = Тип("СправочникСсылка.ДоговорыКонтрагентов") Тогда
				СтрокаТаблицы.Контрагент = СтрокаТаблицы[РеквизитОбъекта].Владелец;
			Иначе
				СтрокаТаблицы.Контрагент = "";
			КонецЕсли;
		КонецЦикла;
		ДанныеФормы.Сортировать("Контрагент" + ПорядокСортировки);
		
	Иначе
		
		ДанныеФормы.Сортировать(ИмяКолонки + " " + ПорядокСортировки);
		
	КонецЕсли;
	
КонецПроцедуры // СортироватьТабличнуюЧасть()

// Функция возвращает список лицевых счетов выбранного здания / подъезда / 
// помещения / группы лицевых счетов / группы зданий.
//
// Параметры
//  Объект                                  - ссылка на здание (группу зданий), подъезд, помещение,
//                                            лицевой счет или группу лицевых счетов.
// НачалоПериода                            - Дата, начало периода получения данных по лицевым счетам.
// КонецПериода                             - Дата, конец периода получения данных по лицевым счетам.
// ТолькоДействующие                        - флаг, определяющий нужно ли получать только действующие
//                                            лицевые счета.
// ПолучатьПустойСписокЕслиОбъектНеЗаполнен - флаг, определяющий нужно ли возвращать пустой список,
//                                            если объект не заполнен.
Функция ПолучитьСписокЛСОбъекта(Объект, НачалоПериода, КонецПериода = Неопределено, ТолькоДействующие = Истина, ПолучатьПустойСписокЕслиОбъектНеЗаполнен = Истина) Экспорт
	
	СписокЛицевыхСчетов = Новый СписокЗначений();
	ТипОбъекта = ТипЗнч(Объект);
	
	Если ЗначениеЗаполнено(Объект) Тогда
		
		ОбъектСписок = ПолучитьЭлементыСправочникаПоГруппе(Объект);
		
		Если ТипОбъекта = Тип("СправочникСсылка.КВП_Здания") Тогда
			СписокЛицевыхСчетов = КВП_ПолучитьСписокЛицевыхСчетовПоЗданиям(ОбъектСписок, НачалоПериода, КонецПериода, ТолькоДействующие);
		ИначеЕсли ТипОбъекта = Тип("СправочникСсылка.КВП_Подъезды") Тогда
			СписокЛицевыхСчетов = КВП_ПолучитьСписокЛицевыхСчетовПоПодъездам(ОбъектСписок, НачалоПериода, КонецПериода, ТолькоДействующие);
		ИначеЕсли ТипОбъекта = Тип("СправочникСсылка.УПЖКХ_Помещения") Тогда
			СписокЛицевыхСчетов = КВП_ПолучитьСписокЛицевыхСчетовПоПомещениям(ОбъектСписок, НачалоПериода, КонецПериода, ТолькоДействующие);
		ИначеЕсли ТипОбъекта = Тип("СправочникСсылка.КВП_ЛицевыеСчета") Тогда
			СписокЛицевыхСчетов = ОбъектСписок;
		КонецЕсли;
		
	ИначеЕсли НЕ ПолучатьПустойСписокЕслиОбъектНеЗаполнен Тогда
		
		Запрос = Новый Запрос();
		Запрос.Текст =
		"ВЫБРАТЬ РАЗРЕШЕННЫЕ РАЗЛИЧНЫЕ
		|	КВП_ЛицевыеСчета.ЛицевойСчет КАК ЛицевойСчет
		|ИЗ
		|	РегистрСведений.КВП_ЛицевыеСчета.СрезПоследних(&НачалоПериода, ) КАК КВП_ЛицевыеСчета
		|ГДЕ
		|	&УсловиеДействия";
		
		Если НЕ КонецПериода = Неопределено Тогда
			Запрос.Текст = Запрос.Текст + "
			|
			|ОБЪЕДИНИТЬ
			|
			|ВЫБРАТЬ РАЗЛИЧНЫЕ
			|	КВП_ЛицевыеСчета.ЛицевойСчет КАК ЛицевойСчет
			|ИЗ
			|	РегистрСведений.КВП_ЛицевыеСчета КАК КВП_ЛицевыеСчета
			|ГДЕ
			|	КВП_ЛицевыеСчета.Период МЕЖДУ &НачалоПериода И &КонецПериода
			|	И &УсловиеДействия";
			Запрос.УстановитьПараметр("КонецПериода", КонецДня(КонецПериода));
		КонецЕсли;
		
		Запрос.УстановитьПараметр("НачалоПериода", НачалоДня(НачалоПериода));
		
		Если ТолькоДействующие Тогда
			Запрос.Текст = СтрЗаменить(Запрос.Текст, "&УсловиеДействия", "КВП_ЛицевыеСчета.Действует");
		Иначе
			// Для получения всех лицевых счетов.
			Запрос.Текст = СтрЗаменить(Запрос.Текст, "&УсловиеДействия", "ИСТИНА");
		КонецЕсли;
		
		СписокЛицевыхСчетов.ЗагрузитьЗначения(Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("ЛицевойСчет"));
		
	КонецЕсли;
	
	Возврат СписокЛицевыхСчетов;
	
КонецФункции // ПолучитьСписокЛСОбъекта()

// Получает количество л/с в базе.
//
Функция ПолучитьКоличествоЛСВБазе() Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ
	|	КОЛИЧЕСТВО(КВП_ЛицевыеСчетаСрезПоследних.ЛицевойСчет) КАК КоличествоЛС
	|ИЗ
	|	РегистрСведений.КВП_ЛицевыеСчета.СрезПоследних(&Дата, ) КАК КВП_ЛицевыеСчетаСрезПоследних
	|ГДЕ
	|	КВП_ЛицевыеСчетаСрезПоследних.Действует";
	
	Запрос.УстановитьПараметр("Дата", ТекущаяДатаСеанса());
	
	Результат = 0;
	
	Выборка = Запрос.Выполнить().Выбрать();
	Если Выборка.Следующий() Тогда
		Результат = Выборка.КоличествоЛС;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Возвращает структуру реквизитов элемента справочника "ОВД".
//
// Параметры:
//  ОВД - СправочникСсылка.КВП_ОВД - ссылки на элемент справочника "ОВД".
//
// Возвращаемое значение:
//  РеквизитыОВД - Структура - структура значений реквизитов указанного элемента справочника "ОВД" (ключ - имя реквизита).
//
Функция ПолучитьСтруктуруРеквизитовОВД(ОВД) Экспорт
	
	СтруктураРеквизитовОВД = Новый Структура("Наименование,Адрес,ИНН,КПП,ОГРН,Телефон,КодПодразделения", "", "", "", "", "", "", "");
	
	Если Не ОВД.Пустая() Тогда
		
		Запрос = Новый Запрос;
		
		Запрос.УстановитьПараметр("ОВД", ОВД);
		
		Запрос.Текст =
		"ВЫБРАТЬ РАЗРЕШЕННЫЕ
		|	КВП_ОВД.Наименование,
		|	КВП_ОВД.Адрес,
		|	КВП_ОВД.ИНН,
		|	КВП_ОВД.КПП,
		|	КВП_ОВД.ОГРН,
		|	КВП_ОВД.Телефон,
		|	КВП_ОВД.КодПодразделения
		|ИЗ
		|	Справочник.КВП_ОВД КАК КВП_ОВД
		|ГДЕ
		|	КВП_ОВД.Ссылка = &ОВД";
		
		Выборка = Запрос.Выполнить().Выбрать();
		
		Пока Выборка.Следующий() Цикл
			ЗаполнитьЗначенияСвойств(СтруктураРеквизитовОВД, Выборка);
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат СтруктураРеквизитовОВД;
	
КонецФункции // ПолучитьСтруктуруРеквизитовОВД()

// Процедура обрабатывает связь документов "Ввод показаний счетчика" и "Корректировка начислений".
//
Процедура ОбработатьСвязьДокументовВводаПоказанийИКорректировкиНачисленийПриЗаписи(Объект, Отказ, РежимЗаписи = Неопределено) Экспорт
	
	СвязанныйДокумент = Неопределено;
	
	Если Объект.ЭтоНовый() Тогда
		Возврат;
	КонецЕсли;
	
	Если РежимЗаписи = Неопределено Тогда
		РежимЗаписи = РежимЗаписиДокумента.Запись;
	КонецЕсли;
	
	Если ТипЗнч(Объект) = Тип("ДокументОбъект.УПЖКХ_ВводПоказанийСчетчика") Тогда
		
		ДокКорректировки = УПЖКХ_ВводПоказанийПриборовУчетаСервер.НайтиПодчиненныйДокументКорректировкаНачислений(Объект.Ссылка);
		Если ЗначениеЗаполнено(ДокКорректировки) Тогда
			
			СвязанныйДокумент = ДокКорректировки.ПолучитьОбъект();
			СвязанныйДокумент.ДополнительныеСвойства.Вставить("ОбработкаСвязанныхДокументов", Истина);
			
			Если Объект.ПометкаУдаления <> СвязанныйДокумент.ПометкаУдаления Тогда
				
				// Синхронизация пометки на удаление. Если производится отмена проведения текущего документа, то отменяется
				// и проведение связанного.
				СвязанныйДокумент.ПометкаУдаления = Объект.ПометкаУдаления;
				Если Не КВП_ЗаписатьОбъект(СвязанныйДокумент, РежимЗаписи) Тогда
					Отказ = Истина;
					Возврат;
				КонецЕсли;
				
			Иначе
				
				Если РежимЗаписи = РежимЗаписиДокумента.ОтменаПроведения И СвязанныйДокумент.Проведен Тогда
					// Если отменяем проведение документа ввода показаний, то отменяем и проведение связанного документа корректировки.
					Если Не КВП_ЗаписатьОбъект(СвязанныйДокумент, РежимЗаписи) Тогда
						Отказ = Истина;
						Возврат;
					КонецЕсли;
					
				ИначеЕсли РежимЗаписи = РежимЗаписиДокумента.Проведение И Не СвязанныйДокумент.Проведен Тогда
					// Если проводим документ ввода показаний, то документ корректировки не проводим, но уведомляем пользователя, что
					// связанный документ есть и рекомендуется его перезаполнить (с перепроведением).
					УПЖКХ_ТиповыеМетодыКлиентСервер.СообщитьПользователю("Обнаружен связанный непроведенный документ """ + СвязанныйДокумент.Ссылка + """. Рекомендуется выполнить его перезаполнение.", СвязанныйДокумент.Ссылка);
				КонецЕсли;
				
			КонецЕсли;
			
		КонецЕсли;
		
	ИначеЕсли ТипЗнч(Объект) = Тип("ДокументОбъект.КВП_КорректировкаНачислений") Тогда
		
		Если ЗначениеЗаполнено(Объект.ДокументОснование) Тогда
			
			СвязанныйДокумент = Объект.ДокументОснование.ПолучитьОбъект();
			
			СвязанныйДокумент.ДополнительныеСвойства.Вставить("ОбработкаСвязанныхДокументов", Истина);
			
			Если Не Объект.Проведен И СвязанныйДокумент.Проведен Тогда
				
				// Если отменяется проведение документа корректировки, тогда нужно перепровести документ ввода показаний, чтобы
				// восстановить движения по счетчикам с отрицательным расходом в документе ввода показаний.
				Если Не КВП_ЗаписатьОбъект(СвязанныйДокумент, РежимЗаписиДокумента.Проведение) Тогда
					Отказ = Истина;
					Возврат;
				КонецЕсли;
				
			ИначеЕсли Объект.Проведен И Не СвязанныйДокумент.Проведен Тогда
				
				// Если документ проводится, и при этом у него есть связанный документ ввода, то рекомендуем перепровести документ ввода.
				УПЖКХ_ТиповыеМетодыКлиентСервер.СообщитьПользователю("Обнаружен связанный документ """ + СвязанныйДокумент.Ссылка + """. Рекомендуется выполнить его перепроведение." + Символы.ПС +
																		"Чтобы перейти к документу, дважды нажмите на данное сообщение.", СвязанныйДокумент.Ссылка);
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры // ОбработатьСвязьДокументовВводаПоказанийИКорректировкиНачисленийПриЗаписи()

// Процедура выполняет заполнение представлений ответственных собственников л/с.
//
Процедура ЗаполнитьПредставленияОтветственныхСобственниковЛС(МассивЛицевыхСчетов = Неопределено, Ответственный = Неопределено, Отказ = Ложь) Экспорт
	
	// В запросе получаем данные о собственника из реквизита лицевого счета
	// и из регистра сведений. Если данные не совпадают, то необходимо обновить
	// представление собственника в реквизите лицевого счета.
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Период",        КонецДня(УПЖКХ_ТиповыеМетодыКлиентСервер.ПолучитьРабочуюДату()));
	Запрос.УстановитьПараметр("МассивЛС",      МассивЛицевыхСчетов);
	Запрос.УстановитьПараметр("Ответственный", Ответственный);
	
	Запрос.Текст =
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ РАЗЛИЧНЫЕ
	|	УПЖКХ_ОтветственныйСобственникНанимательЛицевогоСчетаСрезПоследних.ЛицевойСчет,
	|	УПЖКХ_ОтветственныйСобственникНанимательЛицевогоСчетаСрезПоследних.ЛицевойСчет.ОтветственныйСобственникПредставление КАК ПредставлениеОтветственногоИзЛицевогоСчета,
	|	ПРЕДСТАВЛЕНИЕ(УПЖКХ_ОтветственныйСобственникНанимательЛицевогоСчетаСрезПоследних.ОтветственныйВладелец) КАК ПредставлениеОтветственногоИзРегистра
	|ИЗ
	|	РегистрСведений.УПЖКХ_ОтветственныйСобственникНанимательЛицевогоСчета.СрезПоследних(
	|			&Период,
	|			&УсловиеОтбораЛицевогоСчета
	|				И &УсловиеОтбораПоОтветственному) КАК УПЖКХ_ОтветственныйСобственникНанимательЛицевогоСчетаСрезПоследних";
	
	УсловиеОтбораЛицевогоСчета = "ИСТИНА";
	Если ТипЗнч(МассивЛицевыхСчетов) = Тип("Массив") Тогда
		УсловиеОтбораЛицевогоСчета = "ЛицевойСчет В (&МассивЛС)";
	КонецЕсли;
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "&УсловиеОтбораЛицевогоСчета", УсловиеОтбораЛицевогоСчета);
	
	УсловиеОтбораПоОтветственному = "ИСТИНА";
	Если ТипЗнч(Ответственный) = Тип("СправочникСсылка.Контрагенты") Или ТипЗнч(Ответственный) = Тип("СправочникСсылка.УПЖКХ_Жильцы") Тогда
		УсловиеОтбораПоОтветственному = "ОтветственныйВладелец = &Ответственный";
	КонецЕсли;
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "&УсловиеОтбораПоОтветственному", УсловиеОтбораПоОтветственному);
	
	// Выполним запрос и обновим представление ответственного собственника в лицевых счетах.
	ВыборкаОтветственных = Запрос.Выполнить().Выбрать();
	Пока ВыборкаОтветственных.Следующий() Цикл
		
		Если Не ВыборкаОтветственных.ПредставлениеОтветственногоИзЛицевогоСчета = ВыборкаОтветственных.ПредставлениеОтветственногоИзРегистра Тогда
			
			// Сравниваем представление ответственного из регистра и из элемента справочника, при необходимости заменяем.
			ОбъектЛицевогоСчета = ВыборкаОтветственных.ЛицевойСчет.ПолучитьОбъект();
			ОбъектЛицевогоСчета.ОтветственныйСобственникПредставление = ВыборкаОтветственных.ПредставлениеОтветственногоИзРегистра;
			
			Если Не КВП_ЗаписатьОбъект(ОбъектЛицевогоСчета) Тогда
				Отказ = Истина;
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры // ЗаполнитьПредставленияОтветственныхСобственниковЛС()

// Процедура устанавливает использование режима отладки по умолчанию.
// По умолчанию режим отладки отключен.
//
Процедура УстановитьИспользованиеРежимаОтладкиПоУмолчанию() Экспорт
	
	Попытка
		Константы.УПЖКХ_ИспользоватьРежимОтладки.Установить(Ложь);
	Исключение
	КонецПопытки;
	
КонецПроцедуры

// Определяет, используется ли измененный макет или типовой.
//
Функция ОпределитьИспользованиеПользовательскогоМакетаПечати(НаименованиеОбъекта, НаименованиеМакета) Экспорт
	
	ИспользуетсяПользовательскийМакетПечати = Истина;
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ
	|	ПользовательскиеМакетыПечати.ИмяМакета КАК ИмяМакета,
	|	ПользовательскиеМакетыПечати.Объект КАК Объект,
	|	ПользовательскиеМакетыПечати.Макет КАК Макет,
	|	ПользовательскиеМакетыПечати.Использование КАК Использование
	|ИЗ
	|	РегистрСведений.ПользовательскиеМакетыПечати КАК ПользовательскиеМакетыПечати
	|ГДЕ
	|	ПользовательскиеМакетыПечати.Объект = &НаименованиеОбъекта
	|	И ПользовательскиеМакетыПечати.ИмяМакета = &НаименованиеМакета
	|	И ПользовательскиеМакетыПечати.Использование";
	
	Запрос.УстановитьПараметр("НаименованиеОбъекта", НаименованиеОбъекта);
	Запрос.УстановитьПараметр("НаименованиеМакета",  НаименованиеМакета);
	
	РезультатЗапроса = Запрос.Выполнить().Выгрузить();
	
	Если РезультатЗапроса.Количество() = 0 Тогда
		ИспользуетсяПользовательскийМакетПечати = Ложь;
	КонецЕсли;
	
	Возврат ИспользуетсяПользовательскийМакетПечати;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ КЛЮЧЕВОЙ СТАВКИ ЦБ

// Процедура обновляет в регистре сведений "УПЖКХ_КлючеваяСтавкаЦБ" ключевую ставку ЦБ РФ.
//
Функция ОбновлениеКлючевойСтавкиЦБ() Экспорт
	
	// Параметр успешности обновления ключевой ставки ЦБ РФ.
	ОбновлениеВыполнено = Ложь;
	
	Попытка
		
		// ОПИСАНИЕ ВЕБ-СЕРВИСА, ЕГО МЕТОДОВ И ПАРАМЕТРОВ доступно по ссылке:
		// http://www.cbr.ru/scripts/Root.asp?Prtid=DWS
		
		// Получение ключевой ставки производим с веб-сервиса сайта ЦБРФ.
		Определения = Новый WSОпределения("http://www.cbr.ru/DailyInfoWebServ/DailyInfo.asmx?WSDL"); 
		Прокси = Новый WSПрокси(Определения, "http://web.cbr.ru/", "DailyInfo", "DailyInfoSoap"); 
		ТипWSПараметра = Прокси.ФабрикаXDTO.Пакеты.Получить("http://web.cbr.ru/").Получить("MainInfoXML"); 
		WSПараметр = Прокси.ФабрикаXDTO.Создать(ТипWSПараметра); 
		РезультатXDTO = Прокси.AllDataInfoXML(WSПараметр);
		ДатаПринятияКлючевойСтавкиЦБ = РезультатXDTO.AllDataInfoXMLResult.AllData.KEY_RATE.date;
		Ставка = РезультатXDTO.AllDataInfoXMLResult.AllData.KEY_RATE.val;
		
		// Получение ставки в виде числа и даты изменения ставки в тип "Дата".
		Ставка = Число(Ставка);
		
		// Дату получаем без времени, например, "01.01.2017", для преобразования к дате добавляем время.
		ДатаПринятияКлючевойСтавкиЦБ = Дата(ДатаПринятияКлючевойСтавкиЦБ + " 00:00:00");
		
		Если ЗначениеЗаполнено(Ставка) Тогда
			
			// Проверяем, если ставка уже введена на указанную дату, то ничего не выполняем.
			// Если ставки нет, то создаем новую запись с указанием полученной ключевой ставки.
			МенеджерЗаписей = РегистрыСведений.УПЖКХ_КлючеваяСтавкаЦБ.СоздатьМенеджерЗаписи();
			
			// Устанавливаем период и считываем запись с данным периодом.
			МенеджерЗаписей.Период = ДатаПринятияКлючевойСтавкиЦБ;
			МенеджерЗаписей.Прочитать();
			
			// Если записи нет, то создаем новую.
			Если Не МенеджерЗаписей.Выбран() Тогда
				
				МенеджерЗаписей.Период = ДатаПринятияКлючевойСтавкиЦБ;
				МенеджерЗаписей.Размер = Ставка;
				
				МенеджерЗаписей.Записать();
				
			КонецЕсли;
			
			// Если ставку получили, то обновили ее, если это требуется.
			ОбновлениеВыполнено = Истина;
			
		КонецЕсли;
		
	Исключение
		
		// Определим текст информации об ошибке.
		ТекстОшибки = "При получении ключевой ставки с ресурса http://www.cbr.ru/DailyInfoWebServ/DailyInfo.asmx?WSDL возникла ошибка.
					  |Проверьте подключение к сети Интернет, а также настройки брандмауэра и антивирусного ПО.
					  |Описание ошибки: " + ОписаниеОшибки();
		
		// Сообщаем об ошибке получения ключевой ставки.
		УПЖКХ_ТиповыеМетодыКлиентСервер.СообщитьОбОшибке(ТекстОшибки);
		
		// Записать информацию об ошибке в журнал регистрации.
		ЗаписьЖурналаРегистрации("Регламентное задание. Обновление ключевой ставки ЦБ.",
								  УровеньЖурналаРегистрации.Ошибка,
								  Метаданные.РегистрыСведений.УПЖКХ_КлючеваяСтавкаЦБ,,
								  ТекстОшибки);
		
	КонецПопытки;
	
	Возврат ОбновлениеВыполнено;
	
КонецФункции

// Функция возвращает признак использования регламентного задания для обновления
// ключевой ставки ЦБРФ.
Функция ПроверитьИспользованиеРегламентногоЗаданияОбновленияКлючевойСтавкиЦБ() Экспорт
	
	// Устанавливаем привилегированный режим для работы с данным РЗ,
	// так как настройки обновления предоставляем также пользователям
	// с правами на подсистему "Учет в ЖКХ".
	УстановитьПривилегированныйРежим(Истина);
	
	РегламентноеЗадание = ПолучитьРегламентноеЗаданиеОбновленияКлючевойСтавкиЦБ();
	Возврат УПЖКХ_ТиповыеМетодыСервер.РегламентноеЗаданиеИспользуется(РегламентноеЗадание);
	
КонецФункции

// Функция возвращает расписание регламентного задания для обновления
// ключевой ставки ЦБРФ.
Функция ПолучитьРасписаниеРегламентногоЗаданияОбновленияКлючевойСтавкиЦБ() Экспорт
	
	// Устанавливаем привилегированный режим для работы с данным РЗ,
	// так как настройки обновления предоставляем также пользователям
	// с правами на подсистему "Учет в ЖКХ".
	УстановитьПривилегированныйРежим(Истина);
	
	РегламентноеЗадание = ПолучитьРегламентноеЗаданиеОбновленияКлючевойСтавкиЦБ();
	Возврат УПЖКХ_ТиповыеМетодыСервер.РасписаниеРегламентногоЗадания(РегламентноеЗадание);
	
КонецФункции

// Функция возвращает регламентное задание обновления ключевой ставки ЦБ.
//
Функция ПолучитьРегламентноеЗаданиеОбновленияКлючевойСтавкиЦБ()
	
	// Устанавливаем привилегированный режим для работы с данным РЗ,
	// так как настройки обновления предоставляем также пользователям
	// с правами на подсистему "Учет в ЖКХ".
	УстановитьПривилегированныйРежим(Истина);
	
	Возврат РегламентныеЗадания.НайтиПредопределенное("УПЖКХ_ОбновлениеКлючевойСтавкиЦБРФ");
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ПО РАБОТЕ С ОЦЕНКОЙ ПРОИЗВОДИТЕЛЬНОСТИ

// Функция возвращает таблицу ключевых операций,
// используемых для оценки производительности подсистемы ЖКХ.
//
// Возвращаемое значение:
//  ТаблицаКлючевыхОпераций - ТаблицаЗначений - структура данных,
//                            содержащая информацию о ключевых операциях ЖКХ.
Функция ПолучитьТаблицуКлючевыхОперацийЖКХ() Экспорт
	
	МетаданныеСправочника = Метаданные.Справочники.КлючевыеОперации;
	
	ТаблицаКлючевыхОпераций = Новый ТаблицаЗначений;
	ТаблицаКлючевыхОпераций.Колонки.Добавить("ИмяКлючевойОперации",    МетаданныеСправочника.Реквизиты.Имя.Тип);
	ТаблицаКлючевыхОпераций.Колонки.Добавить("НаименованиеУстаревшее", Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(МетаданныеСправочника.ДлинаНаименования)));
	ТаблицаКлючевыхОпераций.Колонки.Добавить("ЦелевоеВремя",           МетаданныеСправочника.Реквизиты.ЦелевоеВремя.Тип);
	
	ДобавитьКлючевуюОперациюВТаблицу(ТаблицаКлючевыхОпераций, "ВыгрузкаДанныхПоЛСНаСайтЖкх",                               "Выгрузка данных по лицевым счетам на сайт ЖКХ",                157);
	ДобавитьКлючевуюОперациюВТаблицу(ТаблицаКлючевыхОпераций, "ЗагрузкаПоказанийПУССайтаЖкх",                              "Загрузка показаний счетчиков с сайта ЖКХ",                     30);
	ДобавитьКлючевуюОперациюВТаблицу(ТаблицаКлючевыхОпераций, "ЗагрузкаОплатССайтаЖкх",                                    "Загрузка сведений о платежах с сайта ЖКХ",                     3);
	ДобавитьКлючевуюОперациюВТаблицу(ТаблицаКлючевыхОпераций, "ЗаполнениеДокументаНачислениеУслугПоОбычнойУслугеЖкх",      "Заполнение документа начисление услуг по обычной услуге",      23);
	ДобавитьКлючевуюОперациюВТаблицу(ТаблицаКлючевыхОпераций, "ЗаполнениеДокументаНачислениеУслугПоПУЖкх",                 "Заполнение документа начисление услуг по ПУ",                  23);
	ДобавитьКлючевуюОперациюВТаблицу(ТаблицаКлючевыхОпераций, "ЗаполнениеДокументаНачисленияПениЖкх",                      "Заполнение документа начисления пени",                         95);
	ДобавитьКлючевуюОперациюВТаблицу(ТаблицаКлючевыхОпераций, "ЗаполнениеДокументаНачисленияПениЧерезМастерНачисленийЖкх", "Заполнение документа начисления пени через мастер начислений", 153);
	ДобавитьКлючевуюОперациюВТаблицу(ТаблицаКлючевыхОпераций, "ОтражениеОплатЖкх",                                         "Отражение оплат",                                              314);
	ДобавитьКлючевуюОперациюВТаблицу(ТаблицаКлючевыхОпераций, "ПроведениеДокументаВводПоказанийСчетчикаЖкх",               "Проведение документа ввод показаний счетчика",                 1);
	ДобавитьКлючевуюОперациюВТаблицу(ТаблицаКлючевыхОпераций, "ПроведениеДокументаНачислениеУслугПоОбычнойУслугеЖкх",      "Проведение документа начисление услуг по обычной услуге",      6);
	ДобавитьКлючевуюОперациюВТаблицу(ТаблицаКлючевыхОпераций, "ПроведениеДокументаНачислениеУслугПоПУЖкх",                 "Проведение документа начисление услуг по ПУ",                  4);
	ДобавитьКлючевуюОперациюВТаблицу(ТаблицаКлючевыхОпераций, "ПроведениеДокументаНачисленияПениЖкх",                      "Проведение документа начисления пени",                         17);
	ДобавитьКлючевуюОперациюВТаблицу(ТаблицаКлючевыхОпераций, "ПроведениеДокументаРасчетЛьготЖкх",                         "Проведение документа расчет льгот",                            5);
	ДобавитьКлючевуюОперациюВТаблицу(ТаблицаКлючевыхОпераций, "ПроведениеДокументаРегистрацияОплатыЖкх",                   "Проведение документа регистрация оплаты",                      35);
	ДобавитьКлючевуюОперациюВТаблицу(ТаблицаКлючевыхОпераций, "РаботаМастераНачисленийЖкх",                                "Работа мастера начислений",                                    579);
	ДобавитьКлючевуюОперациюВТаблицу(ТаблицаКлючевыхОпераций, "РаспределениеОплатВДокументеРегистрацияОплатыЖкх",          "Распределение оплат в документе регистрация оплаты",           1);
	ДобавитьКлючевуюОперациюВТаблицу(ТаблицаКлючевыхОпераций, "РасчетЛьготНовыйМеханизмЖкх",                               "Расчет льгот новый механизм",                                  49);
	ДобавитьКлючевуюОперациюВТаблицу(ТаблицаКлючевыхОпераций, "РасчетОДНВНачисленииУслугЖкх",                              "Расчет ОДН в начислении услуг",                                6);
	ДобавитьКлючевуюОперациюВТаблицу(ТаблицаКлючевыхОпераций, "ФормированиеКвитанцийЖкх",                                  "Формирование квитанций",                                       100);
	
	Возврат ТаблицаКлючевыхОпераций;
	
КонецФункции // ПолучитьТаблицуКлючевыхОперацийЖКХ()

// Добавляет новую строку в таблицу ключевых операций.
//
// Параметры:
//  ТаблицаКлючевыхОпераций - ТаблицаЗначений - структура данных,
//                            содержащая информацию о ключевых операциях ЖКХ.
//  ИмяКлючевойОперации     - Строка - актуальное имя ключевой операции.
//  НаименованиеУстаревшее  - Строка - наименование предопределенного элемента
//                            справочника Ключевые операции (если использовалось ранее).
//  ЦелевоеВремя            - Число - целевое время выполнения ключевой операции.
//
Процедура ДобавитьКлючевуюОперациюВТаблицу(ТаблицаКлючевыхОпераций, ИмяКлючевойОперации, НаименованиеУстаревшее = "", ЦелевоеВремя = 1)
	
	НоваяСтрока = ТаблицаКлючевыхОпераций.Добавить();
	НоваяСтрока.ИмяКлючевойОперации    = ИмяКлючевойОперации;
	НоваяСтрока.НаименованиеУстаревшее = НаименованиеУстаревшее;
	НоваяСтрока.ЦелевоеВремя           = ЦелевоеВремя;
	
КонецПроцедуры // ДобавитьКлючевуюОперациюВТаблицу()

#КонецОбласти

///////////////////////////////////////////////////////////////////////////////
// РАБОТА С РОЛЯМИ

#Область РаботаСРолями

// Определяет наличие у пользователя прав на изменение текущего объекта.
//
Функция ОпределитьНаличиеПравНаРедактированиеОбъектовЖКХ() Экспорт
	
	Возврат РольДоступна("КВП_УчетВЖКХ_ДобавлениеИзменение") ИЛИ РольДоступна("ПолныеПрава");
	
КонецФункции

#КонецОбласти

///////////////////////////////////////////////////////////////////////////////
// ПРОВЕРКИ ИСПОЛЬЗОВАНИЯ СЕРВИСОВ

#Область Проверки_использования_сервисов

// Проверяет использование сервиса "Сайт ЖКХ".
// 
// Возвращаемое значение:
//  Булево.
//
Функция ИспользуетсяСервисСайтЖКХ() Экспорт
	
	Используется = Ложь;
	
	Выборка = Справочники.УПЖКХ_НастройкиДоступаКСайту.Выбрать();
	
	Пока Выборка.Следующий() Цикл
		Если Выборка.ПометкаУдаления = Ложь Тогда
			Используется = Истина;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Если Используется Тогда
		
		Запрос = Новый Запрос;
		Запрос.Текст =
		"ВЫБРАТЬ
		|	УПЖКХ_ЖурналОбменаССайтом.Дата КАК Дата
		|ИЗ
		|	РегистрСведений.УПЖКХ_ЖурналОбменаССайтом КАК УПЖКХ_ЖурналОбменаССайтом
		|ГДЕ
		|	УПЖКХ_ЖурналОбменаССайтом.Дата > &Дата
		|	И УПЖКХ_ЖурналОбменаССайтом.Статус";
		
		Запрос.УстановитьПараметр("Дата", ДобавитьМесяц(ТекущаяДата(), -3));
		
		Используется = Запрос.Выполнить().Выбрать().Следующий();
		
	КонецЕсли;
	
	Возврат Используется;
	
КонецФункции // ИспользуетсяСервисСайтЖКХ()

// Проверяет использование сервиса "Мобильное приложение ЛК ЖКХ".
// 
// Возвращаемое значение:
//  Булево.
//
Функция ИспользуетсяСервисМобильноеПриложениеЛКЖКХ() Экспорт
	
	Используется = Истина;
	
	СтруктураНастроекОбмена = УПЖКХ_ИнтеграцияСМобильнымПриложениемВзаимодействиеСБазой.ПолучитьНастройкуАвтоматическогоОбменаСМобильнымПриложением();
	
	Если ТипЗнч(СтруктураНастроекОбмена) = Тип("Структура")
	   И НЕ СтруктураНастроекОбмена.Свойство("НастройкаФормированияДанных")
	 ИЛИ (СтруктураНастроекОбмена.Свойство("НастройкаФормированияДанных")
		И (СтруктураНастроекОбмена.НастройкаФормированияДанных = Неопределено
		ИЛИ СтруктураНастроекОбмена.НастройкаФормированияДанных = Справочники.УПЖКХ_НастройкиСбораДанныхДляКвитанцийИОбменов.ПустаяСсылка())) Тогда
		
		Используется = Ложь;
		
	КонецЕсли;
	
	Возврат Используется;
	
КонецФункции // ИспользуетсяСервисМобильноеПриложениеЛКЖКХ()

// Проверяет использование сервиса автообзвона должников.
// 
// Возвращаемое значение:
//  Булево.
//
Функция ИспользуетсяСервисАвтообзвонДолжников() Экспорт
	
	Используется = Ложь;
	
	// Настройки сервиса хранятся в одной константе "УПЖКХ_НастройкиИнтеграцииСГолосовымиСервисами".
	
	СтруктураНастроек = УПЖКХ_ИнтеграцияСГолосовымиСервисамиВзаимодействиеСБазойДанных.ПолучитьНастройкиИнтеграцииСГолосовымиСервисами();
	
	Если ТипЗнч(СтруктураНастроек) = Тип("Структура") Тогда
		
		ПерсональныйURL = СтруктураНастроек.ПерсональныйURL;
		Логин           = СтруктураНастроек.Логин;
		Пароль          = СтруктураНастроек.Пароль;
		
		Если НЕ (ПустаяСтрока(ПерсональныйURL) И ПустаяСтрока(Логин) И ПустаяСтрока(Пароль)) Тогда
			
			СтруктураСоСведениямиОПодписке = УПЖКХ_ИнтеграцияСГолосовымиСервисамиВзаимодействиеССервером.ПолучитьСведенияОбУчетнойЗаписи(ПерсональныйURL, Логин, Пароль);
			
			Если ТипЗнч(СтруктураСоСведениямиОПодписке) = Тип("Структура")
			   И СтруктураСоСведениямиОПодписке.ВыполненоУспешно
			   И НЕ СтруктураСоСведениямиОПодписке.Подписка_ВидПодписки = Перечисления.УПЖКХ_ВидыПодпискиНаГолосовыеСервисы.ПриемПоказаний Тогда
				
				Используется = Истина;
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат Используется;
	
КонецФункции // ИспользуетсяСервисАвтообзвонДолжников()

// Проверяет использование сервиса "Автоматический прием показаний счетчиков".
// 
// Возвращаемое значение:
//  Булево.
//
Функция ИспользуетсяСервисАвтоматическийПриемПоказанийСчетчиков() Экспорт
	
	Используется = Ложь;
	
	СтруктураНастроек = УПЖКХ_ИнтеграцияСГолосовымиСервисамиВзаимодействиеСБазойДанных.ПолучитьНастройкиИнтеграцииСГолосовымиСервисами();
	
	Если ТипЗнч(СтруктураНастроек) = Тип("Структура") Тогда
		
		ПерсональныйURL = СтруктураНастроек.ПерсональныйURL;
		Логин           = СтруктураНастроек.Логин;
		Пароль          = СтруктураНастроек.Пароль;
		
		Если НЕ (ПустаяСтрока(ПерсональныйURL) И ПустаяСтрока(Логин) И ПустаяСтрока(Пароль)) Тогда
			
			СтруктураСоСведениямиОПодписке = УПЖКХ_ИнтеграцияСГолосовымиСервисамиВзаимодействиеССервером.ПолучитьСведенияОбУчетнойЗаписи(ПерсональныйURL, Логин, Пароль);
			
			Если СтруктураСоСведениямиОПодписке.ВыполненоУспешно
			   И НЕ СтруктураСоСведениямиОПодписке.Подписка_ВидПодписки = Перечисления.УПЖКХ_ВидыПодпискиНаГолосовыеСервисы.АвтообзвонДолжников Тогда
				
				Используется = Истина;
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат Используется;
	
КонецФункции // ИспользуетсяСервисАвтоматическийПриемПоказанийСчетчиков()

// Проверяет использование сервиса "СМС-рассылка".
// 
// Возвращаемое значение:
//  Булево.
//
Функция ИспользуетсяСервисСМСРассылка() Экспорт
	
	Используется = Ложь;
	
	Если смсНастройкаПереопределяемый.ФункционалСМСРассылкиДоступен() Тогда
		
		// Если есть факт отправки хотя бы одного смс, тогда считаем, что сервис используется.
		Запрос = Новый Запрос;
		Запрос.УстановитьПараметр("КонецПериода", КонецМесяца(ТекущаяДата()));
		
		Запрос.Текст =
		"ВЫБРАТЬ
		|	МАКСИМУМ(смсСтатистикаОтправкиСообщенийОбороты.Период) КАК ПериодПоследнейОтправкиНаСервис
		|ИЗ
		|	РегистрНакопления.смсСтатистикаОтправкиСообщений.Обороты(, &КонецПериода, Запись, ) КАК смсСтатистикаОтправкиСообщенийОбороты
		|ГДЕ
		|	смсСтатистикаОтправкиСообщенийОбороты.ПереданоНаСервисОборот = ИСТИНА
		|
		|ИМЕЮЩИЕ
		|	НЕ МАКСИМУМ(смсСтатистикаОтправкиСообщенийОбороты.Период) ЕСТЬ NULL";
		
		Используется = Запрос.Выполнить().Выбрать().Следующий();
		
	КонецЕсли;
	
	Возврат Используется;
	
КонецФункции // ИспользуетсяСервисСМСРассылка()

#КонецОбласти // Проверки_использования_сервисов
