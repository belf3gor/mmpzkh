
////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ДЛЯ РАБОТЫ С НАСТРОЙКАМИ МНОГОПОТОЧНОСТИ

#Область ПроцедурыИФункцииДляРаботыСНастройкамиМногопоточности

// Получает настройки многопоточности.
//
Функция ПолучитьНастройкиМногопоточности() Экспорт
	
	ИспользоватьМногопоточность = Константы.УПЖКХ_ИспользоватьМногопоточность.Получить();
	КоличествоПотоков           = Константы.УПЖКХ_КоличествоПотоковПриМногопоточнойОбработкеДанных.Получить();
	
	СтруктураНастроекМногопоточности = Новый Структура("ИспользоватьМногопоточность, КоличествоПотоков");
	СтруктураНастроекМногопоточности.ИспользоватьМногопоточность = ИспользоватьМногопоточность;
	СтруктураНастроекМногопоточности.КоличествоПотоков           = ?(КоличествоПотоков = 0, 1, КоличествоПотоков);
	
	Возврат СтруктураНастроекМногопоточности;
	
КонецФункции

// Определяет, нужно ли показывать гиперссылку на страницу настроек многопоточности.
//
Функция ПоказыватьСсылкиНаСтраницуНастроекМногопоточности() Экспорт
	
	ПоказыватьСсылку = НЕ УПЖКХ_ТиповыеМетодыСервер.ИнформационнаяБазаФайловая();
	
	Возврат ПоказыватьСсылку;
	
КонецФункции

// Определяет, включено ли использование многопоточности.
//
Функция ПроверитьВключенаЛиМногопоточнаяОбработкаДанных() Экспорт
	
	НастройкиМногопоточности = ПолучитьНастройкиМногопоточности();
	
	Возврат НастройкиМногопоточности.ИспользоватьМногопоточность;
	
КонецФункции

// Собирает информацию о количестве ядер и потоков процессора на сервере.
//
Функция ПолучитьИнформациюОКоличествеЯдерИПотоковПроцессора() Экспорт
	
	СтруктураИнформацииОПроцессоре = Новый Структура("ВыполненоУспешно, КоличествоЯдер, КоличествоПотоков", Ложь, 1, 1);
	
	Если ОбщегоНазначения.ЭтоLinuxСервер() Тогда
		ОпределитьКоличествоЯдерПроцессораLinux(СтруктураИнформацииОПроцессоре);
	Иначе
		ОпределитьКоличествоЯдерПроцессораWindows(СтруктураИнформацииОПроцессоре);
	КонецЕсли;
	
	Возврат СтруктураИнформацииОПроцессоре;
	
КонецФункции

// Определяет количество ядер и потоков при использовании ОС Linux.
//
Процедура ОпределитьКоличествоЯдерПроцессораLinux(СтруктураИнформацииОПроцессоре)
	
	Попытка
		
		ВременныйФайлДляХраненияРезультата = ПолучитьИмяВременногоФайла();
		
		ЗапуститьПриложение("cat /proc/cpuinfo | grep 'cpu cores' | uniq > " + ВременныйФайлДляХраненияРезультата,, Истина);
		
		Файл = Новый ЧтениеТекста;
		Файл.Открыть(ВременныйФайлДляХраненияРезультата);
		Результат = Файл.Прочитать();
		
		ПодстрокаСоЗначением = Сред(Результат, СтрНайти(Результат, ":") + 1);
		
		КоличествоЯдер = Число(ПодстрокаСоЗначением);
		
		СтруктураИнформацииОПроцессоре.ВыполненоУспешно  = Истина;
		СтруктураИнформацииОПроцессоре.КоличествоЯдер    = КоличествоЯдер;
		СтруктураИнформацииОПроцессоре.КоличествоПотоков = КоличествоЯдер;
		
	Исключение
	КонецПопытки;
	
КонецПроцедуры

// Определяет количество ядер и потоков при использовании ОС Windows.
//
Процедура ОпределитьКоличествоЯдерПроцессораWindows(СтруктураИнформацииОПроцессоре)
	
	Попытка
		
		WinMGMT = ПолучитьCOMОбъект("winmgmts:\\.\root\cimv2");
		
		Win32_Processor = WinMGMT.ExecQuery("SELECT NumberOfCores, NumberOfLogicalProcessors FROM Win32_Processor");
		
		// Определяем количество ядер и потоков только первого процессора.
		Для Каждого Processor ИЗ Win32_Processor Цикл
			КоличествоЯдер              = Processor.NumberOfCores;
			КоличествоЛогическихПотоков = Processor.NumberOfLogicalProcessors;
			
			Прервать;
		КонецЦикла;
		
		СтруктураИнформацииОПроцессоре.ВыполненоУспешно  = Истина;
		СтруктураИнформацииОПроцессоре.КоличествоЯдер    = КоличествоЯдер;
		СтруктураИнформацииОПроцессоре.КоличествоПотоков = КоличествоЛогическихПотоков;
		
	Исключение
	КонецПопытки;
	
КонецПроцедуры

#КонецОбласти

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ МНОГОПОТОЧНОЙ ОБРАБОТКИ ДАННЫХ

#Область ПроцедурыИФункцииМногопоточнойОбработкиДанных

// Выполняет запуск фоновых заданий на основании имени метода и массива наборов параметров каждого потока.
// Параметры:
//  - ИмяМетода - строка - имя экспортного метода, который нужно выполнить в каждом потоке.
//  - НаименованиеЗадания - строка - наименование задания, отображаемое в журнале фоновых заданий.
//  - МассивПараметровПотоков - массив параметров, которые необходимо передавать в потоки. При этом:
//     1. Будет создано столько потоков, сколько элементов в данном массиве.
//     2. Набор параметров для каждого потока должен быть представлен в виде массива.
//
Процедура ОбработатьМассивНаборовДанныхМногопоточно(ИмяМетода, НаименованиеЗадания, МассивПараметровПотоков) Экспорт
	
	СтруктураМногопоточнойОбработкиДанных = СоздатьСтруктуруМногопоточнойОбработкиДанных(ИмяМетода, НаименованиеЗадания);
	
	ДобавитьМассивФоновыхЗаданийВОбщийМассивФоновыхЗаданий(СтруктураМногопоточнойОбработкиДанных, МассивПараметровПотоков);
	ЗапуститьОжиданиеЗавершенияМассиваФоновыхЗаданий(СтруктураМногопоточнойОбработкиДанных);
	
КонецПроцедуры

// Создает объект (структуру), предназначенный для хранения информации о фоновых заданиях в установленном виде.
//
Функция СоздатьСтруктуруМногопоточнойОбработкиДанных(ИмяМетода, НаименованиеЗадания)
	
	СтруктураМногопоточнойОбработкиДанных = Новый Структура("ИмяМетода, НаименованиеЗадания, МассивФоновыхЗаданий, ДанныеФоновыхЗаданий, МассивИдентификаторовАварийноЗавершенныхФоновыхЗаданий");
	
	СтруктураМногопоточнойОбработкиДанных.ИмяМетода            = ИмяМетода;
	СтруктураМногопоточнойОбработкиДанных.НаименованиеЗадания  = НаименованиеЗадания;
	СтруктураМногопоточнойОбработкиДанных.МассивФоновыхЗаданий = Новый Массив;
	СтруктураМногопоточнойОбработкиДанных.ДанныеФоновыхЗаданий = Новый Соответствие;
	СтруктураМногопоточнойОбработкиДанных.МассивИдентификаторовАварийноЗавершенныхФоновыхЗаданий = Новый Массив;
	
	Возврат СтруктураМногопоточнойОбработкиДанных;
	
КонецФункции

// Заполняет массив фоновых заданий на основании массива параметров потоков.
//
Процедура ДобавитьМассивФоновыхЗаданийВОбщийМассивФоновыхЗаданий(СтруктураМногопоточнойОбработкиДанных, МассивПараметровПотоков)
	
	Для каждого ТекПараметрыПотока из МассивПараметровПотоков Цикл
		ДобавитьФоновоеЗаданиеВМассивФоновыхЗаданий(СтруктураМногопоточнойОбработкиДанных, ТекПараметрыПотока)
	КонецЦикла;
	
КонецПроцедуры

// Добавляет новое фоновое задание в массив фоновых заданий.
//
Процедура ДобавитьФоновоеЗаданиеВМассивФоновыхЗаданий(СтруктураМногопоточнойОбработкиДанных, МассивПараметров)
	
	ТекФоновоеЗадание = ФоновыеЗадания.Выполнить(СтруктураМногопоточнойОбработкиДанных.ИмяМетода, МассивПараметров, Новый УникальныйИдентификатор, СтруктураМногопоточнойОбработкиДанных.НаименованиеЗадания);
	
	СтруктураМногопоточнойОбработкиДанных.МассивФоновыхЗаданий.Добавить(ТекФоновоеЗадание);
	СтруктураМногопоточнойОбработкиДанных.ДанныеФоновыхЗаданий.Вставить(ТекФоновоеЗадание.УникальныйИдентификатор, МассивПараметров);
	
КонецПроцедуры

// Выполняет ожидание завершения фоновых заданий и обрабатывает аварийно завершенные задания.
//
Процедура ЗапуститьОжиданиеЗавершенияМассиваФоновыхЗаданий(СтруктураМногопоточнойОбработкиДанных)
	
	ЗапуститьОжиданиеЗавершения(СтруктураМногопоточнойОбработкиДанных);
	ВыполнитьАварийноЗавершенныеПотокиВТекущемСеансе(СтруктураМногопоточнойОбработкиДанных);
	
КонецПроцедуры

// Выполняет ожидание завершения фоновых заданий и накапливает информацию об аварийно завершенных заданиях.
//
Процедура ЗапуститьОжиданиеЗавершения(СтруктураМногопоточнойОбработкиДанных, НомерПопытки = 0)
	
	Попытка
		// Запускаем фоновые задания и ожидаем их завершения.
		ФоновыеЗадания.ОжидатьЗавершения(СтруктураМногопоточнойОбработкиДанных.МассивФоновыхЗаданий);
	Исключение
		
		// Определяет, не превышено ли максимальное количество перезапусков потока.
		ПревышеноКоличествоПопыток = НомерПопытки > 1;
		
		// Текущий массив фоновых заданий.
		МассивФоновыхЗаданий = СтруктураМногопоточнойОбработкиДанных.МассивФоновыхЗаданий;
		
		// Если завершилось неудачно, то перезаполняем массив фоновых заданий.
		ЗаданияДляВыполнения = Новый Массив;
		
		// Если фоновые задания существуют, то обходим каждое из них и проверяем его состояние.
		Если НЕ МассивФоновыхЗаданий.Количество() = 0 Тогда
			
			Для Сч = 0 по МассивФоновыхЗаданий.Количество() - 1 Цикл
				
				ТекФоновоеЗадание = МассивФоновыхЗаданий[Сч];
				
				// Если фоновое задание завершено аварийно, то отменяем его и создаем новое с теми же параметрами.
				Если ТекФоновоеЗадание.Состояние = СостояниеФоновогоЗадания.ЗавершеноАварийно ИЛИ ПревышеноКоличествоПопыток Тогда
					
					СтруктураМногопоточнойОбработкиДанных.МассивИдентификаторовАварийноЗавершенныхФоновыхЗаданий.Добавить(ТекФоновоеЗадание.УникальныйИдентификатор);
					ТекФоновоеЗадание.Отменить();
					
				// Если текущее фоновое задание активно, то продолжаем его выполнение.
				ИначеЕсли ТекФоновоеЗадание.Состояние = СостояниеФоновогоЗадания.Активно Тогда
					
					ЗаданияДляВыполнения.Добавить(ТекФоновоеЗадание);
					
				КонецЕсли;
				
			КонецЦикла;
			
			// Если есть, что выполнять, то запускаем ожидание выполнения потоков.
			Если НЕ ЗаданияДляВыполнения.Количество() = 0 Тогда
				
				СтруктураМногопоточнойОбработкиДанных.МассивФоновыхЗаданий = ЗаданияДляВыполнения;
				
				ЗапуститьОжиданиеЗавершения(СтруктураМногопоточнойОбработкиДанных, НомерПопытки + 1);
				
			КонецЕсли;
		КонецЕсли;
	КонецПопытки;
	
КонецПроцедуры

// Выполняет повторный запуск обработчиков, выполнявшихся в аварийно завершенных фоновых заданиях, в текущем сеансе.
//
Процедура ВыполнитьАварийноЗавершенныеПотокиВТекущемСеансе(СтруктураМногопоточнойОбработкиДанных)
	
	// Если есть фоновые задания, которые завершились не успешно, пробуем получить их данные последовательно в основном потоке/сеансе.
	Если НЕ СтруктураМногопоточнойОбработкиДанных.МассивИдентификаторовАварийноЗавершенныхФоновыхЗаданий.Количество() = 0 Тогда
		
		Попытка
			
			Для каждого ТекИдентификаторАварийногоЗадания из СтруктураМногопоточнойОбработкиДанных.МассивИдентификаторовАварийноЗавершенныхФоновыхЗаданий Цикл
				
				МассивПараметров = СтруктураМногопоточнойОбработкиДанных.ДанныеФоновыхЗаданий.Получить(ТекИдентификаторАварийногоЗадания);
				
				СтрокаВызоваПроцедуры = СтруктураМногопоточнойОбработкиДанных.ИмяМетода + ПодготовитьНаборПараметровФоновогоЗаданияИзМассива(МассивПараметров);
				
				Выполнить(СтрокаВызоваПроцедуры);
				
			КонецЦикла;
			
		Исключение
		КонецПопытки;
		
	КонецЕсли;
	
КонецПроцедуры

// Подготавливает представление набора параметров для повторного запуска обработчика фонового задания.
// Необходимо для запуска обработчика с помощью команды "Выполнить".
//
Функция ПодготовитьНаборПараметровФоновогоЗаданияИзМассива(МассивПараметров)
	
	СтрокаНабораПараметров = "(";
	
	Если ТипЗнч(МассивПараметров) = Тип("Массив") Тогда
		
		КоличествоПараметров = МассивПараметров.Количество();
		
		Если НЕ КоличествоПараметров = 0 Тогда
			
			Для ИндексТекПараметра = 0 по КоличествоПараметров - 1 Цикл
				
				СтрокаНабораПараметров = СтрокаНабораПараметров + ?(ИндексТекПараметра = 0, "", ", ") + "МассивПараметров[" + Формат(ИндексТекПараметра, "ЧГ=0;ЧН=0") + "]";
				
			КонецЦикла;
			
		КонецЕсли;
		
	КонецЕсли;
	
	СтрокаНабораПараметров = СтрокаНабораПараметров + ")";
	
	Возврат СтрокаНабораПараметров;
	
КонецФункции

#КонецОбласти

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ЗАМЕРОВ ВРЕМЕНИ

#Область ПроцедурыИФункцииЗамеровВремени

// Создает объект-таймер (структуру), предназначенную для хранения информации о текущем замере.
//
Функция СоздатьНовыйТаймер()
	
	Возврат Новый Структура("ВремяНачала, ВремяОкончания, ВремяВыполнения, ПредставлениеРезультата", 0, 0, 0, "");
	
КонецФункции

// Начинает замер времени для указанного таймера.
// 
Процедура НачатьЗамерВремениВыполнения(Таймер) Экспорт
	
	Если НЕ ТипЗнч(Таймер) = Тип("Структура") Тогда
		Таймер = СоздатьНовыйТаймер();
	КонецЕсли;
	
	Таймер.ВремяВыполнения         = 0;
	Таймер.ПредставлениеРезультата = "";
	
	ТекущееВремяВМиллисекундах = ТекущаяУниверсальнаяДатаВМиллисекундах();
	
	Таймер.ВремяНачала    = ТекущееВремяВМиллисекундах;
	Таймер.ВремяОкончания = ТекущееВремяВМиллисекундах;
	
КонецПроцедуры

// Останавливает замер времени для указанного таймера.
//
Процедура ОстановитьЗамерВремениВыполнения(Таймер) Экспорт
	
	Если НЕ ТипЗнч(Таймер) = Тип("Структура") Тогда
		Таймер = СоздатьНовыйТаймер();
		
		Возврат;
	КонецЕсли;
	
	ВремяОкончания = ТекущаяУниверсальнаяДатаВМиллисекундах();
	
	Таймер.ВремяОкончания          = ВремяОкончания;
	Таймер.ВремяВыполнения         = ВремяОкончания - Таймер.ВремяНачала;
	Таймер.ПредставлениеРезультата = ПеревестиКоличествоМиллисекундВСтроку(Таймер.ВремяВыполнения);
	
	Если УПЖКХ_ВебИнтеграцияВзаимодействиеСБазойДанных.ИспользуетсяРежимОтладки() Тогда
		УПЖКХ_ТиповыеМетодыКлиентСервер.СообщитьПользователю("Время выполнения: " + Таймер.ПредставлениеРезультата);
	КонецЕсли;
	
КонецПроцедуры

// Преобразует количество миллисекунд в строковое представление.
//
Функция ПеревестиКоличествоМиллисекундВСтроку(КоличествоМиллисекунд)
	
	МиллисекундВДне     = 86400000;
	МиллисекундВЧасе    = 3600000;
	МиллисекундВМинуте  = 60000;
	МиллисекундВСекунде = 1000;
	
	// Количество дней.
	КоличествоДней = Цел(КоличествоМиллисекунд / МиллисекундВДне);
	КоличествоМиллисекундОстаток = КоличествоМиллисекунд % МиллисекундВДне;
	
	// Количество часов.
	КоличествоЧасов = Цел(КоличествоМиллисекундОстаток / МиллисекундВЧасе);
	КоличествоМиллисекундОстаток = КоличествоМиллисекундОстаток % МиллисекундВЧасе;
	
	// Количество минут.
	КоличествоМинут = Цел(КоличествоМиллисекундОстаток / МиллисекундВМинуте);
	КоличествоМиллисекундОстаток = КоличествоМиллисекундОстаток % МиллисекундВМинуте;
	
	// Количество секунд.
	КоличествоСекунд = Цел(КоличествоМиллисекундОстаток / МиллисекундВСекунде);
	КоличествоМиллисекундОстаток = КоличествоМиллисекундОстаток % МиллисекундВСекунде;
	
	СтрокаПредставления = ?(КоличествоДней = 0, "", Строка(КоличествоДней) + " дн., ")
						+ ?(КоличествоЧасов = 0, "", Строка(КоличествоЧасов) + " ч., ")
						+ ?(КоличествоМинут = 0, "", Строка(КоличествоМинут) + " мин., ")
						+ ?(КоличествоСекунд = 0, "", Строка(КоличествоСекунд) + " сек., ")
						+ Строка(КоличествоМиллисекундОстаток) + " мс.";
	
	Возврат СтрокаПредставления;
	
КонецФункции

#КонецОбласти

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ МНОГОПОТОЧНОЙ ОБРАБОТКИ ДАННЫХ (САЙТ ЖКХ)

#Область ПроцедурыМногопоточнойОбработкиДанныхСайтЖКХ

// Выполняет многопоточную выгрузку на сайт основных учетных данных (начисления, показания по ПУ и пр.).
//
// Параметры:
//  НастройкаДоступа - текущие настройки доступа.
//  СтруктураНастроек - структура настроек сбора данных.
//  КоличествоЛСВФайле - максимальное количество л/с в файле обмена.
//  АдресСпискаФайловОбмена - адрес во временном хранилище, куда будет сохраняться массив сформированных файлов.
//  АдресСтатусаВыполнения - адрес во временном хранилище, куда будут сохраняться информация
//                           об успешности подготовоки данных (булево).
//
Процедура ВыполнитьВыгрузкуДанныхПоЛСВФоновомЗадании(НастройкаДоступа, СтруктураНастроек, КоличествоЛСВФайле, АдресСпискаФайловОбмена, АдресСтатусаВыполнения) Экспорт
	
	УПЖКХ_ВебИнтеграцияОбщегоНазначения.ВыполнитьВыгрузкуДанныхПоЛСПоЗаданнымПараметрам(НастройкаДоступа, СтруктураНастроек, КоличествоЛСВФайле, АдресСпискаФайловОбмена, АдресСтатусаВыполнения);
	
КонецПроцедуры

#КонецОбласти

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ МНОГОПОТОЧНОЙ ОБРАБОТКИ ДАННЫХ (ЖКХ: ЛИЧНЫЙ КАБИНЕТ)

#Область ПроцедурыМногопоточнойОбработкиДанныхЖКХЛичныйКабинет

// Выполняет многопоточную выгрузку на сервис "ЖКХ: Личный кабинет" основных учетных данных
// (начисления, показания по ПУ и пр.).
//
// Параметры:
//  СтруктураНастроек - структура настроек сбора данных.
//  ТаблицаЛСДляПотока - таблица лицевых счетов, по которым осуществляется выгрузка.
//  КоличествоЛСВФайле - максимальное количество л/с в файле обмена.
//  АдресСпискаФайловОбмена - адрес во временном хранилище, куда будет сохраняться массив сформированных файлов.
//  АдресСтатусаВыполнения - адрес во временном хранилище, куда будут сохраняться информация
//                           об успешности подготовоки данных (булево).
//
Процедура ВыполнитьВыгрузкуДанныхПоЛСВФоновомЗаданииЖКХЛичныйКабинет(СтруктураНастроек, ТаблицаЛСДляПотока, КоличествоЛСВФайле, АдресСпискаФайловОбмена, АдресСтатусаВыполнения) Экспорт
	
	// Подготавливаем массивы, в которых будут сохранены результаты обмена.
	СписокФайловВременный = Новый Массив;
	СписокФайлов          = Новый Массив;
	ВыполняетсяУспешно    = Истина;
	
	// Таблица всех л/с, которые нужно обработать в фоновом задании.
	ТаблицаВсехЛС = ТаблицаЛСДляПотока;
	
	УПЖКХ_ИнтеграцияСМобильнымПриложениемВзаимодействиеССервером.СформироватьДанныеПоЛС(СтруктураНастроек, ТаблицаВсехЛС, КоличествоЛСВФайле, СписокФайловВременный,, ВыполняетсяУспешно);
	
	Для каждого ТекФайл из СписокФайловВременный Цикл
		СписокФайлов.Добавить(Новый ДвоичныеДанные(ТекФайл));
	КонецЦикла;
	
	// Помещаем во временное хранилище результаты.
	ПоместитьВоВременноеХранилище(СписокФайлов,       АдресСпискаФайловОбмена);
	ПоместитьВоВременноеХранилище(ВыполняетсяУспешно, АдресСтатусаВыполнения);
	
КонецПроцедуры

#КонецОбласти

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ МНОГОПОТОЧНОЙ ОБРАБОТКИ ДАННЫХ (ПЛАТЕЖНЫЙ ДОКУМЕНТ)

#Область ПроцедурыМногопоточнойОбработкиДанныхПлатежныйДокумент

// Выполняет многопоточный сбор данных для формирования отчета "Платежный документ".
//
// Параметры:
//  СтруктураНастроек - структура настроек сбора данных.
//  АдресГотовойСтруктурДанных - адрес временного хранилища, куда будет помещен результат выполнения потока.
//
Процедура ВыполнитьСборДанныхДляПлатежныхДокументовВФоновомЗадании(СтруктураНастроек, АдресГотовойСтруктурДанных) Экспорт
	
	ИмяОбъектаОтчета = СтруктураНастроек.ОтчетОбъект;
	ОтчетОбъект      = Отчеты.УПЖКХ_ПлатежныйДокумент.ОбъектПоПолномуИмени(ИмяОбъектаОтчета);
	
	СтруктураГотовыхДанных = ОтчетОбъект.ПолучитьДанныеДляФормированияПлатежныхДокументов(СтруктураНастроек);
	
	ПоместитьВоВременноеХранилище(СтруктураГотовыхДанных, АдресГотовойСтруктурДанных);
	
КонецПроцедуры

// Выполняет многопоточное формирование отчета "Платежный документ" на основании собранных ранее данных.
//
// Параметры:
//  СтруктураГотовыхДанных - структура с данными, по которым необходимо сформировать отчет.
//  АдресГотовогоТабличногоДокумента - адрес временного хранилища, куда будет помещен табличный документ.
//  АдресТабЗначДанныеПоКвитанциям   - адрес временного хранилища, куда будет помещена таблица значений
//                                     данных для рассылки квитанций.
//
Процедура ВыполнитьФормированиеПлатежныхДокументовВФоновомЗадании(СтруктураГотовыхДанных, АдресГотовогоТабличногоДокумента, АдресТабЗначДанныеПоКвитанциям = Неопределено) Экспорт
	
	ДокументРезультат = Новый ТабличныйДокумент;
	
	ИмяОбъектаОтчета = СтруктураГотовыхДанных.СтруктураНастроек.ОтчетОбъект;
	ОтчетОбъект      = Отчеты.УПЖКХ_ПлатежныйДокумент.ОбъектПоПолномуИмени(ИмяОбъектаОтчета);
	
	ОтчетОбъект.СформироватьПлатежныйДокументНаОснованииГотовыхДанных(ДокументРезультат, СтруктураГотовыхДанных);
	
	ПоместитьВоВременноеХранилище(ДокументРезультат, АдресГотовогоТабличногоДокумента);
	
	// МеханизмРассылкиКвитанцийНаЭлекторонныйЯщики
	ИспользоватьРассылкуКвитанций = Константы.УПЖКХ_ИспользоватьРассылкуКвитанцийПоЭлектроннойПочте.Получить();
	
	Если ИспользоватьРассылкуКвитанций И АдресТабЗначДанныеПоКвитанциям <> Неопределено Тогда
		
		СтруктураНастроек = СтруктураГотовыхДанных.СтруктураНастроек;
		
		ПоместитьВоВременноеХранилище(СтруктураНастроек.ДанныеПоКвитанциям, АдресТабЗначДанныеПоКвитанциям);
		
	КонецЕсли;
	// Конец МеханизмРассылкиКвитанцийНаЭлекторонныйЯщики
	
КонецПроцедуры

#КонецОбласти

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ МНОГОПОТОЧНОЙ ОБРАБОТКИ ДАННЫХ (ГИС ЖКХ)

#Область ПроцедурыМногопоточнойОбработкиДанныхГИСЖКХ

// Выполняет многопоточный сбор данных о лицевых счетах для выгрузки сведений о л/с в ГИС ЖКХ.
//
// Параметры:
//  МассивЛС - массив л/с, по которому осуществляется сбор данных.
//  ПериодВыгрузки - период, за который выполняет сбор данных.
//  АдресТаблицыЛС - адрес временного хранилища, куда будет помещен результат выполнения потока.
//
Процедура ПолучитьДанныеОЛицевыхСчетахВФоновомЗаданииГИСЖКХ(МассивЛС, ПериодВыгрузки, АдресТаблицыЛС) Экспорт
	
	ПоместитьВоВременноеХранилище(УПЖКХ_ИнтеграцияСГИСЖКХВажныеМеханизмы.ПолучитьДанныеОЛицевыхСчетах(МассивЛС, ПериодВыгрузки), АдресТаблицыЛС);
	
КонецПроцедуры

// Выполняет многопоточный сбор данных для выгрузки платежных документов в ГИС ЖКХ.
//
// Параметры:
//  МассивЛС - массив л/с, по которому осуществляется сбор данных.
//  ТаблицаУслуг - таблица соответствия услуг в базе и кодов услуг в ГИС ЖКХ.
//  ПериодВыгрузки - период, за который выполняет сбор данных.
//  Организация - организация, для которой осуществляется сбор данных.
//  НастройкаСбораДанных - настройки сбора данных, по которым осуществляется сбор данных.
//  АдресСтруктурыДанных - адрес временного хранилища, куда будет помещен результат выполнения потока.
//
Процедура ПолучитьДанныеПлатежныхДокументовВФоновомЗаданииГИСЖКХ(МассивЛС, ТаблицаУслуг, ПериодВыгрузки, Организация, НастройкаСбораДанных, АдресСтруктурыДанных) Экспорт
	
	ПоместитьВоВременноеХранилище(УПЖКХ_ИнтеграцияСГИСЖКХВажныеМеханизмы.ПолучитьДанныеПлатежныхДокументов(МассивЛС, ТаблицаУслуг, ПериодВыгрузки, Организация, НастройкаСбораДанных), АдресСтруктурыДанных);
	
КонецПроцедуры

#КонецОбласти
